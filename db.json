{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/exturl.js","path":"js/src/exturl.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/js.cookie.js","path":"js/src/js.cookie.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scroll-cookie.js","path":"js/src/scroll-cookie.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","path":"lib/algolia-instant-search/instantsearch.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","path":"lib/canvas-nest/canvas-nest.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","path":"lib/canvas-ribbon/canvas-ribbon.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/LICENSE","path":"lib/fastclick/LICENSE","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/README.md","path":"lib/fastclick/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/bower.json","path":"lib/fastclick/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","path":"lib/jquery_lazyload/CONTRIBUTING.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","path":"lib/jquery_lazyload/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","path":"lib/jquery_lazyload/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","path":"lib/jquery_lazyload/jquery.lazyload.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","path":"lib/jquery_lazyload/jquery.scrollstop.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/font-embedded.css","path":"lib/needsharebutton/font-embedded.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.css","path":"lib/needsharebutton/needsharebutton.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.js","path":"lib/needsharebutton/needsharebutton.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","path":"lib/pace/pace-theme-barber-shop.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","path":"lib/pace/pace-theme-big-counter.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","path":"lib/pace/pace-theme-bounce.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","path":"lib/pace/pace-theme-center-atom.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","path":"lib/pace/pace-theme-center-circle.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","path":"lib/pace/pace-theme-center-radar.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","path":"lib/pace/pace-theme-center-simple.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","path":"lib/pace/pace-theme-corner-indicator.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","path":"lib/pace/pace-theme-fill-left.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","path":"lib/pace/pace-theme-flash.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","path":"lib/pace/pace-theme-loading-bar.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","path":"lib/pace/pace-theme-mac-osx.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","path":"lib/pace/pace-theme-minimal.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace.min.js","path":"lib/pace/pace.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","path":"lib/three/canvas_lines.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","path":"lib/three/canvas_sphere.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/three-waves.min.js","path":"lib/three/three-waves.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/bower.json","path":"lib/velocity/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.css","path":"lib/Han/dist/han.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.js","path":"lib/Han/dist/han.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","path":"lib/fancybox/source/blank.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","path":"lib/fancybox/source/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","path":"lib/fancybox/source/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","path":"lib/fancybox/source/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","path":"lib/fancybox/source/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","path":"lib/fancybox/source/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","path":"lib/fancybox/source/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","path":"lib/fancybox/source/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","path":"lib/fancybox/source/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","path":"lib/fastclick/lib/fastclick.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","path":"lib/fastclick/lib/fastclick.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.css","path":"lib/Han/dist/han.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.js","path":"lib/Han/dist/han.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","path":"lib/Han/dist/font/han-space.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","path":"lib/Han/dist/font/han-space.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","path":"lib/Han/dist/font/han.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff2","path":"lib/Han/dist/font/han.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","path":"lib/Han/dist/font/han.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","path":"lib/fancybox/source/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","path":"lib/fancybox/source/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","path":"lib/font-awesome/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","path":"lib/font-awesome/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","path":"lib/algolia-instant-search/instantsearch.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","path":"lib/font-awesome/fonts/fontawesome-webfont.svg","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/three.min.js","path":"lib/three/three.min.js","modified":0,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"0b5b7f798a851da68d81fc1f23e5486ea484945a","modified":1560150575679},{"_id":"themes/next/.bowerrc","hash":"3228a58ed0ece9f85e1e3136352094080b8dece1","modified":1560140051262},{"_id":"themes/next/.editorconfig","hash":"792fd2bd8174ece1a75d5fd24ab16594886f3a7f","modified":1560140051262},{"_id":"themes/next/.gitattributes","hash":"44bd4729c74ccb88110804f41746fec07bf487d4","modified":1560140051262},{"_id":"themes/next/.gitignore","hash":"0b5c2ffd41f66eb1849d6426ba8cf9649eeed329","modified":1560140051263},{"_id":"themes/next/.hound.yml","hash":"b76daa84c9ca3ad292c78412603370a367cc2bc3","modified":1560140051263},{"_id":"themes/next/.javascript_ignore","hash":"8a224b381155f10e6eb132a4d815c5b52962a9d1","modified":1560140051263},{"_id":"themes/next/.jshintrc","hash":"9928f81bd822f6a8d67fdbc909b517178533bca9","modified":1560140051263},{"_id":"themes/next/.stylintrc","hash":"b28e24704a5d8de08346c45286574c8e76cc109f","modified":1560140051264},{"_id":"themes/next/.travis.yml","hash":"d60d4a5375fea23d53b2156b764a99b2e56fa660","modified":1560140051264},{"_id":"themes/next/README.cn.md","hash":"263b74f1ac7c0f6f9424b8cced4b0b320ae61efc","modified":1560140051264},{"_id":"themes/next/LICENSE","hash":"f293bcfcdc06c0b77ba13570bb8af55eb5c059fd","modified":1560140051264},{"_id":"themes/next/README.md","hash":"287c7e6b7a6ddf75d815dda0df8bd228e3f285c5","modified":1560140051265},{"_id":"themes/next/_config.yml","hash":"5ff37e90e4d6812c8fc40c03fa6e1d903d743470","modified":1560140051265},{"_id":"themes/next/bower.json","hash":"0674f11d3d514e087a176da0e1d85c2286aa5fba","modified":1560140051265},{"_id":"themes/next/gulpfile.coffee","hash":"031bffc483e417b20e90eceb6cf358e7596d2e69","modified":1560140051265},{"_id":"themes/next/package.json","hash":"036d3a1346203d2f1a3958024df7f74e7ac07bfe","modified":1560140051291},{"_id":"source/_posts/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1560150575677},{"_id":"source/_posts/API接口约定.md","hash":"e327b574ce4f5e1060e08905ec2ae29b9874e18b","modified":1545702494959},{"_id":"source/_posts/Hbase初识.md","hash":"c7fe8265d4a3f0f7ddb9cc53c7530581089ad837","modified":1545702494121},{"_id":"source/_posts/MongoDB必知必会.md","hash":"3e08938d0db392d3b7c4fe92df58578002b78ac5","modified":1545702493960},{"_id":"source/_posts/Nginx应用 - Https.md","hash":"87daa660e3dc0d0341ad573d1a36ba720c93989b","modified":1545702492490},{"_id":"source/_posts/Nginx应用 - URL拦截.md","hash":"377caab8bb454184b432993e2d8994ae808e44e4","modified":1545702492420},{"_id":"source/_posts/Nginx应用 - 反向代理.md","hash":"9a214e5e01d84e0f5bd587fb0ff8980d01e5774c","modified":1545702493344},{"_id":"source/_posts/Nginx应用 - 流量镜像.md","hash":"20699b609e8bc32a464fff622c0bbbd0f793a36c","modified":1545702489078},{"_id":"source/_posts/Nginx应用 - 虚拟主机.md","hash":"475338dd50dd7c150d610b7881361efe8e097c80","modified":1545702489036},{"_id":"source/_posts/Nginx应用 - 负载均衡.md","hash":"432f99b0b422d726fd76fef2d9f783c7a62857b4","modified":1545702493266},{"_id":"source/_posts/Nginx应用 - 跨域访问.md","hash":"dcef6756d2286e61e97493ab1fd320f929ddaa5b","modified":1545702493125},{"_id":"source/_posts/RabbitMQ - 延迟消息.md","hash":"5396598764c34d8ed6d9135b61953b007260bac3","modified":1545702491633},{"_id":"source/_posts/RabbitMQ - 消息幂等.md","hash":"70d83bfd0634721dc9df5bbab807243c61e11364","modified":1545702491654},{"_id":"source/_posts/RabbitMQ - 顺序消息.md","hash":"1193355f040a3c9a6c2cb01cf233babdd48e92c1","modified":1545702492294},{"_id":"source/_posts/RabbitMQ必知必会.md","hash":"e776694c58e332dcaae6037ad40357874a5a012a","modified":1545702491574},{"_id":"source/_posts/Redis必知必会.md","hash":"08ea4e9c07bf9635b2d28f8f85386dd301c42a11","modified":1545702493378},{"_id":"source/_posts/并发编程必知必会.md","hash":"b2b67c8a4db2e553933ac145570fd55dd940ee4b","modified":1545702818104},{"_id":"source/_posts/排错卷宗 - MySQL引发MongoDB查询慢.md","hash":"8108dcf3ff831162302a56f78fa5496947555291","modified":1545702489789},{"_id":"source/_posts/排错卷宗 - POI引发的OOM.md","hash":"3052051b4138d53f77de5b42d4341263ad7d00b3","modified":1545702489022},{"_id":"source/_posts/排错卷宗 - UDP肉机.md","hash":"afab652de999213326d2e2d35931b75ef44cd575","modified":1545702494387},{"_id":"source/_posts/排错卷宗 - redis连接timeout.md","hash":"e023433602091c193125d4a132d654dac1a35df2","modified":1545702488926},{"_id":"source/_posts/杂谈MySQL - 优化篇.md","hash":"a32dd7738e0b5093e5878b1295d7916e77ffc202","modified":1545702494209},{"_id":"source/_posts/杂谈MySQL - 基础篇.md","hash":"3a0704388a5499872e665cb2cdc0208674a8d70e","modified":1545702494251},{"_id":"source/_posts/杂谈Spring Framework.md","hash":"81fc629d9460f6c54b310159793b1be7add6aa9a","modified":1545702494790},{"_id":"source/_posts/浅析JAVA垃圾回收.md","hash":"ec187131fd4959c099da1950268853d75431a8d1","modified":1545702490718},{"_id":"source/_posts/浅析JAVA对象模型.md","hash":"68f89e8496b116c6bbb236b3e42fe83e362c8551","modified":1545702490796},{"_id":"source/_posts/浅析JAVA集合.md","hash":"d0edc31a4ca9ab74cef437a11944c0abda00f5e7","modified":1545702490773},{"_id":"source/_posts/浅析JMM.md","hash":"5d55215d63645bb934a08f7e1c8c9d87b23290e8","modified":1545702845727},{"_id":"source/_posts/浅析JVM内存结构.md","hash":"ed4a796d855964913243866e753f3572cb21a256","modified":1545702910937},{"_id":"source/_posts/浅析JVM结构.md","hash":"5bfcc0eb6d92b93c2a7be4f885570d2fbe6010b0","modified":1545702867091},{"_id":"source/_posts/浅析JVM调试工具.md","hash":"b900dca56dcf33f2dde5287efe3acc50d1e10d86","modified":1545702489938},{"_id":"source/_posts/浅识Nginx.md","hash":"9d963d24c3de350af99dc91972bf453b6d89e990","modified":1545702492515},{"_id":"source/_posts/闲扯RESTful.md","hash":"b72af79eff4963a0412b01d560834e9631f59083","modified":1545702495332},{"_id":"source/_posts/闲扯TDD.md","hash":"c56c0910bafa3ca5bbbc2d8e3b6b9ffe8aa93828","modified":1545702495061},{"_id":"source/_posts/闲扯常用设计模式.md","hash":"e1dbc2458f890cdac6a3e5183884d2eb2149313c","modified":1545702495108},{"_id":"source/_posts/闲扯微服务.md","hash":"b070890474f3d5f27b9bef83beb34358854e840c","modified":1545702495705},{"_id":"themes/next/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1560140051254},{"_id":"themes/next/.git/config","hash":"bf7d1df65cf34d0f25a7184a58c37a09f72e4be7","modified":1560140051256},{"_id":"themes/next/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1560140036936},{"_id":"themes/next/.git/index","hash":"23f5719f67ef0a9b311c408765521e8195bbb603","modified":1560140051386},{"_id":"themes/next/.git/packed-refs","hash":"3bb2e8e3fad44742d3e3bfadfb0b4d791fe9fe9e","modified":1560140051252},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"3b5eafd32abb718e56ccf8d1cee0607ad8ce611d","modified":1560140051262},{"_id":"themes/next/.github/ISSUE_TEMPLATE.md","hash":"50d48c47162817a3810a9d9ad51104e83947419a","modified":1560140051262},{"_id":"themes/next/.github/PULL_REQUEST_TEMPLATE.md","hash":"902f627155a65099e0a37842ff396a58d0dc306f","modified":1560140051263},{"_id":"themes/next/.github/browserstack_logo.png","hash":"a6c43887f64a7f48a2814e3714eaa1215e542037","modified":1560140051263},{"_id":"themes/next/languages/de.yml","hash":"057e7df11ddeb1c8c15a5d7c5ff29430d725ec6b","modified":1560140051266},{"_id":"themes/next/languages/default.yml","hash":"44ef3f26917f467459326c2c8be2f73e4d947f35","modified":1560140051266},{"_id":"themes/next/languages/en.yml","hash":"7e680d9bb8f3a3a9d1ba1c9d312b3d257183dded","modified":1560140051266},{"_id":"themes/next/languages/fr-FR.yml","hash":"7e4eb7011b8feee641cfb11c6e73180b0ded1c0f","modified":1560140051266},{"_id":"themes/next/languages/id.yml","hash":"b5de1ea66dd9ef54cac9a1440eaa4e3f5fc011f5","modified":1560140051266},{"_id":"themes/next/languages/it.yml","hash":"aa595f2bda029f73ef7bfa104b4c55c3f4e9fb4c","modified":1560140051266},{"_id":"themes/next/languages/ja.yml","hash":"3c76e16fd19b262864475faa6854b718bc08c4d8","modified":1560140051266},{"_id":"themes/next/languages/ko.yml","hash":"ea5b46056e73ebcee121d5551627af35cbffc900","modified":1560140051267},{"_id":"themes/next/languages/nl-NL.yml","hash":"edca4f3598857dbc3cbf19ed412213329b6edd47","modified":1560140051267},{"_id":"themes/next/languages/pt-BR.yml","hash":"b1694ae766ed90277bcc4daca4b1cfa19cdcb72b","modified":1560140051267},{"_id":"themes/next/languages/pt.yml","hash":"44b61f2d085b827b507909a0b8f8ce31c6ef5d04","modified":1560140051267},{"_id":"themes/next/languages/ru.yml","hash":"98ec6f0b7183282e11cffc7ff586ceb82400dd75","modified":1560140051267},{"_id":"themes/next/languages/vi.yml","hash":"fd08d3c8d2c62965a98ac420fdaf95e54c25d97c","modified":1560140051267},{"_id":"themes/next/languages/zh-Hans.yml","hash":"16ef56d0dea94638de7d200984c90ae56f26b4fe","modified":1560140051267},{"_id":"themes/next/languages/zh-hk.yml","hash":"9396f41ae76e4fef99b257c93c7354e661f6e0fa","modified":1560140051268},{"_id":"themes/next/languages/zh-tw.yml","hash":"50b71abb3ecc0686f9739e179e2f829cd074ecd9","modified":1560140051268},{"_id":"themes/next/layout/_layout.swig","hash":"da0929166674ea637e0ad454f85ad0d7bac4aff2","modified":1560140051268},{"_id":"themes/next/layout/archive.swig","hash":"f0a8225feafd971419837cdb4bcfec98a4a59b2f","modified":1560140051289},{"_id":"themes/next/layout/category.swig","hash":"4472255f4a3e3dd6d79201523a9526dcabdfbf18","modified":1560140051289},{"_id":"themes/next/layout/index.swig","hash":"783611349c941848a0e26ee2f1dc44dd14879bd1","modified":1560140051290},{"_id":"themes/next/layout/page.swig","hash":"969caaee05bdea725e99016eb63d810893a73e99","modified":1560140051290},{"_id":"themes/next/layout/post.swig","hash":"b3589a8e46288a10d20e41c7a5985d2493725aec","modified":1560140051290},{"_id":"themes/next/layout/schedule.swig","hash":"d86f8de4e118f8c4d778b285c140474084a271db","modified":1560140051290},{"_id":"themes/next/layout/tag.swig","hash":"7e0a7d7d832883eddb1297483ad22c184e4368de","modified":1560140051290},{"_id":"themes/next/scripts/merge-configs.js","hash":"81e86717ecfb775986b945d17f0a4ba27532ef07","modified":1560140051291},{"_id":"themes/next/scripts/merge.js","hash":"9130dabe6a674c54b535f322b17d75fe6081472f","modified":1560140051292},{"_id":"themes/next/test/.jshintrc","hash":"19f93d13d1689fe033c82eb2d5f3ce30b6543cc0","modified":1560140051385},{"_id":"themes/next/test/helpers.js","hash":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1560140051385},{"_id":"themes/next/test/intern.js","hash":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1560140051385},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1560140051323},{"_id":"themes/next/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1560140036937},{"_id":"themes/next/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1560140036936},{"_id":"themes/next/.git/hooks/fsmonitor-watchman.sample","hash":"f7c0aa40cb0d620ff0bca3efe3521ec79e5d7156","modified":1560140036937},{"_id":"themes/next/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1560140036938},{"_id":"themes/next/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1560140036939},{"_id":"themes/next/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1560140036937},{"_id":"themes/next/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1560140036939},{"_id":"themes/next/.git/hooks/pre-rebase.sample","hash":"288efdc0027db4cfd8b7c47c4aeddba09b6ded12","modified":1560140036936},{"_id":"themes/next/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1560140036938},{"_id":"themes/next/.git/hooks/prepare-commit-msg.sample","hash":"2584806ba147152ae005cb675aa4f01d5d068456","modified":1560140036938},{"_id":"themes/next/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1560140036940},{"_id":"themes/next/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1560140036935},{"_id":"themes/next/.git/logs/HEAD","hash":"c098a2d162226762b9cd78148aaf881c95acd7a6","modified":1560140051255},{"_id":"themes/next/layout/_custom/header.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1560140051268},{"_id":"themes/next/layout/_custom/sidebar.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1560140051268},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"31322a7f57936cf2dc62e824af5490da5354cf02","modified":1560140051269},{"_id":"themes/next/layout/_macro/post-copyright.swig","hash":"665a928604f99d2ba7dc4a4a9150178229568cc6","modified":1560140051269},{"_id":"themes/next/layout/_macro/post.swig","hash":"446a35a2cd389f8cfc3aa38973a9b44ad0740134","modified":1560140051271},{"_id":"themes/next/layout/_macro/reward.swig","hash":"56e8d8556cf474c56ae1bef9cb7bbd26554adb07","modified":1560140051271},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"6a54c3c85ff6b19d275827a327abbf4bd99b2ebf","modified":1560140051272},{"_id":"themes/next/layout/_macro/wechat-subscriber.swig","hash":"39852700e4084ecccffa6d4669168e5cc0514c9e","modified":1560140051272},{"_id":"themes/next/layout/_partials/comments.swig","hash":"4a6f5b1792b2e5262b7fdab9a716b3108e2f09c7","modified":1560140051272},{"_id":"themes/next/layout/_partials/footer.swig","hash":"c4d6181f5d3db5365e622f78714af8cc58d7a45e","modified":1560140051273},{"_id":"themes/next/layout/_partials/head.swig","hash":"6b94fe8f3279daea5623c49ef4bb35917ba57510","modified":1560140051273},{"_id":"themes/next/layout/_partials/header.swig","hash":"ed042be6252848058c90109236ec988e392d91d4","modified":1560140051274},{"_id":"themes/next/layout/_partials/page-header.swig","hash":"1efd925d34a5d4ba2dc0838d9c86ba911e705fc9","modified":1560140051274},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"9e8e21d194ef44d271b1cca0bc1448c14d7edf4f","modified":1560140051275},{"_id":"themes/next/layout/_partials/search.swig","hash":"9dbd378e94abfcb3f864a5b8dbbf18d212ca2ee0","modified":1560140051275},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"03aaebe9d50f6acb007ec38cc04acd1cfceb404d","modified":1560140051278},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"766b2bdda29523ed6cd8d7aa197f996022f8fd94","modified":1560140051278},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"a266f96ad06ee87bdeae6e105a4b53cd587bbd04","modified":1560140051279},{"_id":"themes/next/layout/_third-party/duoshuo-hot-articles.swig","hash":"5d4638c46aef65bf32a01681495b62416ccc98db","modified":1560140051286},{"_id":"themes/next/layout/_third-party/exturl.swig","hash":"7c04a42319d728be356746363aff8ea247791d24","modified":1560140051286},{"_id":"themes/next/layout/_third-party/mathjax.swig","hash":"6d25596d6a7c57700d37b607f8d9a62d89708683","modified":1560140051286},{"_id":"themes/next/layout/_third-party/needsharebutton.swig","hash":"5fe0447cc88a5a63b530cf0426f93c4634811876","modified":1560140051286},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"fc93b1a7e6aed0dddb1f3910142b48d8ab61174e","modified":1560140051287},{"_id":"themes/next/layout/_third-party/schedule.swig","hash":"22369026c87fc23893c35a7f250b42f3bb1b60f1","modified":1560140051287},{"_id":"themes/next/layout/_third-party/scroll-cookie.swig","hash":"1ddb2336a1a19b47af3017047012c01ec5f54529","modified":1560140051287},{"_id":"themes/next/scripts/tags/button.js","hash":"d023f10a00077f47082b0517e2ad666e6e994f60","modified":1560140051292},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"535fc542781021c4326dec24d8495cbb1387634a","modified":1560140051292},{"_id":"themes/next/scripts/tags/exturl.js","hash":"8d7e60f60779bde050d20fd76f6fdc36fc85e06d","modified":1560140051293},{"_id":"themes/next/scripts/tags/full-image.js","hash":"8eeb3fb89540299bdbb799edfdfdac3743b50596","modified":1560140051293},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"49252824cd53184dc9b97b2f2d87ff28e1b3ef27","modified":1560140051293},{"_id":"themes/next/scripts/tags/label.js","hash":"2f8f41a7316372f0d1ed6b51190dc4acd3e16fff","modified":1560140051293},{"_id":"themes/next/scripts/tags/lazy-image.js","hash":"eeeabede68cf263de9e6593ecf682f620da16f0a","modified":1560140051294},{"_id":"themes/next/scripts/tags/note.js","hash":"64de4e9d01cf3b491ffc7d53afdf148ee5ad9779","modified":1560140051294},{"_id":"themes/next/scripts/tags/tabs.js","hash":"5786545d51c38e8ca38d1bfc7dd9e946fc70a316","modified":1560140051294},{"_id":"themes/next/source/css/main.styl","hash":"20702c48d6053c92c5bcdbc68e8d0ef1369848a0","modified":1560140051323},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1560140051323},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1560140051324},{"_id":"themes/next/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1560140051324},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1560140051324},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1560140051325},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1560140051325},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1560140051325},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1560140051325},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1560140051326},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1560140051326},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1560140051326},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1560140051327},{"_id":"themes/next/source/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1560140051327},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1560140051327},{"_id":"themes/next/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1560140051328},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1560140051327},{"_id":"themes/next/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1560140051328},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1560140051328},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1560140051279},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1560140051279},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1560140051314},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1560140051314},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1560140051315},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1560140051322},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1560140051322},{"_id":"themes/next/.git/refs/heads/master","hash":"3c959678e3fe6e51e935526c19927d21443a3be3","modified":1560140051255},{"_id":"themes/next/layout/_partials/head/custom-head.swig","hash":"9e1b9666efa77f4cf8d8261bcfa445a9ac608e53","modified":1560140051274},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"7ce76358411184482bb0934e70037949dd0da8ca","modified":1560140051274},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"957701729b85fb0c5bfcf2fb99c19d54582f91ed","modified":1560140051275},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"959b7e04a96a5596056e4009b73b6489c117597e","modified":1560140051276},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"eefe2388ff3d424694045eda21346989b123977c","modified":1560140051276},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"23e23dc0f76ef3c631f24c65277adf7ea517b383","modified":1560140051276},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"1f1107468aaf03f7d0dcd7eb2b653e2813a675b4","modified":1560140051276},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"89c5a5240ecb223acfe1d12377df5562a943fd5d","modified":1560140051277},{"_id":"themes/next/layout/_partials/share/jiathis.swig","hash":"048fd5e98149469f8c28c21ba3561a7a67952c9b","modified":1560140051277},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"069d1357c717572256e5cdee09574ebce529cbae","modified":1560140051278},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1560140051279},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1560140051279},{"_id":"themes/next/layout/_third-party/analytics/analytics-with-widget.swig","hash":"98df9d72e37dd071e882f2d5623c9d817815b139","modified":1560140051280},{"_id":"themes/next/layout/_third-party/analytics/application-insights.swig","hash":"60426bf73f8a89ba61fb1be2df3ad5398e32c4ef","modified":1560140051280},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"deda6a814ed48debc694c4e0c466f06c127163d0","modified":1560140051280},{"_id":"themes/next/layout/_third-party/analytics/busuanzi-counter.swig","hash":"18e7bef8923d83ea42df6c97405e515a876cede4","modified":1560140051281},{"_id":"themes/next/layout/_third-party/analytics/cnzz-analytics.swig","hash":"8160b27bee0aa372c7dc7c8476c05bae57f58d0f","modified":1560140051281},{"_id":"themes/next/layout/_third-party/analytics/facebook-sdk.swig","hash":"a234c5cd1f75ca5731e814d0dbb92fdcf9240d1b","modified":1560140051281},{"_id":"themes/next/layout/_third-party/analytics/firestore.swig","hash":"1cd01c6e92ab1913d48e556a92bb4f28b6dc4996","modified":1560140051281},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"5d9943d74cc2e0a91badcf4f755c6de77eab193a","modified":1560140051282},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"5e9bb24c750b49513d9a65799e832f07410002ac","modified":1560140051282},{"_id":"themes/next/layout/_third-party/analytics/lean-analytics.swig","hash":"fc65b9c98a0a8ab43a5e7aabff6c5f03838e09c8","modified":1560140051282},{"_id":"themes/next/layout/_third-party/analytics/tencent-analytics.swig","hash":"3658414379e0e8a34c45c40feadc3edc8dc55f88","modified":1560140051283},{"_id":"themes/next/layout/_third-party/analytics/tencent-mta.swig","hash":"0ddc94ed4ba0c19627765fdf1abc4d8efbe53d5a","modified":1560140051283},{"_id":"themes/next/layout/_third-party/analytics/vkontakte-api.swig","hash":"c3971fd154d781088e1cc665035f8561a4098f4c","modified":1560140051283},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"0e3378f7c39b2b0f69638290873ede6b6b6825c0","modified":1560140051284},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"c316758546dc9ba6c60cb4d852c17ca6bb6d6724","modified":1560140051284},{"_id":"themes/next/layout/_third-party/comments/duoshuo.swig","hash":"a356b2185d40914447fde817eb3d358ab6b3e4c3","modified":1560140051284},{"_id":"themes/next/layout/_third-party/comments/gitment.swig","hash":"10160daceaa6f1ecf632323d422ebe2caae49ddf","modified":1560140051284},{"_id":"themes/next/layout/_third-party/comments/hypercomments.swig","hash":"3e8dc5c6c912628a37e3b5f886bec7b2e5ed14ea","modified":1560140051285},{"_id":"themes/next/layout/_third-party/comments/index.swig","hash":"aa0629277d751c55c6d973e7691bf84af9b17a60","modified":1560140051285},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"8a2e393d2e49f7bf560766d8a07cd461bf3fce4f","modified":1560140051285},{"_id":"themes/next/layout/_third-party/comments/valine.swig","hash":"fcabbb241f894c9a6309c44e126cf3e8fea81fd4","modified":1560140051285},{"_id":"themes/next/layout/_third-party/comments/youyan.swig","hash":"8b6650f77fe0a824c8075b2659e0403e0c78a705","modified":1560140051286},{"_id":"themes/next/layout/_third-party/search/index.swig","hash":"c747fb5c6b1f500e8f0c583e44195878b66e4e29","modified":1560140051288},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"385c066af96bee30be2459dbec8aae1f15d382f5","modified":1560140051288},{"_id":"themes/next/layout/_third-party/seo/baidu-push.swig","hash":"c057b17f79e8261680fbae8dc4e81317a127c799","modified":1560140051289},{"_id":"themes/next/layout/_third-party/search/tinysou.swig","hash":"cb3a5d36dbe1630bab84e03a52733a46df7c219b","modified":1560140051289},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"328d9a9696cc2ccf59c67d3c26000d569f46344c","modified":1560140051314},{"_id":"themes/next/source/css/_mixins/Gemini.styl","hash":"2aa5b7166a85a8aa34b17792ae4f58a5a96df6cc","modified":1560140051314},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"9ab65361ba0a12a986edd103e56492644c2db0b8","modified":1560140051314},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"82f9055955920ed88a2ab6a20ab02169abb2c634","modified":1560140051315},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"99fbb4686ea9a3e03a4726ed7cf4d8f529034452","modified":1560140051321},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"be087dcc060e8179f7e7f60ab4feb65817bd3d9f","modified":1560140051322},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"f29165e36489a87ba32d17dddfd2720d84e3f3ec","modified":1560140051322},{"_id":"themes/next/source/css/_variables/base.styl","hash":"29c261fa6b4046322559074d75239c6b272fb8a3","modified":1560140051322},{"_id":"themes/next/source/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1560140051329},{"_id":"themes/next/source/js/src/algolia-search.js","hash":"b172f697ed339a24b1e80261075232978d164c35","modified":1560140051329},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"034bc8113e0966fe2096ba5b56061bbf10ef0512","modified":1560140051329},{"_id":"themes/next/source/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1560140051329},{"_id":"themes/next/source/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1560140051330},{"_id":"themes/next/source/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1560140051330},{"_id":"themes/next/source/js/src/motion.js","hash":"754b294394f102c8fd9423a1789ddb1201677898","modified":1560140051330},{"_id":"themes/next/source/js/src/post-details.js","hash":"a13f45f7aa8291cf7244ec5ba93907d119c5dbdd","modified":1560140051331},{"_id":"themes/next/source/js/src/scroll-cookie.js","hash":"09dc828cbf5f31158ff6250d2bf7c3cde6365c67","modified":1560140051331},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1560140051331},{"_id":"themes/next/source/js/src/utils.js","hash":"9b1325801d27213083d1487a12b1a62b539ab6f8","modified":1560140051332},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1560140051337},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1560140051341},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","hash":"ff5915eb2596e890a2fc6697c864f861a1995ec0","modified":1560140051341},{"_id":"themes/next/source/lib/fancybox/.bower.json","hash":"cc40a9b11e52348e554c84e4a5c058056f6b7aeb","modified":1560140051342},{"_id":"themes/next/source/lib/fancybox/.gitattributes","hash":"2db21acfbd457452462f71cc4048a943ee61b8e0","modified":1560140051342},{"_id":"themes/next/source/lib/fastclick/.bower.json","hash":"93ebd5b35e632f714dcf1753e1f6db77ec74449b","modified":1560140051348},{"_id":"themes/next/source/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1560140051348},{"_id":"themes/next/source/lib/fastclick/README.md","hash":"1decd8e1adad2cd6db0ab50cf56de6035156f4ea","modified":1560140051348},{"_id":"themes/next/source/lib/fastclick/bower.json","hash":"13379463c7463b4b96d13556b46faa4cc38d81e6","modified":1560140051348},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"a2aaaf12378db56bd10596ba3daae30950eac051","modified":1560140051350},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1560140051350},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1560140051350},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1560140051350},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1560140051351},{"_id":"themes/next/source/lib/jquery/.bower.json","hash":"91745c2cc6c946c7275f952b2b0760b880cea69e","modified":1560140051366},{"_id":"themes/next/source/lib/jquery_lazyload/.bower.json","hash":"b7638afc93e9cd350d0783565ee9a7da6805ad8e","modified":1560140051367},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","hash":"4891864c24c28efecd81a6a8d3f261145190f901","modified":1560140051367},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","hash":"895d50fa29759af7835256522e9dd7dac597765c","modified":1560140051368},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","hash":"65bc85d12197e71c40a55c0cd7f6823995a05222","modified":1560140051368},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1560140051368},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1560140051369},{"_id":"themes/next/source/lib/needsharebutton/font-embedded.css","hash":"c39d37278c1e178838732af21bd26cd0baeddfe0","modified":1560140051369},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.css","hash":"3ef0020a1815ca6151ea4886cd0d37421ae3695c","modified":1560140051370},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.js","hash":"9885fd9bea5e7ebafc5b1de9d17be5e106248d96","modified":1560140051370},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1560140051370},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1560140051371},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1560140051371},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1560140051371},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1560140051371},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1560140051371},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1560140051372},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1560140051372},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1560140051372},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1560140051372},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1560140051373},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1560140051373},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1560140051373},{"_id":"themes/next/source/lib/pace/pace.min.js","hash":"9944dfb7814b911090e96446cea4d36e2b487234","modified":1560140051373},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","hash":"dce4a3b65f8bf958f973690caa7ec4952f353b0c","modified":1560140051374},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","hash":"d8ea241a53c135a650f7335d2b6982b899fd58a9","modified":1560140051374},{"_id":"themes/next/source/lib/three/three-waves.min.js","hash":"d968cba6b3a50b3626a02d67b544f349d83b147c","modified":1560140051375},{"_id":"themes/next/source/lib/velocity/.bower.json","hash":"05f960846f1c7a93dab1d3f9a1121e86812e8c88","modified":1560140051380},{"_id":"themes/next/source/lib/velocity/bower.json","hash":"2ec99573e84c7117368beccb9e94b6bf35d2db03","modified":1560140051380},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1560140051384},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1560140051383},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1560140051384},{"_id":"themes/next/source/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1560140051367},{"_id":"themes/next/.git/logs/refs/heads/master","hash":"c098a2d162226762b9cd78148aaf881c95acd7a6","modified":1560140051256},{"_id":"themes/next/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1560140051254},{"_id":"themes/next/layout/_third-party/search/algolia-search/assets.swig","hash":"28ff4ed6714c59124569ffcbd10f1173d53ca923","modified":1560140051288},{"_id":"themes/next/layout/_third-party/search/algolia-search/dom.swig","hash":"ba698f49dd3a868c95b240d802f5b1b24ff287e4","modified":1560140051288},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"4719ce717962663c5c33ef97b1119a0b3a4ecdc3","modified":1560140051295},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"31050fc7a25784805b4843550151c93bfa55c9c8","modified":1560140051295},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"7e509c7c28c59f905b847304dd3d14d94b6f3b8e","modified":1560140051295},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"471f1627891aca5c0e1973e09fbcb01e1510d193","modified":1560140051295},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"a6bb5256be6195e76addbda12f4ed7c662d65e7a","modified":1560140051296},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"c5d48863f332ff8ce7c88dec2c893f709d7331d3","modified":1560140051299},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"dd8a3b22fc2f222ac6e6c05bd8a773fb039169c0","modified":1560140051306},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"2186be20e317505cd31886f1291429cc21f76703","modified":1560140051312},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"f7c44b0ee46cf2cf82a4c9455ba8d8b55299976f","modified":1560140051312},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"9c25c75311e1bd4d68df031d3f2ae6d141a90766","modified":1560140051312},{"_id":"themes/next/source/css/_common/scaffolding/mobile.styl","hash":"47a46583a1f3731157a3f53f80ed1ed5e2753e8e","modified":1560140051313},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"ece571f38180febaf02ace8187ead8318a300ea7","modified":1560140051313},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"a280a583b7615e939aaddbf778f5c108ef8a2a6c","modified":1560140051313},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"64f5d56c08d74a338813df1265580ca0cbf0190b","modified":1560140051313},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"18c3336ee3d09bd2da6a876e1336539f03d5a973","modified":1560140051315},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"0efa036a15c18f5abb058b7c0fad1dd9ac5eed4c","modified":1560140051318},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"8829bc556ca38bfec4add4f15a2f028092ac6d46","modified":1560140051318},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"4aac01962520d60b03b23022ab601ad4bd19c08c","modified":1560140051318},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1560140051319},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"a0e2030a606c934fb2c5c7373aaae04a1caac4c5","modified":1560140051319},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"c2d079788d6fc2e9a191ccdae94e50d55bf849dc","modified":1560140051315},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"5ae7906dc7c1d9468c7f4b4a6feddddc555797a1","modified":1560140051316},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"38e5df90c8689a71c978fd83ba74af3d4e4e5386","modified":1560140051316},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"b0dcca862cd0cc6e732e33d975b476d744911742","modified":1560140051316},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"3b25edfa187d1bbbd0d38b50dd013cef54758abf","modified":1560140051316},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1560140051316},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"9a5581a770af8964064fef7afd3e16963e45547f","modified":1560140051317},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"c4ed249798296f60bda02351fe6404fb3ef2126f","modified":1560140051320},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"5b93958239d3d2bf9aeaede44eced2434d784462","modified":1560140051320},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"215de948be49bcf14f06d500cef9f7035e406a43","modified":1560140051320},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"2f878213cb24c5ddc18877f6d15ec5c5f57745ac","modified":1560140051320},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"9d16fa3c14ed76b71229f022b63a02fd0f580958","modified":1560140051321},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"69ecd6c97e7cdfd822ac8102b45ad0ede85050db","modified":1560140051321},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"8050a5b2683d1d77238c5762b6bd89c543daed6e","modified":1560140051331},{"_id":"themes/next/source/lib/Han/dist/han.min.css","hash":"a0c9e32549a8b8cf327ab9227b037f323cdb60ee","modified":1560140051336},{"_id":"themes/next/source/lib/Han/dist/han.min.js","hash":"f559c68a25065a14f47da954a7617d87263e409d","modified":1560140051337},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1560140051342},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1560140051342},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1560140051343},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1560140051343},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1560140051343},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1560140051344},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1560140051346},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1560140051347},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1560140051347},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1560140051349},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1560140051349},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1560140051351},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1560140051352},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1560140051352},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1560140051379},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1560140051380},{"_id":"themes/next/source/lib/Han/dist/han.css","hash":"bd40da3fba8735df5850956814e312bd7b3193d7","modified":1560140051335},{"_id":"themes/next/source/lib/Han/dist/han.js","hash":"e345397e0585c9fed1449e614ec13e0224acf2ab","modified":1560140051336},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1560140051365},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1560140051365},{"_id":"themes/next/source/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1560140051382},{"_id":"themes/next/.git/logs/refs/remotes/origin/HEAD","hash":"c098a2d162226762b9cd78148aaf881c95acd7a6","modified":1560140051254},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"7905a7f625702b45645d8be1268cb8af3f698c70","modified":1560140051296},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"ae1ca14e51de67b07dba8f61ec79ee0e2e344574","modified":1560140051296},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d27448f199fc2f9980b601bc22b87f08b5d64dd1","modified":1560140051296},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"8a2421cb9005352905fae9d41a847ae56957247e","modified":1560140051297},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"6c00f6e0978f4d8f9a846a15579963728aaa6a17","modified":1560140051297},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"49c2b2c14a1e7fcc810c6be4b632975d0204c281","modified":1560140051297},{"_id":"themes/next/source/css/_common/components/highlight/diff.styl","hash":"96f32ea6c3265a3889e6abe57587f6e2a2a40dfb","modified":1560140051297},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"25dc25f61a232f03ca72472b7852f882448ec185","modified":1560140051298},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"b76387934fb6bb75212b23c1a194486892cc495e","modified":1560140051298},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"f5aa2ba3bfffc15475e7e72a55b5c9d18609fdf5","modified":1560140051298},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"4eff5b252d7b614e500fc7d52c97ce325e57d3ab","modified":1560140051298},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"2039590632bba3943c39319d80ef630af7928185","modified":1560140051299},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"9bf4362a4d0ae151ada84b219d39fbe5bb8c790e","modified":1560140051299},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"a82afbb72d83ee394aedc7b37ac0008a9823b4f4","modified":1560140051299},{"_id":"themes/next/source/css/_common/components/post/post-button.styl","hash":"e72a89e0f421444453e149ba32c77a64bd8e44e8","modified":1560140051300},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"0f7f522cc6bfb3401d5afd62b0fcdf48bb2d604b","modified":1560140051300},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"f54367c0feda6986c030cc4d15a0ca6ceea14bcb","modified":1560140051300},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"2cdc094ecf907a02fce25ad4a607cd5c40da0f2b","modified":1560140051300},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"535b3b4f8cb1eec2558e094320e7dfb01f94c0e7","modified":1560140051301},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"387ce23bba52b22a586b2dfb4ec618fe1ffd3926","modified":1560140051301},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"aea21141015ca8c409d8b33e3e34ec505f464e93","modified":1560140051301},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"a5d8617a24d7cb6c5ad91ea621183ca2c0917331","modified":1560140051302},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"36332c8a91f089f545f3c3e8ea90d08aa4d6e60c","modified":1560140051302},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"017074ef58166e2d69c53bb7590a0e7a8947a1ed","modified":1560140051302},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"a352ae5b1f8857393bf770d2e638bf15f0c9585d","modified":1560140051302},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"d5a4e4fc17f1f7e7c3a61b52d8e2e9677e139de7","modified":1560140051303},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"10251257aceecb117233c9554dcf8ecfef8e2104","modified":1560140051303},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"e4055a0d2cd2b0ad9dc55928e2f3e7bd4e499da3","modified":1560140051303},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"262debfd4442fa03d9919ceb88b948339df03fb0","modified":1560140051303},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"0a6c0efffdf18bddbc1d1238feaed282b09cd0fe","modified":1560140051304},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"920343e41c124221a17f050bbb989494d44f7a24","modified":1560140051304},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"89dd4f8b1f1cce3ad46cf2256038472712387d02","modified":1560140051304},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-dimmer.styl","hash":"efa5e5022e205b52786ce495d4879f5e7b8f84b2","modified":1560140051304},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"9486ddd2cb255227db102d09a7df4cae0fabad72","modified":1560140051305},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"45fa7193435a8eae9960267438750b4c9fa9587f","modified":1560140051305},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"12937cae17c96c74d5c58db6cb29de3b2dfa14a2","modified":1560140051305},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"f7784aba0c1cd20d824c918c120012d57a5eaa2a","modified":1560140051305},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"50305b6ad7d09d2ffa4854e39f41ec1f4fe984fd","modified":1560140051306},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"3623e7fa4324ec1307370f33d8f287a9e20a5578","modified":1560140051306},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"c2abe4d87148e23e15d49ee225bc650de60baf46","modified":1560140051307},{"_id":"themes/next/source/css/_common/components/tags/exturl.styl","hash":"1b3cc9f4e5a7f6e05b4100e9990b37b20d4a2005","modified":1560140051307},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"37e951e734a252fe8a81f452b963df2ba90bfe90","modified":1560140051307},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"4851b981020c5cbc354a1af9b831a2dcb3cf9d39","modified":1560140051307},{"_id":"themes/next/source/css/_common/components/tags/label.styl","hash":"4a457d265d62f287c63d48764ce45d9bcfc9ec5a","modified":1560140051308},{"_id":"themes/next/source/css/_common/components/tags/note-modern.styl","hash":"ee7528900578ef4753effe05b346381c40de5499","modified":1560140051308},{"_id":"themes/next/source/css/_common/components/tags/note.styl","hash":"32c9156bea5bac9e9ad0b4c08ffbca8b3d9aac4b","modified":1560140051308},{"_id":"themes/next/source/css/_common/components/tags/tabs.styl","hash":"4ab5deed8c3b0c338212380f678f8382672e1bcb","modified":1560140051308},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"ead0d0f2321dc71505788c7f689f92257cf14947","modified":1560140051309},{"_id":"themes/next/source/css/_common/components/third-party/algolia-search.styl","hash":"fd42777b9125fd8969dc39d4f15473e2b91b4142","modified":1560140051309},{"_id":"themes/next/source/css/_common/components/third-party/baidushare.styl","hash":"93b08815c4d17e2b96fef8530ec1f1064dede6ef","modified":1560140051309},{"_id":"themes/next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"d4e6d8d7b34dc69994593c208f875ae8f7e8a3ae","modified":1560140051309},{"_id":"themes/next/source/css/_common/components/third-party/duoshuo.styl","hash":"2340dd9b3202c61d73cc708b790fac5adddbfc7f","modified":1560140051310},{"_id":"themes/next/source/css/_common/components/third-party/gitment.styl","hash":"34935b40237c074be5f5e8818c14ccfd802b7439","modified":1560140051310},{"_id":"themes/next/source/css/_common/components/third-party/han.styl","hash":"cce6772e2cdb4db85d35486ae4c6c59367fbdd40","modified":1560140051310},{"_id":"themes/next/source/css/_common/components/third-party/jiathis.styl","hash":"327b5f63d55ec26f7663185c1a778440588d9803","modified":1560140051311},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"d89c4b562b528e4746696b2ad8935764d133bdae","modified":1560140051311},{"_id":"themes/next/source/css/_common/components/third-party/needsharebutton.styl","hash":"a5e3e6b4b4b814a9fe40b34d784fed67d6d977fa","modified":1560140051311},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"1ccfbd4d0f5754b2dc2719a91245c95f547a7652","modified":1560140051311},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1560140051319},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"5dc4859c66305f871e56cba78f64bfe3bf1b5f01","modified":1560140051317},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1560140051317},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1560140051333},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1560140051333},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1560140051333},{"_id":"themes/next/source/lib/Han/dist/font/han.woff2","hash":"623af3ed5423371ac136a4fe0e8cc7bb7396037a","modified":1560140051334},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1560140051334},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1560140051344},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1560140051345},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1560140051344},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1560140051345},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1560140051345},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1560140051346},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1560140051354},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1560140051357},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1560140051364},{"_id":"themes/next/.git/objects/pack/pack-a8cd1e4b028edc0f794785aaf594da4318fa74ae.idx","hash":"8dee2350ff4e3068f3184d4793686e0cec509227","modified":1560140051240},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1560140051340},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1560140051362},{"_id":"themes/next/source/lib/three/three.min.js","hash":"73f4cdc17e51a72b9bf5b9291f65386d615c483b","modified":1560140051379},{"_id":"themes/next/.git/objects/pack/pack-a8cd1e4b028edc0f794785aaf594da4318fa74ae.pack","hash":"41786ceaa4a41528e8df91f72cf35baca151e717","modified":1560140051236},{"_id":"public/2018/10/13/Nginx应用 - 流量镜像/index.html","hash":"24426cb018fb3155f7892a0db06737b552e31dda","modified":1560152543109},{"_id":"public/2018/10/13/Nginx应用 - 跨域访问/index.html","hash":"a7c70bd9aaaca2f8ef583de8b89accc26c670b83","modified":1560152543110},{"_id":"public/2018/09/14/排错卷宗 - UDP肉机/index.html","hash":"c108833c577f17752fe7d2b7bb6b05d353fc1da9","modified":1560152543120},{"_id":"public/2018/08/19/API接口约定/index.html","hash":"0f1793dc4a3c60708799063cd9bd66f2387e18c1","modified":1560152543120},{"_id":"public/2018/08/13/闲扯TDD/index.html","hash":"9b7a440d3cbfb05850c5b0f04397a2d9b168c4c4","modified":1560152543120},{"_id":"public/2018/08/08/排错卷宗 - MySQL引发MongoDB查询慢/index.html","hash":"ced70510851904486256887ff5854865816ec61e","modified":1560152543120},{"_id":"public/2018/07/15/浅析JAVA对象模型/index.html","hash":"796db0943b5a1108109881ffc1e478535f3e11d9","modified":1560152543120},{"_id":"public/2018/06/01/Nginx应用 - 反向代理/index.html","hash":"14dd5747fe846ae9923e5b06852bc64e3c4b33a1","modified":1560152543120},{"_id":"public/2018/06/01/Nginx应用 - URL拦截/index.html","hash":"5a9d6593b8eca0680d6ac0ac9878f8edcbde9598","modified":1560152543120},{"_id":"public/2018/03/24/RabbitMQ - 消息幂等/index.html","hash":"e0c0a62db0b75e84452a02083015014f147f956b","modified":1560152543120},{"_id":"public/2017/11/12/闲扯RESTful/index.html","hash":"74303a53bf38dca4e558278e7145cf8240bd1f80","modified":1560152543121},{"_id":"public/2017/10/21/排错卷宗 - POI引发的OOM/index.html","hash":"97413fcd65136bebab65cd06f4c541066f364304","modified":1560152543121},{"_id":"public/2017/10/13/Nginx应用 - 虚拟主机/index.html","hash":"5ea32af21d6d9bb5741ffd79b05bb243dd711ecc","modified":1560152543121},{"_id":"public/2017/10/08/Nginx应用 - Https/index.html","hash":"a22bf36aa539cefc38a69be758b85de0a12ce741","modified":1560152543121},{"_id":"public/2017/05/29/RabbitMQ - 顺序消息/index.html","hash":"0ed359bd5b13033f81f8477fcf272c432ce7a03e","modified":1560152543121},{"_id":"public/archives/index.html","hash":"82a9f8e5e84987fc3721ae88b82c11c1d2bfa814","modified":1560152543121},{"_id":"public/archives/page/2/index.html","hash":"a2b0003b1e64ded4a7ae966127437ef4fbd5e7b4","modified":1560152543121},{"_id":"public/2018/09/25/排错卷宗 - redis连接timeout/index.html","hash":"d1cb4b64dc878432febda57dae7178848f5efe1e","modified":1560152543121},{"_id":"public/2018/09/16/RabbitMQ必知必会/index.html","hash":"088dad47c3dc07ed857dfae61e90968580cb243c","modified":1560152543121},{"_id":"public/2018/08/30/浅析JVM结构/index.html","hash":"7e353b6da2d36aa5ce9fc5820aca5c48265fc944","modified":1560152543121},{"_id":"public/2018/08/11/浅析JVM内存结构/index.html","hash":"c4287b1d97e28471fcdfe8ebf594d707bbec4fa9","modified":1560152543121},{"_id":"public/2018/07/12/杂谈Spring Framework/index.html","hash":"1f76e94a5c618f51dc3de6825125c3ddf243ce34","modified":1560152543121},{"_id":"public/2018/07/12/并发编程必知必会/index.html","hash":"caede94c3b0493dd85479f4c4887d583521edefc","modified":1560152543121},{"_id":"public/2018/07/01/浅析JMM/index.html","hash":"fa95d90b7d0d46ecd263b49c630a80879f9a235b","modified":1560152543121},{"_id":"public/2018/06/08/浅析JAVA集合/index.html","hash":"3714701b8862905594d12238cd8dffefda54af39","modified":1560152543121},{"_id":"public/2018/06/01/浅识Nginx/index.html","hash":"fde5d5490c452378209359a0c2c2c9a69909bdca","modified":1560152543121},{"_id":"public/2018/06/01/Nginx应用 - 负载均衡/index.html","hash":"9808d48c6fb355b9b3a9beabaef17f6891442b89","modified":1560152543121},{"_id":"public/2018/05/02/Redis必知必会/index.html","hash":"f0b523809ee80e624440e956975988ba3942fd0c","modified":1560152543121},{"_id":"public/2018/04/14/杂谈MySQL - 优化篇/index.html","hash":"4e779e1ff2f6caf549e5d8c7abfe944feda94472","modified":1560152543122},{"_id":"public/2018/04/03/MongoDB必知必会/index.html","hash":"e697e86b360dbbdb4cb0de2f06d1a63fe4ba7058","modified":1560152543122},{"_id":"public/2018/02/15/闲扯微服务/index.html","hash":"793ce3f639e2137b2a6914e102f6e7596dd4faa4","modified":1560152543122},{"_id":"public/2018/01/25/RabbitMQ - 延迟消息/index.html","hash":"bf898a595fc83e9ddba2115f8c2753e3074d5bb8","modified":1560152543122},{"_id":"public/2018/01/09/浅析JVM调试工具/index.html","hash":"af8711ba25a7476caca1cf8dba13f762e1498804","modified":1560152543122},{"_id":"public/2017/12/13/浅析JAVA垃圾回收/index.html","hash":"9edbf9c3d3e6f51881dc6a956363629b3bbf3063","modified":1560152543122},{"_id":"public/2017/08/28/Hbase初识/index.html","hash":"85cfc0e89ddf98b8cc755c0cb1e68d34d218d799","modified":1560152543122},{"_id":"public/2017/08/12/杂谈MySQL - 基础篇/index.html","hash":"3300f741b099d882e748d3e498494cb18ad94a40","modified":1560152543122},{"_id":"public/2017/08/05/闲扯常用设计模式/index.html","hash":"fa4adb08dcf38d1847f3f3ed23ca647cf9927afe","modified":1560152543122},{"_id":"public/archives/page/3/index.html","hash":"572bd0b0c1a6dde9002e1776c4032b0ce4771f3e","modified":1560152543133},{"_id":"public/archives/page/4/index.html","hash":"7ba6454bf2e5eac27cdfed2e531d833cadd0a929","modified":1560152543134},{"_id":"public/archives/2017/index.html","hash":"c7f71d30a81c7b1ec36f6e7e941fe430453a8d63","modified":1560152543134},{"_id":"public/archives/2017/05/index.html","hash":"9d379a26918f30bb2d9b0bbf2eecd5eeef717bfc","modified":1560152543134},{"_id":"public/archives/2017/08/index.html","hash":"8fdcc9a1bb86d4c7deea100b71908f8cbc95de51","modified":1560152543134},{"_id":"public/archives/2017/10/index.html","hash":"a8363446af9ac72ab212a405eff4ee87e27b43e4","modified":1560152543134},{"_id":"public/archives/2017/11/index.html","hash":"9a8dc478da30c20e3c777e6f55ebcf4241a013d0","modified":1560152543134},{"_id":"public/archives/2017/12/index.html","hash":"fafa09cf0a41f7afe67215cb9947f30f0545272a","modified":1560152543134},{"_id":"public/archives/2018/index.html","hash":"8cef621134890e206d1cb18cd0a727d2d1533966","modified":1560152543134},{"_id":"public/archives/2018/page/2/index.html","hash":"45c2b5535d5ac698af302ef4c6a978d3be30a751","modified":1560152543134},{"_id":"public/archives/2018/page/3/index.html","hash":"635852e696ad939135218b4c96867bd9804d223b","modified":1560152543134},{"_id":"public/archives/2018/01/index.html","hash":"c1cc11a67b35015be1115415e3d950ef6b97f790","modified":1560152543134},{"_id":"public/archives/2018/02/index.html","hash":"28644e992f01ade511a67f808d26df2e7bbe416c","modified":1560152543135},{"_id":"public/archives/2018/03/index.html","hash":"45346d0b147e7ba94b860e7c6cca04e726281f6b","modified":1560152543135},{"_id":"public/archives/2018/04/index.html","hash":"4491336521d166259ed7528ac4c91fe3f62af5a6","modified":1560152543135},{"_id":"public/archives/2018/05/index.html","hash":"1aaf84507f96786a9d0d2e7cd42fe7edc6ebb2a8","modified":1560152543135},{"_id":"public/archives/2018/06/index.html","hash":"63e19f3bb8e0cc4fe45bee4d84f10d1df2ed5291","modified":1560152543135},{"_id":"public/archives/2018/07/index.html","hash":"dc7119c72d57830974131746703d344d03c59e84","modified":1560152543135},{"_id":"public/archives/2018/08/index.html","hash":"d3332e38c228f05e40b222e3a49201a47c308b18","modified":1560152543135},{"_id":"public/archives/2018/09/index.html","hash":"596dec30db4700346622d0599195972aa1779c22","modified":1560152543135},{"_id":"public/archives/2018/10/index.html","hash":"932039f0db3e6ba7b33ed6c5f5bf3510db676667","modified":1560152543135},{"_id":"public/categories/方法论/index.html","hash":"994ef531553ebee26434da8a3bcecfdb1685dfa4","modified":1560152543136},{"_id":"public/categories/数据库/index.html","hash":"79a87b2f2abe0753d0c9125d4f1d78645ae506f0","modified":1560152543136},{"_id":"public/categories/中间件/index.html","hash":"207362fd1a4a8dd4fd567dfe26a03bbf2945d424","modified":1560152543136},{"_id":"public/categories/中间件/page/2/index.html","hash":"662e13fe8f2edb6f5cc6fa9a6b6558a6e8dcc866","modified":1560152543136},{"_id":"public/categories/JAVA/index.html","hash":"8bae04a5ee6a8718364953e8b5b366e6eee61347","modified":1560152543138},{"_id":"public/categories/排错卷宗/index.html","hash":"ca125d883ad77ff9e678e58b979b3273022f7a8a","modified":1560152543138},{"_id":"public/categories/开源框架/index.html","hash":"6466f7537ad93a59d68ced467905d88ab006df05","modified":1560152543138},{"_id":"public/tags/RESTful/index.html","hash":"40df492e4f79fe1036863160694437202630078f","modified":1560152543138},{"_id":"public/tags/Hbase/index.html","hash":"6b4fb5f1fc97f9509028bd2d85c87b581e94678a","modified":1560152543138},{"_id":"public/tags/MongoDB/index.html","hash":"18046d1a3c5ff5b2d04e8a466925ca145e9b0c50","modified":1560152543138},{"_id":"public/tags/Nginx/index.html","hash":"b362df76c9038d95585c1df81f320502a628d3b5","modified":1560152543138},{"_id":"public/tags/RabbitMQ/index.html","hash":"2719d2f3d3d636000eac51000c0ff6fa2ae1d7be","modified":1560152543139},{"_id":"public/tags/Redis/index.html","hash":"a8e9ad05480ab97357f794cd4aafc6a418fd4b05","modified":1560152543139},{"_id":"public/tags/JVM/index.html","hash":"84a5ba939ac353981fe429df4e8be52a8b79be8a","modified":1560152543139},{"_id":"public/tags/OOM/index.html","hash":"28fcce8c703071ab5cf7b63af129acde8adad490","modified":1560152543139},{"_id":"public/tags/UDP/index.html","hash":"7c96b453e96052baa9305b125f819d1d71099fe7","modified":1560152543139},{"_id":"public/tags/redis/index.html","hash":"da185a4bd91c58b128818d3721e754c67edc7619","modified":1560152543139},{"_id":"public/tags/MySQL/index.html","hash":"f804b828944e03892c21fe3c0b063d151e5d410a","modified":1560152543139},{"_id":"public/tags/Spring/index.html","hash":"7da9fa431a07abedddc39b7e839f409ba57a55d3","modified":1560152543139},{"_id":"public/tags/TDD/index.html","hash":"3ffb5b00a0cdeb8ccc03ed545f35b556df527f79","modified":1560152543140},{"_id":"public/tags/设计模式/index.html","hash":"6102aaf179570ace7b62880499bdcafa94abdcb1","modified":1560152543140},{"_id":"public/tags/微服务/index.html","hash":"6ec610775dc45fdf00466cd09b48bd6ddda379a2","modified":1560152543140},{"_id":"public/index.html","hash":"0bd817b24c073eade35845cf298aca3c64c6fe75","modified":1560152543140},{"_id":"public/page/2/index.html","hash":"ff4c9ec0839233d3cae4814998d98850729ff079","modified":1560152543140},{"_id":"public/page/3/index.html","hash":"7f47d49c59581b9fe11cb1c015838d3fc580ffac","modified":1560152543140},{"_id":"public/page/4/index.html","hash":"829add00d545a37c8a03f6e84e576ed598bb20f9","modified":1560152543140},{"_id":"public/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1560152543148},{"_id":"public/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1560152543149},{"_id":"public/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1560152543150},{"_id":"public/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1560152543150},{"_id":"public/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1560152543150},{"_id":"public/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1560152543150},{"_id":"public/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1560152543151},{"_id":"public/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1560152543151},{"_id":"public/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1560152543151},{"_id":"public/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1560152543151},{"_id":"public/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1560152543151},{"_id":"public/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1560152543151},{"_id":"public/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1560152543151},{"_id":"public/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1560152543151},{"_id":"public/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1560152543151},{"_id":"public/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1560152543152},{"_id":"public/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1560152543152},{"_id":"public/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1560152543152},{"_id":"public/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1560152543152},{"_id":"public/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1560152543152},{"_id":"public/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1560152543152},{"_id":"public/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1560152543152},{"_id":"public/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1560152543152},{"_id":"public/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1560152543152},{"_id":"public/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1560152543152},{"_id":"public/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1560152543152},{"_id":"public/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1560152543153},{"_id":"public/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1560152543153},{"_id":"public/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1560152543153},{"_id":"public/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1560152543153},{"_id":"public/lib/Han/dist/font/han.woff2","hash":"623af3ed5423371ac136a4fe0e8cc7bb7396037a","modified":1560152543154},{"_id":"public/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1560152543154},{"_id":"public/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1560152543154},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1560152543724},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1560152543729},{"_id":"public/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1560152543778},{"_id":"public/js/src/algolia-search.js","hash":"b172f697ed339a24b1e80261075232978d164c35","modified":1560152543778},{"_id":"public/js/src/bootstrap.js","hash":"034bc8113e0966fe2096ba5b56061bbf10ef0512","modified":1560152543779},{"_id":"public/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1560152543779},{"_id":"public/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1560152543779},{"_id":"public/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1560152543780},{"_id":"public/js/src/post-details.js","hash":"a13f45f7aa8291cf7244ec5ba93907d119c5dbdd","modified":1560152543780},{"_id":"public/js/src/scroll-cookie.js","hash":"09dc828cbf5f31158ff6250d2bf7c3cde6365c67","modified":1560152543780},{"_id":"public/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1560152543780},{"_id":"public/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1560152543780},{"_id":"public/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1560152543780},{"_id":"public/lib/canvas-ribbon/canvas-ribbon.js","hash":"ff5915eb2596e890a2fc6697c864f861a1995ec0","modified":1560152543780},{"_id":"public/lib/fastclick/bower.json","hash":"4dcecf83afddba148464d5339c93f6d0aa9f42e9","modified":1560152543780},{"_id":"public/lib/font-awesome/bower.json","hash":"64394a2a9aa00f8e321d8daa5e51a420f0e96dad","modified":1560152543780},{"_id":"public/lib/jquery_lazyload/bower.json","hash":"ae3c3b61e6e7f9e1d7e3585ad854380ecc04cf53","modified":1560152543780},{"_id":"public/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1560152543780},{"_id":"public/lib/needsharebutton/needsharebutton.css","hash":"3ef0020a1815ca6151ea4886cd0d37421ae3695c","modified":1560152543781},{"_id":"public/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1560152543781},{"_id":"public/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1560152543781},{"_id":"public/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1560152543781},{"_id":"public/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1560152543781},{"_id":"public/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1560152543781},{"_id":"public/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1560152543781},{"_id":"public/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1560152543781},{"_id":"public/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1560152543781},{"_id":"public/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1560152543781},{"_id":"public/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1560152543781},{"_id":"public/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1560152543781},{"_id":"public/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1560152543781},{"_id":"public/lib/velocity/bower.json","hash":"0ef14e7ccdfba5db6eb3f8fc6aa3b47282c36409","modified":1560152543781},{"_id":"public/js/src/schemes/pisces.js","hash":"8050a5b2683d1d77238c5762b6bd89c543daed6e","modified":1560152543817},{"_id":"public/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1560152543817},{"_id":"public/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1560152543817},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1560152543817},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1560152543817},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1560152543818},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1560152543818},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1560152543818},{"_id":"public/lib/fastclick/README.html","hash":"c5a4c05ca80132b7e343d5fd1d1d1a976b4ad151","modified":1560152543818},{"_id":"public/lib/jquery_lazyload/CONTRIBUTING.html","hash":"81057e5b518b8ab60474e1ad027e868b558f15b7","modified":1560152543818},{"_id":"public/lib/jquery_lazyload/README.html","hash":"18a600ca1aafd3bf08af52b6a6fe5f056aeed9f4","modified":1560152543818},{"_id":"public/css/main.css","hash":"4b9f81b8b08e9fe618c5f8fe36c5be50a3a483c4","modified":1560152543818},{"_id":"public/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1560152543818},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1560152543818},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1560152543818},{"_id":"public/js/src/motion.js","hash":"754b294394f102c8fd9423a1789ddb1201677898","modified":1560152543887},{"_id":"public/js/src/utils.js","hash":"9b1325801d27213083d1487a12b1a62b539ab6f8","modified":1560152543887},{"_id":"public/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1560152543888},{"_id":"public/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1560152543888},{"_id":"public/lib/pace/pace.min.js","hash":"9944dfb7814b911090e96446cea4d36e2b487234","modified":1560152543888},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1560152543888},{"_id":"public/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1560152543892},{"_id":"public/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1560152543893},{"_id":"public/lib/needsharebutton/needsharebutton.js","hash":"9885fd9bea5e7ebafc5b1de9d17be5e106248d96","modified":1560152543914},{"_id":"public/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1560152543914},{"_id":"public/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1560152543956},{"_id":"public/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1560152543956},{"_id":"public/lib/three/canvas_lines.min.js","hash":"dce4a3b65f8bf958f973690caa7ec4952f353b0c","modified":1560152543991},{"_id":"public/lib/three/canvas_sphere.min.js","hash":"d8ea241a53c135a650f7335d2b6982b899fd58a9","modified":1560152543991},{"_id":"public/lib/three/three-waves.min.js","hash":"d968cba6b3a50b3626a02d67b544f349d83b147c","modified":1560152543993},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1560152543993},{"_id":"public/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1560152543993},{"_id":"public/lib/Han/dist/han.min.js","hash":"f559c68a25065a14f47da954a7617d87263e409d","modified":1560152543993},{"_id":"public/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1560152543993},{"_id":"public/lib/needsharebutton/font-embedded.css","hash":"c39d37278c1e178838732af21bd26cd0baeddfe0","modified":1560152544021},{"_id":"public/lib/Han/dist/han.min.css","hash":"a0c9e32549a8b8cf327ab9227b037f323cdb60ee","modified":1560152544022},{"_id":"public/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1560152544023},{"_id":"public/lib/Han/dist/han.css","hash":"bd40da3fba8735df5850956814e312bd7b3193d7","modified":1560152544027},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1560152544031},{"_id":"public/lib/Han/dist/han.js","hash":"e345397e0585c9fed1449e614ec13e0224acf2ab","modified":1560152544046},{"_id":"public/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1560152544048},{"_id":"public/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1560152544056},{"_id":"public/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1560152544076},{"_id":"public/lib/three/three.min.js","hash":"73f4cdc17e51a72b9bf5b9291f65386d615c483b","modified":1560152544084}],"Category":[{"name":"方法论","_id":"cjwq2jfch0002qxpjt85msnvj"},{"name":"数据库","_id":"cjwq2jfco0007qxpj8x2li7l7"},{"name":"中间件","_id":"cjwq2jfd4000iqxpjwi1bbbqc"},{"name":"JAVA","_id":"cjwq2jfdw001pqxpjevo1jptv"},{"name":"排错卷宗","_id":"cjwq2jfe1001wqxpjxcsunlrz"},{"name":"开源框架","_id":"cjwq2jfem002qqxpjd9eniytk"}],"Data":[],"Page":[],"Post":[{"title":"API接口约定","date":"2018-08-18T16:00:00.000Z","_content":"> 站在巨人的肩膀上 ——牛顿\n\n## 全局约定\n\n    1. 仅支持发送和接收UTF-8编码数据\n    2. request和response，统一为application/json\n    3. response返回结构体{code:0,msg:'ok',data:{key:value}}\n    4. token统一采用JWT标准\n    5. token统一为header参数\n    5. 日期统一使用10位UNIX时间戳\n    6. 对外的接口统一采用HTTPS协议\n    7. 在路径中设置版本，如 example.com/v1\n    8. response的httpcode统一为200\n    9. response中的code，0表示成功，400-499为客户端全局错误，500-599为服务端全局错误，其他为接口局部错误\n \n## URI表达\n> 实例均摘录于《GitHub API v3 接口文档》\n\n1. 获取单个资源\n\n        [GET] \n        /repos/:owner/:repo/issues/:number\n        /repos/octocat/Hello-World/issues/1347\n\n\n2. 获取多个资源\n\n        [GET]\n        /repos/:owner/:repo/issues\n        /repos/octocat/Hello-World/issues\n        \n3. 分页查询\n\n        [GET]\n        /repos/:owner/:repo/issues?page=:pageNum&per_page=pageSize\n        /repos/octocat/Hello-World/issues?page=3&per_page=100\n        \n        \n4. 分页搜索\n\n        [GET]\n        /repos/:owner/:repo/issues?state=:state&sort=:sort&direction=:direction\n        /repos/octocat/Hello-World/issues?state=closed&sort=created&direction=desc\n\n5. 添加资源\n\n        [POST]\n        /repos/:owner/:repo/issues\n        /repos/octocat/Hello-World/issues\n\n6. 删除资源\n\n        [DELETE]\n        /repos/:owner/:repo\n        /repos/octocat/Hello-World\n        \n7. 修改资源\n\n        [PATCH]\n        /repos/:owner/:repo\n        /repos/octocat/Hello-World\n        \n8. 动作型请求(把动作转换成资源)\n    \n        [POST]\n        /repos/:owner/:repo/forks\n        /repos/octocat/Hello-World\n\n        \n\n\n","source":"_posts/API接口约定.md","raw":"---\ntitle: API接口约定\ncategories:\n- 方法论\ndate: 2018-08-19\ntags:\n- RESTful\n---\n> 站在巨人的肩膀上 ——牛顿\n\n## 全局约定\n\n    1. 仅支持发送和接收UTF-8编码数据\n    2. request和response，统一为application/json\n    3. response返回结构体{code:0,msg:'ok',data:{key:value}}\n    4. token统一采用JWT标准\n    5. token统一为header参数\n    5. 日期统一使用10位UNIX时间戳\n    6. 对外的接口统一采用HTTPS协议\n    7. 在路径中设置版本，如 example.com/v1\n    8. response的httpcode统一为200\n    9. response中的code，0表示成功，400-499为客户端全局错误，500-599为服务端全局错误，其他为接口局部错误\n \n## URI表达\n> 实例均摘录于《GitHub API v3 接口文档》\n\n1. 获取单个资源\n\n        [GET] \n        /repos/:owner/:repo/issues/:number\n        /repos/octocat/Hello-World/issues/1347\n\n\n2. 获取多个资源\n\n        [GET]\n        /repos/:owner/:repo/issues\n        /repos/octocat/Hello-World/issues\n        \n3. 分页查询\n\n        [GET]\n        /repos/:owner/:repo/issues?page=:pageNum&per_page=pageSize\n        /repos/octocat/Hello-World/issues?page=3&per_page=100\n        \n        \n4. 分页搜索\n\n        [GET]\n        /repos/:owner/:repo/issues?state=:state&sort=:sort&direction=:direction\n        /repos/octocat/Hello-World/issues?state=closed&sort=created&direction=desc\n\n5. 添加资源\n\n        [POST]\n        /repos/:owner/:repo/issues\n        /repos/octocat/Hello-World/issues\n\n6. 删除资源\n\n        [DELETE]\n        /repos/:owner/:repo\n        /repos/octocat/Hello-World\n        \n7. 修改资源\n\n        [PATCH]\n        /repos/:owner/:repo\n        /repos/octocat/Hello-World\n        \n8. 动作型请求(把动作转换成资源)\n    \n        [POST]\n        /repos/:owner/:repo/forks\n        /repos/octocat/Hello-World\n\n        \n\n\n","slug":"API接口约定","published":1,"updated":"2018-12-25T01:48:14.959Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjwq2jfc40000qxpj419y67ku","content":"<blockquote>\n<p>站在巨人的肩膀上 ——牛顿</p>\n</blockquote>\n<h2 id=\"全局约定\"><a href=\"#全局约定\" class=\"headerlink\" title=\"全局约定\"></a>全局约定</h2><pre><code>1. 仅支持发送和接收UTF-8编码数据\n2. request和response，统一为application/json\n3. response返回结构体{code:0,msg:&apos;ok&apos;,data:{key:value}}\n4. token统一采用JWT标准\n5. token统一为header参数\n5. 日期统一使用10位UNIX时间戳\n6. 对外的接口统一采用HTTPS协议\n7. 在路径中设置版本，如 example.com/v1\n8. response的httpcode统一为200\n9. response中的code，0表示成功，400-499为客户端全局错误，500-599为服务端全局错误，其他为接口局部错误</code></pre><h2 id=\"URI表达\"><a href=\"#URI表达\" class=\"headerlink\" title=\"URI表达\"></a>URI表达</h2><blockquote>\n<p>实例均摘录于《GitHub API v3 接口文档》</p>\n</blockquote>\n<ol>\n<li><p>获取单个资源</p>\n<pre><code>[GET] \n/repos/:owner/:repo/issues/:number\n/repos/octocat/Hello-World/issues/1347</code></pre></li>\n</ol>\n<ol start=\"2\">\n<li><p>获取多个资源</p>\n<pre><code>[GET]\n/repos/:owner/:repo/issues\n/repos/octocat/Hello-World/issues</code></pre></li>\n<li><p>分页查询</p>\n<pre><code>[GET]\n/repos/:owner/:repo/issues?page=:pageNum&amp;per_page=pageSize\n/repos/octocat/Hello-World/issues?page=3&amp;per_page=100</code></pre></li>\n</ol>\n<ol start=\"4\">\n<li><p>分页搜索</p>\n<pre><code>[GET]\n/repos/:owner/:repo/issues?state=:state&amp;sort=:sort&amp;direction=:direction\n/repos/octocat/Hello-World/issues?state=closed&amp;sort=created&amp;direction=desc</code></pre></li>\n<li><p>添加资源</p>\n<pre><code>[POST]\n/repos/:owner/:repo/issues\n/repos/octocat/Hello-World/issues</code></pre></li>\n<li><p>删除资源</p>\n<pre><code>[DELETE]\n/repos/:owner/:repo\n/repos/octocat/Hello-World</code></pre></li>\n<li><p>修改资源</p>\n<pre><code>[PATCH]\n/repos/:owner/:repo\n/repos/octocat/Hello-World</code></pre></li>\n<li><p>动作型请求(把动作转换成资源)</p>\n<pre><code>[POST]\n/repos/:owner/:repo/forks\n/repos/octocat/Hello-World</code></pre></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>站在巨人的肩膀上 ——牛顿</p>\n</blockquote>\n<h2 id=\"全局约定\"><a href=\"#全局约定\" class=\"headerlink\" title=\"全局约定\"></a>全局约定</h2><pre><code>1. 仅支持发送和接收UTF-8编码数据\n2. request和response，统一为application/json\n3. response返回结构体{code:0,msg:&apos;ok&apos;,data:{key:value}}\n4. token统一采用JWT标准\n5. token统一为header参数\n5. 日期统一使用10位UNIX时间戳\n6. 对外的接口统一采用HTTPS协议\n7. 在路径中设置版本，如 example.com/v1\n8. response的httpcode统一为200\n9. response中的code，0表示成功，400-499为客户端全局错误，500-599为服务端全局错误，其他为接口局部错误</code></pre><h2 id=\"URI表达\"><a href=\"#URI表达\" class=\"headerlink\" title=\"URI表达\"></a>URI表达</h2><blockquote>\n<p>实例均摘录于《GitHub API v3 接口文档》</p>\n</blockquote>\n<ol>\n<li><p>获取单个资源</p>\n<pre><code>[GET] \n/repos/:owner/:repo/issues/:number\n/repos/octocat/Hello-World/issues/1347</code></pre></li>\n</ol>\n<ol start=\"2\">\n<li><p>获取多个资源</p>\n<pre><code>[GET]\n/repos/:owner/:repo/issues\n/repos/octocat/Hello-World/issues</code></pre></li>\n<li><p>分页查询</p>\n<pre><code>[GET]\n/repos/:owner/:repo/issues?page=:pageNum&amp;per_page=pageSize\n/repos/octocat/Hello-World/issues?page=3&amp;per_page=100</code></pre></li>\n</ol>\n<ol start=\"4\">\n<li><p>分页搜索</p>\n<pre><code>[GET]\n/repos/:owner/:repo/issues?state=:state&amp;sort=:sort&amp;direction=:direction\n/repos/octocat/Hello-World/issues?state=closed&amp;sort=created&amp;direction=desc</code></pre></li>\n<li><p>添加资源</p>\n<pre><code>[POST]\n/repos/:owner/:repo/issues\n/repos/octocat/Hello-World/issues</code></pre></li>\n<li><p>删除资源</p>\n<pre><code>[DELETE]\n/repos/:owner/:repo\n/repos/octocat/Hello-World</code></pre></li>\n<li><p>修改资源</p>\n<pre><code>[PATCH]\n/repos/:owner/:repo\n/repos/octocat/Hello-World</code></pre></li>\n<li><p>动作型请求(把动作转换成资源)</p>\n<pre><code>[POST]\n/repos/:owner/:repo/forks\n/repos/octocat/Hello-World</code></pre></li>\n</ol>\n"},{"title":"Hbase初识","date":"2017-08-27T16:00:00.000Z","_content":">开源的分布式数据库\n>基于Google的BigTable论文设计\n>面向列存储\n>构建于HDFS之上\n>可以快速随机查询海量的结构化数据\n>No Schema\n\n#### 为什么快\n`写入快`\nHBase的写入速度快是因为它其实并不是真的立即写入文件中，而是先写入内存，随后异步刷入HFile。所以在客户端看来，写入速度很快。另外，写入时候将随机写入转换成顺序写，数据写入速度也很稳定。\n\n`读取快`\n客户端可以直接定位到要查数据所在的HRegion server服务器，然后直接在服务器的一个region上查找要匹配的数据，并且这些数据部分是经过cache缓存的。\n\n#### 数据模型\n  `RowKey`\n  是表中每条记录的“主键”，方便快速查找，Rowkey的设计非常重要。\n `Column Family`\n  列族，拥有一个名称(string)，包含一个或者多个相关列\n `Column`\n  属于某一个columnfamily，familyName:columnName，每条记录可动态添加\n `Version Number`\n  类型为Long，默认值是系统时间戳，可由用户自定义\n `Value(Cell)`\n  Byte array\n\n#### 集群角色\n\n`zookeeper`\n1.保证任何时候，集群中只有一个master\n2.存贮所有Region的寻址入口\n3.实时监控Region Server的状态，将Region server的上线和下线信息实时通知给Master\n4.存储Hbase的schema，包括有哪些table，每个table有哪些column family\n \n`master`\n1.为Region server分配region\n2.负责region server的负载均衡\n3.发现失效的region server并重新分配其上的region\n4.GFS上的垃圾回收\n5.处理schema更新请求\n \n`Region server`\n1.Region server 维护Master分配给它的region，处理对这些region的IO请求\n2.Region server 负责切分在运行过程中变得过大的region\n \n可以看到，client访问hbase上数据的过程并不需要master参与\n（寻址访问zookeeper和region server，数据读写访问region server）,\nmaster仅仅维护着table和region的元数据信息，负载很低\n\n\n#### Rowkey设计\n`长度原则`\n越短越好，设计成定长。\n\n`散列原则`\n提高数据均衡分布在每个RegionServer，避免热点现象。\n\n`唯一原则`\n保证唯一\n\n\n","source":"_posts/Hbase初识.md","raw":"---\ntitle: Hbase初识\ncategories:\n- 数据库\ndate: 2017-08-28 \ntags:\n- Hbase\n---\n>开源的分布式数据库\n>基于Google的BigTable论文设计\n>面向列存储\n>构建于HDFS之上\n>可以快速随机查询海量的结构化数据\n>No Schema\n\n#### 为什么快\n`写入快`\nHBase的写入速度快是因为它其实并不是真的立即写入文件中，而是先写入内存，随后异步刷入HFile。所以在客户端看来，写入速度很快。另外，写入时候将随机写入转换成顺序写，数据写入速度也很稳定。\n\n`读取快`\n客户端可以直接定位到要查数据所在的HRegion server服务器，然后直接在服务器的一个region上查找要匹配的数据，并且这些数据部分是经过cache缓存的。\n\n#### 数据模型\n  `RowKey`\n  是表中每条记录的“主键”，方便快速查找，Rowkey的设计非常重要。\n `Column Family`\n  列族，拥有一个名称(string)，包含一个或者多个相关列\n `Column`\n  属于某一个columnfamily，familyName:columnName，每条记录可动态添加\n `Version Number`\n  类型为Long，默认值是系统时间戳，可由用户自定义\n `Value(Cell)`\n  Byte array\n\n#### 集群角色\n\n`zookeeper`\n1.保证任何时候，集群中只有一个master\n2.存贮所有Region的寻址入口\n3.实时监控Region Server的状态，将Region server的上线和下线信息实时通知给Master\n4.存储Hbase的schema，包括有哪些table，每个table有哪些column family\n \n`master`\n1.为Region server分配region\n2.负责region server的负载均衡\n3.发现失效的region server并重新分配其上的region\n4.GFS上的垃圾回收\n5.处理schema更新请求\n \n`Region server`\n1.Region server 维护Master分配给它的region，处理对这些region的IO请求\n2.Region server 负责切分在运行过程中变得过大的region\n \n可以看到，client访问hbase上数据的过程并不需要master参与\n（寻址访问zookeeper和region server，数据读写访问region server）,\nmaster仅仅维护着table和region的元数据信息，负载很低\n\n\n#### Rowkey设计\n`长度原则`\n越短越好，设计成定长。\n\n`散列原则`\n提高数据均衡分布在每个RegionServer，避免热点现象。\n\n`唯一原则`\n保证唯一\n\n\n","slug":"Hbase初识","published":1,"updated":"2018-12-25T01:48:14.121Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjwq2jfcc0001qxpj0aji22jt","content":"<blockquote>\n<p>开源的分布式数据库<br>基于Google的BigTable论文设计<br>面向列存储<br>构建于HDFS之上<br>可以快速随机查询海量的结构化数据<br>No Schema</p>\n</blockquote>\n<h4 id=\"为什么快\"><a href=\"#为什么快\" class=\"headerlink\" title=\"为什么快\"></a>为什么快</h4><p><code>写入快</code><br>HBase的写入速度快是因为它其实并不是真的立即写入文件中，而是先写入内存，随后异步刷入HFile。所以在客户端看来，写入速度很快。另外，写入时候将随机写入转换成顺序写，数据写入速度也很稳定。</p>\n<p><code>读取快</code><br>客户端可以直接定位到要查数据所在的HRegion server服务器，然后直接在服务器的一个region上查找要匹配的数据，并且这些数据部分是经过cache缓存的。</p>\n<h4 id=\"数据模型\"><a href=\"#数据模型\" class=\"headerlink\" title=\"数据模型\"></a>数据模型</h4><p>  <code>RowKey</code><br>  是表中每条记录的“主键”，方便快速查找，Rowkey的设计非常重要。<br> <code>Column Family</code><br>  列族，拥有一个名称(string)，包含一个或者多个相关列<br> <code>Column</code><br>  属于某一个columnfamily，familyName:columnName，每条记录可动态添加<br> <code>Version Number</code><br>  类型为Long，默认值是系统时间戳，可由用户自定义<br> <code>Value(Cell)</code><br>  Byte array</p>\n<h4 id=\"集群角色\"><a href=\"#集群角色\" class=\"headerlink\" title=\"集群角色\"></a>集群角色</h4><p><code>zookeeper</code><br>1.保证任何时候，集群中只有一个master<br>2.存贮所有Region的寻址入口<br>3.实时监控Region Server的状态，将Region server的上线和下线信息实时通知给Master<br>4.存储Hbase的schema，包括有哪些table，每个table有哪些column family</p>\n<p><code>master</code><br>1.为Region server分配region<br>2.负责region server的负载均衡<br>3.发现失效的region server并重新分配其上的region<br>4.GFS上的垃圾回收<br>5.处理schema更新请求</p>\n<p><code>Region server</code><br>1.Region server 维护Master分配给它的region，处理对这些region的IO请求<br>2.Region server 负责切分在运行过程中变得过大的region</p>\n<p>可以看到，client访问hbase上数据的过程并不需要master参与<br>（寻址访问zookeeper和region server，数据读写访问region server）,<br>master仅仅维护着table和region的元数据信息，负载很低</p>\n<h4 id=\"Rowkey设计\"><a href=\"#Rowkey设计\" class=\"headerlink\" title=\"Rowkey设计\"></a>Rowkey设计</h4><p><code>长度原则</code><br>越短越好，设计成定长。</p>\n<p><code>散列原则</code><br>提高数据均衡分布在每个RegionServer，避免热点现象。</p>\n<p><code>唯一原则</code><br>保证唯一</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>开源的分布式数据库<br>基于Google的BigTable论文设计<br>面向列存储<br>构建于HDFS之上<br>可以快速随机查询海量的结构化数据<br>No Schema</p>\n</blockquote>\n<h4 id=\"为什么快\"><a href=\"#为什么快\" class=\"headerlink\" title=\"为什么快\"></a>为什么快</h4><p><code>写入快</code><br>HBase的写入速度快是因为它其实并不是真的立即写入文件中，而是先写入内存，随后异步刷入HFile。所以在客户端看来，写入速度很快。另外，写入时候将随机写入转换成顺序写，数据写入速度也很稳定。</p>\n<p><code>读取快</code><br>客户端可以直接定位到要查数据所在的HRegion server服务器，然后直接在服务器的一个region上查找要匹配的数据，并且这些数据部分是经过cache缓存的。</p>\n<h4 id=\"数据模型\"><a href=\"#数据模型\" class=\"headerlink\" title=\"数据模型\"></a>数据模型</h4><p>  <code>RowKey</code><br>  是表中每条记录的“主键”，方便快速查找，Rowkey的设计非常重要。<br> <code>Column Family</code><br>  列族，拥有一个名称(string)，包含一个或者多个相关列<br> <code>Column</code><br>  属于某一个columnfamily，familyName:columnName，每条记录可动态添加<br> <code>Version Number</code><br>  类型为Long，默认值是系统时间戳，可由用户自定义<br> <code>Value(Cell)</code><br>  Byte array</p>\n<h4 id=\"集群角色\"><a href=\"#集群角色\" class=\"headerlink\" title=\"集群角色\"></a>集群角色</h4><p><code>zookeeper</code><br>1.保证任何时候，集群中只有一个master<br>2.存贮所有Region的寻址入口<br>3.实时监控Region Server的状态，将Region server的上线和下线信息实时通知给Master<br>4.存储Hbase的schema，包括有哪些table，每个table有哪些column family</p>\n<p><code>master</code><br>1.为Region server分配region<br>2.负责region server的负载均衡<br>3.发现失效的region server并重新分配其上的region<br>4.GFS上的垃圾回收<br>5.处理schema更新请求</p>\n<p><code>Region server</code><br>1.Region server 维护Master分配给它的region，处理对这些region的IO请求<br>2.Region server 负责切分在运行过程中变得过大的region</p>\n<p>可以看到，client访问hbase上数据的过程并不需要master参与<br>（寻址访问zookeeper和region server，数据读写访问region server）,<br>master仅仅维护着table和region的元数据信息，负载很低</p>\n<h4 id=\"Rowkey设计\"><a href=\"#Rowkey设计\" class=\"headerlink\" title=\"Rowkey设计\"></a>Rowkey设计</h4><p><code>长度原则</code><br>越短越好，设计成定长。</p>\n<p><code>散列原则</code><br>提高数据均衡分布在每个RegionServer，避免热点现象。</p>\n<p><code>唯一原则</code><br>保证唯一</p>\n"},{"title":"MongoDB必知必会","date":"2018-04-02T16:00:00.000Z","_content":">NoSQL文档数据库\n>由C++语言编写\n>支持分布式集群扩展\n\n#### 优势\n\n- 灵活，No Schema \n- 解决海量数据存储，并有良好的查询性能\n- 快速，热数据加载到内存，不用join\n- GEO支持，轻松解决附近位置查询场景\n\n#### 常用命令\n```\n1）查看所有数据库（show dbs）\n\n2）创建新的数据库（use mydb）\n\n3）获取所有的集合（表）\n\ndb.getCollectionNames();\n\n4）插入数据。\n\ndb.collName.insert({name: 'Kane', gender: 'male'});\n\n5）更新数据\n\ndb.collName.update({_id: ObjectId('4df96d7fbc7a05156600e4f2')}, {$set: {name: 'Kane', gender: 'male',weight:111}});\n\n6）删除数据\n\ndb.collName.remove({name: 'Kane'});\n\n7）获取集合的文档（记录）数量。\n\ndb.collName.count();\n\n8）获取集合的所有文档\n\ndb.collName.find();\n\n9）获取集合中性别为male的文档\n\ndb.collName.find({gender:'male'});\n\n10）获取集合中性别为男性且体重大于600的文档\n\ndb.collName.find({gender:'male',weight:{$gt:600}});\n\n11）展示名字和体重的所有文档\n\ndb.collName.find(null,{name:1,weight:1});\n\n12）找出性别为male，体重前2、3名的名字\n\ndb.collName.find({gender: 'male'}, {name: 1}).sort({weight:-1}).limit(2).skip(1);\n\n13）计算体重小于600的数量\n\ndb.collName.count({weight:{$lt:600}});\n\n\n```\n\n\n#### GEO支持\n\n```\nPoint location = new Point(-73.99171, 40.738868);\nNearQuery query = NearQuery.near(location).maxDistance(new Distance(10, Metrics.MILES));\n\nGeoResults<Restaurant> = operations.geoNear(query, Restaurant.class);\n```\n\n\n#### Object ID\nObjectId 是一个12字节 BSON 类型数据，有以下格式：\n>前4个字节表示时间戳\n接下来的3个字节是机器标识码\n紧接的两个字节由进程id组成（PID）\n最后三个字节是随机数。\n\n为了减少服务器端的开销，objectId是由客户端的驱动程序来生成的。\n\n#### 索引\n* 类型\n\n`单键索引`\ndb.collection.createIndex({'fieldName':1});\n\n`唯一索引`\ndb.books.ensureIndex({name:-1}, {unique:true});\n\n`复合索引`\ndb.collection.createIndex({'fieldName_one':1,'fieldName_n..':1});\n\n`TTL索引`\ndb.collection.createIndex({'dateTimeField':1},{expireAfterSeconds:100(秒)});\n在一段时间后会过期的索引，在索引过期后，相应的数据会被删除。\n\n`地理空间索引`\n db.collection.createIndex({w:\"2d\"})\n\n* 注意\n\n`后台创建索引`\ndb.values.createIndex({open: 1}, {background: true})\n建索引过程会阻塞其它数据库操作，background可指定以后台方式创建索引。\n`查看查询计划`\ndb.books.find(query).explain();\n分析查询耗时。\n\n#### 集群\n`模式`\n分为三种模式：主从，副本，sharding\n\n`副本模式`\n三类角色：主节点，副节点，仲裁节点\n","source":"_posts/MongoDB必知必会.md","raw":"---\ntitle: MongoDB必知必会\ncategories:\n- 数据库\ndate: 2018-04-03 \ntags:\n- MongoDB\n---\n>NoSQL文档数据库\n>由C++语言编写\n>支持分布式集群扩展\n\n#### 优势\n\n- 灵活，No Schema \n- 解决海量数据存储，并有良好的查询性能\n- 快速，热数据加载到内存，不用join\n- GEO支持，轻松解决附近位置查询场景\n\n#### 常用命令\n```\n1）查看所有数据库（show dbs）\n\n2）创建新的数据库（use mydb）\n\n3）获取所有的集合（表）\n\ndb.getCollectionNames();\n\n4）插入数据。\n\ndb.collName.insert({name: 'Kane', gender: 'male'});\n\n5）更新数据\n\ndb.collName.update({_id: ObjectId('4df96d7fbc7a05156600e4f2')}, {$set: {name: 'Kane', gender: 'male',weight:111}});\n\n6）删除数据\n\ndb.collName.remove({name: 'Kane'});\n\n7）获取集合的文档（记录）数量。\n\ndb.collName.count();\n\n8）获取集合的所有文档\n\ndb.collName.find();\n\n9）获取集合中性别为male的文档\n\ndb.collName.find({gender:'male'});\n\n10）获取集合中性别为男性且体重大于600的文档\n\ndb.collName.find({gender:'male',weight:{$gt:600}});\n\n11）展示名字和体重的所有文档\n\ndb.collName.find(null,{name:1,weight:1});\n\n12）找出性别为male，体重前2、3名的名字\n\ndb.collName.find({gender: 'male'}, {name: 1}).sort({weight:-1}).limit(2).skip(1);\n\n13）计算体重小于600的数量\n\ndb.collName.count({weight:{$lt:600}});\n\n\n```\n\n\n#### GEO支持\n\n```\nPoint location = new Point(-73.99171, 40.738868);\nNearQuery query = NearQuery.near(location).maxDistance(new Distance(10, Metrics.MILES));\n\nGeoResults<Restaurant> = operations.geoNear(query, Restaurant.class);\n```\n\n\n#### Object ID\nObjectId 是一个12字节 BSON 类型数据，有以下格式：\n>前4个字节表示时间戳\n接下来的3个字节是机器标识码\n紧接的两个字节由进程id组成（PID）\n最后三个字节是随机数。\n\n为了减少服务器端的开销，objectId是由客户端的驱动程序来生成的。\n\n#### 索引\n* 类型\n\n`单键索引`\ndb.collection.createIndex({'fieldName':1});\n\n`唯一索引`\ndb.books.ensureIndex({name:-1}, {unique:true});\n\n`复合索引`\ndb.collection.createIndex({'fieldName_one':1,'fieldName_n..':1});\n\n`TTL索引`\ndb.collection.createIndex({'dateTimeField':1},{expireAfterSeconds:100(秒)});\n在一段时间后会过期的索引，在索引过期后，相应的数据会被删除。\n\n`地理空间索引`\n db.collection.createIndex({w:\"2d\"})\n\n* 注意\n\n`后台创建索引`\ndb.values.createIndex({open: 1}, {background: true})\n建索引过程会阻塞其它数据库操作，background可指定以后台方式创建索引。\n`查看查询计划`\ndb.books.find(query).explain();\n分析查询耗时。\n\n#### 集群\n`模式`\n分为三种模式：主从，副本，sharding\n\n`副本模式`\n三类角色：主节点，副节点，仲裁节点\n","slug":"MongoDB必知必会","published":1,"updated":"2018-12-25T01:48:13.960Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjwq2jfck0004qxpjxebkb0nn","content":"<blockquote>\n<p>NoSQL文档数据库<br>由C++语言编写<br>支持分布式集群扩展</p>\n</blockquote>\n<h4 id=\"优势\"><a href=\"#优势\" class=\"headerlink\" title=\"优势\"></a>优势</h4><ul>\n<li>灵活，No Schema </li>\n<li>解决海量数据存储，并有良好的查询性能</li>\n<li>快速，热数据加载到内存，不用join</li>\n<li>GEO支持，轻松解决附近位置查询场景</li>\n</ul>\n<h4 id=\"常用命令\"><a href=\"#常用命令\" class=\"headerlink\" title=\"常用命令\"></a>常用命令</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1）查看所有数据库（show dbs）</span><br><span class=\"line\"></span><br><span class=\"line\">2）创建新的数据库（use mydb）</span><br><span class=\"line\"></span><br><span class=\"line\">3）获取所有的集合（表）</span><br><span class=\"line\"></span><br><span class=\"line\">db.getCollectionNames();</span><br><span class=\"line\"></span><br><span class=\"line\">4）插入数据。</span><br><span class=\"line\"></span><br><span class=\"line\">db.collName.insert(&#123;name: &apos;Kane&apos;, gender: &apos;male&apos;&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">5）更新数据</span><br><span class=\"line\"></span><br><span class=\"line\">db.collName.update(&#123;_id: ObjectId(&apos;4df96d7fbc7a05156600e4f2&apos;)&#125;, &#123;$set: &#123;name: &apos;Kane&apos;, gender: &apos;male&apos;,weight:111&#125;&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">6）删除数据</span><br><span class=\"line\"></span><br><span class=\"line\">db.collName.remove(&#123;name: &apos;Kane&apos;&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">7）获取集合的文档（记录）数量。</span><br><span class=\"line\"></span><br><span class=\"line\">db.collName.count();</span><br><span class=\"line\"></span><br><span class=\"line\">8）获取集合的所有文档</span><br><span class=\"line\"></span><br><span class=\"line\">db.collName.find();</span><br><span class=\"line\"></span><br><span class=\"line\">9）获取集合中性别为male的文档</span><br><span class=\"line\"></span><br><span class=\"line\">db.collName.find(&#123;gender:&apos;male&apos;&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">10）获取集合中性别为男性且体重大于600的文档</span><br><span class=\"line\"></span><br><span class=\"line\">db.collName.find(&#123;gender:&apos;male&apos;,weight:&#123;$gt:600&#125;&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">11）展示名字和体重的所有文档</span><br><span class=\"line\"></span><br><span class=\"line\">db.collName.find(null,&#123;name:1,weight:1&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">12）找出性别为male，体重前2、3名的名字</span><br><span class=\"line\"></span><br><span class=\"line\">db.collName.find(&#123;gender: &apos;male&apos;&#125;, &#123;name: 1&#125;).sort(&#123;weight:-1&#125;).limit(2).skip(1);</span><br><span class=\"line\"></span><br><span class=\"line\">13）计算体重小于600的数量</span><br><span class=\"line\"></span><br><span class=\"line\">db.collName.count(&#123;weight:&#123;$lt:600&#125;&#125;);</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"GEO支持\"><a href=\"#GEO支持\" class=\"headerlink\" title=\"GEO支持\"></a>GEO支持</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Point location = new Point(-73.99171, 40.738868);</span><br><span class=\"line\">NearQuery query = NearQuery.near(location).maxDistance(new Distance(10, Metrics.MILES));</span><br><span class=\"line\"></span><br><span class=\"line\">GeoResults&lt;Restaurant&gt; = operations.geoNear(query, Restaurant.class);</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Object-ID\"><a href=\"#Object-ID\" class=\"headerlink\" title=\"Object ID\"></a>Object ID</h4><p>ObjectId 是一个12字节 BSON 类型数据，有以下格式：</p>\n<blockquote>\n<p>前4个字节表示时间戳<br>接下来的3个字节是机器标识码<br>紧接的两个字节由进程id组成（PID）<br>最后三个字节是随机数。</p>\n</blockquote>\n<p>为了减少服务器端的开销，objectId是由客户端的驱动程序来生成的。</p>\n<h4 id=\"索引\"><a href=\"#索引\" class=\"headerlink\" title=\"索引\"></a>索引</h4><ul>\n<li>类型</li>\n</ul>\n<p><code>单键索引</code><br>db.collection.createIndex({‘fieldName’:1});</p>\n<p><code>唯一索引</code><br>db.books.ensureIndex({name:-1}, {unique:true});</p>\n<p><code>复合索引</code><br>db.collection.createIndex({‘fieldName_one’:1,’fieldName_n..’:1});</p>\n<p><code>TTL索引</code><br>db.collection.createIndex({‘dateTimeField’:1},{expireAfterSeconds:100(秒)});<br>在一段时间后会过期的索引，在索引过期后，相应的数据会被删除。</p>\n<p><code>地理空间索引</code><br> db.collection.createIndex({w:”2d”})</p>\n<ul>\n<li>注意</li>\n</ul>\n<p><code>后台创建索引</code><br>db.values.createIndex({open: 1}, {background: true})<br>建索引过程会阻塞其它数据库操作，background可指定以后台方式创建索引。<br><code>查看查询计划</code><br>db.books.find(query).explain();<br>分析查询耗时。</p>\n<h4 id=\"集群\"><a href=\"#集群\" class=\"headerlink\" title=\"集群\"></a>集群</h4><p><code>模式</code><br>分为三种模式：主从，副本，sharding</p>\n<p><code>副本模式</code><br>三类角色：主节点，副节点，仲裁节点</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>NoSQL文档数据库<br>由C++语言编写<br>支持分布式集群扩展</p>\n</blockquote>\n<h4 id=\"优势\"><a href=\"#优势\" class=\"headerlink\" title=\"优势\"></a>优势</h4><ul>\n<li>灵活，No Schema </li>\n<li>解决海量数据存储，并有良好的查询性能</li>\n<li>快速，热数据加载到内存，不用join</li>\n<li>GEO支持，轻松解决附近位置查询场景</li>\n</ul>\n<h4 id=\"常用命令\"><a href=\"#常用命令\" class=\"headerlink\" title=\"常用命令\"></a>常用命令</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1）查看所有数据库（show dbs）</span><br><span class=\"line\"></span><br><span class=\"line\">2）创建新的数据库（use mydb）</span><br><span class=\"line\"></span><br><span class=\"line\">3）获取所有的集合（表）</span><br><span class=\"line\"></span><br><span class=\"line\">db.getCollectionNames();</span><br><span class=\"line\"></span><br><span class=\"line\">4）插入数据。</span><br><span class=\"line\"></span><br><span class=\"line\">db.collName.insert(&#123;name: &apos;Kane&apos;, gender: &apos;male&apos;&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">5）更新数据</span><br><span class=\"line\"></span><br><span class=\"line\">db.collName.update(&#123;_id: ObjectId(&apos;4df96d7fbc7a05156600e4f2&apos;)&#125;, &#123;$set: &#123;name: &apos;Kane&apos;, gender: &apos;male&apos;,weight:111&#125;&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">6）删除数据</span><br><span class=\"line\"></span><br><span class=\"line\">db.collName.remove(&#123;name: &apos;Kane&apos;&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">7）获取集合的文档（记录）数量。</span><br><span class=\"line\"></span><br><span class=\"line\">db.collName.count();</span><br><span class=\"line\"></span><br><span class=\"line\">8）获取集合的所有文档</span><br><span class=\"line\"></span><br><span class=\"line\">db.collName.find();</span><br><span class=\"line\"></span><br><span class=\"line\">9）获取集合中性别为male的文档</span><br><span class=\"line\"></span><br><span class=\"line\">db.collName.find(&#123;gender:&apos;male&apos;&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">10）获取集合中性别为男性且体重大于600的文档</span><br><span class=\"line\"></span><br><span class=\"line\">db.collName.find(&#123;gender:&apos;male&apos;,weight:&#123;$gt:600&#125;&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">11）展示名字和体重的所有文档</span><br><span class=\"line\"></span><br><span class=\"line\">db.collName.find(null,&#123;name:1,weight:1&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">12）找出性别为male，体重前2、3名的名字</span><br><span class=\"line\"></span><br><span class=\"line\">db.collName.find(&#123;gender: &apos;male&apos;&#125;, &#123;name: 1&#125;).sort(&#123;weight:-1&#125;).limit(2).skip(1);</span><br><span class=\"line\"></span><br><span class=\"line\">13）计算体重小于600的数量</span><br><span class=\"line\"></span><br><span class=\"line\">db.collName.count(&#123;weight:&#123;$lt:600&#125;&#125;);</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"GEO支持\"><a href=\"#GEO支持\" class=\"headerlink\" title=\"GEO支持\"></a>GEO支持</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Point location = new Point(-73.99171, 40.738868);</span><br><span class=\"line\">NearQuery query = NearQuery.near(location).maxDistance(new Distance(10, Metrics.MILES));</span><br><span class=\"line\"></span><br><span class=\"line\">GeoResults&lt;Restaurant&gt; = operations.geoNear(query, Restaurant.class);</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Object-ID\"><a href=\"#Object-ID\" class=\"headerlink\" title=\"Object ID\"></a>Object ID</h4><p>ObjectId 是一个12字节 BSON 类型数据，有以下格式：</p>\n<blockquote>\n<p>前4个字节表示时间戳<br>接下来的3个字节是机器标识码<br>紧接的两个字节由进程id组成（PID）<br>最后三个字节是随机数。</p>\n</blockquote>\n<p>为了减少服务器端的开销，objectId是由客户端的驱动程序来生成的。</p>\n<h4 id=\"索引\"><a href=\"#索引\" class=\"headerlink\" title=\"索引\"></a>索引</h4><ul>\n<li>类型</li>\n</ul>\n<p><code>单键索引</code><br>db.collection.createIndex({‘fieldName’:1});</p>\n<p><code>唯一索引</code><br>db.books.ensureIndex({name:-1}, {unique:true});</p>\n<p><code>复合索引</code><br>db.collection.createIndex({‘fieldName_one’:1,’fieldName_n..’:1});</p>\n<p><code>TTL索引</code><br>db.collection.createIndex({‘dateTimeField’:1},{expireAfterSeconds:100(秒)});<br>在一段时间后会过期的索引，在索引过期后，相应的数据会被删除。</p>\n<p><code>地理空间索引</code><br> db.collection.createIndex({w:”2d”})</p>\n<ul>\n<li>注意</li>\n</ul>\n<p><code>后台创建索引</code><br>db.values.createIndex({open: 1}, {background: true})<br>建索引过程会阻塞其它数据库操作，background可指定以后台方式创建索引。<br><code>查看查询计划</code><br>db.books.find(query).explain();<br>分析查询耗时。</p>\n<h4 id=\"集群\"><a href=\"#集群\" class=\"headerlink\" title=\"集群\"></a>集群</h4><p><code>模式</code><br>分为三种模式：主从，副本，sharding</p>\n<p><code>副本模式</code><br>三类角色：主节点，副节点，仲裁节点</p>\n"},{"title":"Nginx应用 - Nginx应用 - Https","date":"2017-10-07T16:00:00.000Z","_content":"#### 应用场景\nNginx代替后端服务，处理Https问题。\n\n#### 配置示例\n```\nserver {\n    listen 443;\n    server_name localhost;\n    ssl on;\n    root html;\n    index index.html index.htm;\n    ssl_certificate   cert/215069382450020.pem;\n    ssl_certificate_key  cert/215069382450020.key;\n    ssl_session_timeout 5m;\n    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;\n    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;\n    ssl_prefer_server_ciphers on;\n    location / {\n        root html;\n        index index.html index.htm;\n    }\n}\n```","source":"_posts/Nginx应用 - Https.md","raw":"---\ntitle: Nginx应用 - Nginx应用 - Https\ncategories:\n- 中间件\ndate: 2017-10-08 \ntags:\n- Nginx\n---\n#### 应用场景\nNginx代替后端服务，处理Https问题。\n\n#### 配置示例\n```\nserver {\n    listen 443;\n    server_name localhost;\n    ssl on;\n    root html;\n    index index.html index.htm;\n    ssl_certificate   cert/215069382450020.pem;\n    ssl_certificate_key  cert/215069382450020.key;\n    ssl_session_timeout 5m;\n    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;\n    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;\n    ssl_prefer_server_ciphers on;\n    location / {\n        root html;\n        index index.html index.htm;\n    }\n}\n```","slug":"Nginx应用 - Https","published":1,"updated":"2018-12-25T01:48:12.490Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjwq2jfcm0005qxpjcc6a00yq","content":"<h4 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h4><p>Nginx代替后端服务，处理Https问题。</p>\n<h4 id=\"配置示例\"><a href=\"#配置示例\" class=\"headerlink\" title=\"配置示例\"></a>配置示例</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server &#123;</span><br><span class=\"line\">    listen 443;</span><br><span class=\"line\">    server_name localhost;</span><br><span class=\"line\">    ssl on;</span><br><span class=\"line\">    root html;</span><br><span class=\"line\">    index index.html index.htm;</span><br><span class=\"line\">    ssl_certificate   cert/215069382450020.pem;</span><br><span class=\"line\">    ssl_certificate_key  cert/215069382450020.key;</span><br><span class=\"line\">    ssl_session_timeout 5m;</span><br><span class=\"line\">    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;</span><br><span class=\"line\">    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;</span><br><span class=\"line\">    ssl_prefer_server_ciphers on;</span><br><span class=\"line\">    location / &#123;</span><br><span class=\"line\">        root html;</span><br><span class=\"line\">        index index.html index.htm;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h4 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h4><p>Nginx代替后端服务，处理Https问题。</p>\n<h4 id=\"配置示例\"><a href=\"#配置示例\" class=\"headerlink\" title=\"配置示例\"></a>配置示例</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server &#123;</span><br><span class=\"line\">    listen 443;</span><br><span class=\"line\">    server_name localhost;</span><br><span class=\"line\">    ssl on;</span><br><span class=\"line\">    root html;</span><br><span class=\"line\">    index index.html index.htm;</span><br><span class=\"line\">    ssl_certificate   cert/215069382450020.pem;</span><br><span class=\"line\">    ssl_certificate_key  cert/215069382450020.key;</span><br><span class=\"line\">    ssl_session_timeout 5m;</span><br><span class=\"line\">    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;</span><br><span class=\"line\">    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;</span><br><span class=\"line\">    ssl_prefer_server_ciphers on;</span><br><span class=\"line\">    location / &#123;</span><br><span class=\"line\">        root html;</span><br><span class=\"line\">        index index.html index.htm;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"Nginx应用 - URL拦截","date":"2018-05-31T16:00:00.000Z","_content":"#### 应用场景\n临时下线某个业务接口，不重新发布服务。\n\n\n#### 配置示例\n```\nlocation / {\n\n#匹配请求url中包含指定字符的请求\nif ($request_uri ~* \"/bad_request\") {\n    return 200 \"error\";\n}\n```","source":"_posts/Nginx应用 - URL拦截.md","raw":"---\ntitle: Nginx应用 - URL拦截\ncategories:\n- 中间件\ndate: 2018-06-01 \ntags:\n- Nginx\n---\n#### 应用场景\n临时下线某个业务接口，不重新发布服务。\n\n\n#### 配置示例\n```\nlocation / {\n\n#匹配请求url中包含指定字符的请求\nif ($request_uri ~* \"/bad_request\") {\n    return 200 \"error\";\n}\n```","slug":"Nginx应用 - URL拦截","published":1,"updated":"2018-12-25T01:48:12.420Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjwq2jfcn0006qxpjcdp4t2u7","content":"<h4 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h4><p>临时下线某个业务接口，不重新发布服务。</p>\n<h4 id=\"配置示例\"><a href=\"#配置示例\" class=\"headerlink\" title=\"配置示例\"></a>配置示例</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">location / &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">#匹配请求url中包含指定字符的请求</span><br><span class=\"line\">if ($request_uri ~* &quot;/bad_request&quot;) &#123;</span><br><span class=\"line\">    return 200 &quot;error&quot;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h4 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h4><p>临时下线某个业务接口，不重新发布服务。</p>\n<h4 id=\"配置示例\"><a href=\"#配置示例\" class=\"headerlink\" title=\"配置示例\"></a>配置示例</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">location / &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">#匹配请求url中包含指定字符的请求</span><br><span class=\"line\">if ($request_uri ~* &quot;/bad_request&quot;) &#123;</span><br><span class=\"line\">    return 200 &quot;error&quot;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"Nginx应用 - 反向代理","date":"2018-05-31T16:00:00.000Z","_content":"#### 为什么要用？\n1. 保护源服务的安全，相当于堡垒服务。\n2. 缓存静态资源，加速web请求。\n3. 灵活的服务中间件，实现服务热部署。\n\n#### 配置示例\n```\nserver {\n    listen       7421;\n\n    location / {\n        proxy_pass_header Server;\n        //保留Host请求头\n        proxy_set_header Host $http_host;\n        //保留用户真实IP\n        proxy_set_header X-Real-IP $remote_addr;\n        //转发到7422端口\n        proxy_pass   http://127.0.0.1:7422;\n    }\n}\n```\n\n\n\n","source":"_posts/Nginx应用 - 反向代理.md","raw":"---\ntitle: Nginx应用 - 反向代理\ncategories:\n- 中间件\ndate: 2018-06-01 \ntags:\n- Nginx\n---\n#### 为什么要用？\n1. 保护源服务的安全，相当于堡垒服务。\n2. 缓存静态资源，加速web请求。\n3. 灵活的服务中间件，实现服务热部署。\n\n#### 配置示例\n```\nserver {\n    listen       7421;\n\n    location / {\n        proxy_pass_header Server;\n        //保留Host请求头\n        proxy_set_header Host $http_host;\n        //保留用户真实IP\n        proxy_set_header X-Real-IP $remote_addr;\n        //转发到7422端口\n        proxy_pass   http://127.0.0.1:7422;\n    }\n}\n```\n\n\n\n","slug":"Nginx应用 - 反向代理","published":1,"updated":"2018-12-25T01:48:13.344Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjwq2jfcp000aqxpjju0h66hc","content":"<h4 id=\"为什么要用？\"><a href=\"#为什么要用？\" class=\"headerlink\" title=\"为什么要用？\"></a>为什么要用？</h4><ol>\n<li>保护源服务的安全，相当于堡垒服务。</li>\n<li>缓存静态资源，加速web请求。</li>\n<li>灵活的服务中间件，实现服务热部署。</li>\n</ol>\n<h4 id=\"配置示例\"><a href=\"#配置示例\" class=\"headerlink\" title=\"配置示例\"></a>配置示例</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server &#123;</span><br><span class=\"line\">    listen       7421;</span><br><span class=\"line\"></span><br><span class=\"line\">    location / &#123;</span><br><span class=\"line\">        proxy_pass_header Server;</span><br><span class=\"line\">        //保留Host请求头</span><br><span class=\"line\">        proxy_set_header Host $http_host;</span><br><span class=\"line\">        //保留用户真实IP</span><br><span class=\"line\">        proxy_set_header X-Real-IP $remote_addr;</span><br><span class=\"line\">        //转发到7422端口</span><br><span class=\"line\">        proxy_pass   http://127.0.0.1:7422;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"为什么要用？\"><a href=\"#为什么要用？\" class=\"headerlink\" title=\"为什么要用？\"></a>为什么要用？</h4><ol>\n<li>保护源服务的安全，相当于堡垒服务。</li>\n<li>缓存静态资源，加速web请求。</li>\n<li>灵活的服务中间件，实现服务热部署。</li>\n</ol>\n<h4 id=\"配置示例\"><a href=\"#配置示例\" class=\"headerlink\" title=\"配置示例\"></a>配置示例</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server &#123;</span><br><span class=\"line\">    listen       7421;</span><br><span class=\"line\"></span><br><span class=\"line\">    location / &#123;</span><br><span class=\"line\">        proxy_pass_header Server;</span><br><span class=\"line\">        //保留Host请求头</span><br><span class=\"line\">        proxy_set_header Host $http_host;</span><br><span class=\"line\">        //保留用户真实IP</span><br><span class=\"line\">        proxy_set_header X-Real-IP $remote_addr;</span><br><span class=\"line\">        //转发到7422端口</span><br><span class=\"line\">        proxy_pass   http://127.0.0.1:7422;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n"},{"title":"Nginx应用 - 流量镜像","date":"2018-10-13T03:11:11.000Z","_content":"#### 应用场景\n版本发布前进行预先验证；\n使用生产流量进行压测；\n复制客户端网络请求为两份，原始请求的返回将作为客户端相应，镜像请求将被忽略；\n通过ngx_http_mirror_module 模块，实现的该功能；\n\n#### 配置示例\n```\nlocation / {\n    mirror /mirror;\n    #off，会丢失body\n    mirror_request_body on;\n    proxy_pass http://127.0.0.1:9502;\n}\n \nlocation /mirror {\n    internal;\n    proxy_pass http://127.0.0.1:8081$request_uri;\n    proxy_set_header X-Original-URI $request_uri;\n}\n\n```","source":"_posts/Nginx应用 - 流量镜像.md","raw":"---\ntitle: Nginx应用 - 流量镜像\ncategories:\n- 中间件\ndate: 2018-10-13 11:11:11\ntags:\n- Nginx\n---\n#### 应用场景\n版本发布前进行预先验证；\n使用生产流量进行压测；\n复制客户端网络请求为两份，原始请求的返回将作为客户端相应，镜像请求将被忽略；\n通过ngx_http_mirror_module 模块，实现的该功能；\n\n#### 配置示例\n```\nlocation / {\n    mirror /mirror;\n    #off，会丢失body\n    mirror_request_body on;\n    proxy_pass http://127.0.0.1:9502;\n}\n \nlocation /mirror {\n    internal;\n    proxy_pass http://127.0.0.1:8081$request_uri;\n    proxy_set_header X-Original-URI $request_uri;\n}\n\n```","slug":"Nginx应用 - 流量镜像","published":1,"updated":"2018-12-25T01:48:09.078Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjwq2jfcr000bqxpjt8n76jzs","content":"<h4 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h4><p>版本发布前进行预先验证；<br>使用生产流量进行压测；<br>复制客户端网络请求为两份，原始请求的返回将作为客户端相应，镜像请求将被忽略；<br>通过ngx_http_mirror_module 模块，实现的该功能；</p>\n<h4 id=\"配置示例\"><a href=\"#配置示例\" class=\"headerlink\" title=\"配置示例\"></a>配置示例</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">location / &#123;</span><br><span class=\"line\">    mirror /mirror;</span><br><span class=\"line\">    #off，会丢失body</span><br><span class=\"line\">    mirror_request_body on;</span><br><span class=\"line\">    proxy_pass http://127.0.0.1:9502;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">location /mirror &#123;</span><br><span class=\"line\">    internal;</span><br><span class=\"line\">    proxy_pass http://127.0.0.1:8081$request_uri;</span><br><span class=\"line\">    proxy_set_header X-Original-URI $request_uri;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h4 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h4><p>版本发布前进行预先验证；<br>使用生产流量进行压测；<br>复制客户端网络请求为两份，原始请求的返回将作为客户端相应，镜像请求将被忽略；<br>通过ngx_http_mirror_module 模块，实现的该功能；</p>\n<h4 id=\"配置示例\"><a href=\"#配置示例\" class=\"headerlink\" title=\"配置示例\"></a>配置示例</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">location / &#123;</span><br><span class=\"line\">    mirror /mirror;</span><br><span class=\"line\">    #off，会丢失body</span><br><span class=\"line\">    mirror_request_body on;</span><br><span class=\"line\">    proxy_pass http://127.0.0.1:9502;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">location /mirror &#123;</span><br><span class=\"line\">    internal;</span><br><span class=\"line\">    proxy_pass http://127.0.0.1:8081$request_uri;</span><br><span class=\"line\">    proxy_set_header X-Original-URI $request_uri;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"Nginx应用 - 虚拟主机","date":"2017-10-12T16:00:00.000Z","_content":"#### 应用场景\n基于域名的虚拟主机。\n同一IP，不同域名，解析到不同的服务。\n\n#### 配置示例\n```\nserver {\n    listen       80;\n    server_name  www.a.com;\n\n    location / {\n        //转发到7421端口\n        proxy_pass   http://127.0.0.1:7421;\n    }\n}\n\nserver {\n    listen       80;\n    server_name  www.b.com;\n\n    location / {\n        //转发到7422端口\n        proxy_pass   http://127.0.0.1:7422;\n    }\n}\n```","source":"_posts/Nginx应用 - 虚拟主机.md","raw":"---\ntitle: Nginx应用 - 虚拟主机\ncategories:\n- 中间件\ndate: 2017-10-13 \ntags:\n- Nginx\n---\n#### 应用场景\n基于域名的虚拟主机。\n同一IP，不同域名，解析到不同的服务。\n\n#### 配置示例\n```\nserver {\n    listen       80;\n    server_name  www.a.com;\n\n    location / {\n        //转发到7421端口\n        proxy_pass   http://127.0.0.1:7421;\n    }\n}\n\nserver {\n    listen       80;\n    server_name  www.b.com;\n\n    location / {\n        //转发到7422端口\n        proxy_pass   http://127.0.0.1:7422;\n    }\n}\n```","slug":"Nginx应用 - 虚拟主机","published":1,"updated":"2018-12-25T01:48:09.036Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjwq2jfd0000fqxpjeni252iv","content":"<h4 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h4><p>基于域名的虚拟主机。<br>同一IP，不同域名，解析到不同的服务。</p>\n<h4 id=\"配置示例\"><a href=\"#配置示例\" class=\"headerlink\" title=\"配置示例\"></a>配置示例</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server &#123;</span><br><span class=\"line\">    listen       80;</span><br><span class=\"line\">    server_name  www.a.com;</span><br><span class=\"line\"></span><br><span class=\"line\">    location / &#123;</span><br><span class=\"line\">        //转发到7421端口</span><br><span class=\"line\">        proxy_pass   http://127.0.0.1:7421;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">server &#123;</span><br><span class=\"line\">    listen       80;</span><br><span class=\"line\">    server_name  www.b.com;</span><br><span class=\"line\"></span><br><span class=\"line\">    location / &#123;</span><br><span class=\"line\">        //转发到7422端口</span><br><span class=\"line\">        proxy_pass   http://127.0.0.1:7422;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h4 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h4><p>基于域名的虚拟主机。<br>同一IP，不同域名，解析到不同的服务。</p>\n<h4 id=\"配置示例\"><a href=\"#配置示例\" class=\"headerlink\" title=\"配置示例\"></a>配置示例</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server &#123;</span><br><span class=\"line\">    listen       80;</span><br><span class=\"line\">    server_name  www.a.com;</span><br><span class=\"line\"></span><br><span class=\"line\">    location / &#123;</span><br><span class=\"line\">        //转发到7421端口</span><br><span class=\"line\">        proxy_pass   http://127.0.0.1:7421;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">server &#123;</span><br><span class=\"line\">    listen       80;</span><br><span class=\"line\">    server_name  www.b.com;</span><br><span class=\"line\"></span><br><span class=\"line\">    location / &#123;</span><br><span class=\"line\">        //转发到7422端口</span><br><span class=\"line\">        proxy_pass   http://127.0.0.1:7422;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"Nginx应用 - 负载均衡","date":"2018-05-31T16:00:00.000Z","_content":"#### 负载策略\n`轮循（默认）`\n根据Nginx配置文件中的顺序，依次把客户端的Web请求分发到不同的后端服务器上。\n\n`权重`\n配置Nginx把请求更多地分发到高配置的后端服务器上，把相对较少的请求分发到低配服务器。\n\n`IP Hash`\n同一客户端连续的Web请求都会被分发到同一服务器进行处理。\n\n`最少连接`\n请求会被转发到连接数最少的服务器上。\n\n#### 配置示例\n* 轮循（默认）\n\n```\nupstream service {\n    server 192.168.1.7;\n    server 192.168.1.8;\n}\n\nserver {\n    listen       80;\n    location / {\n        proxy_pass_header Server;\n        #保留Host请求头\n        proxy_set_header Host $http_host;\n        #保留用户真实IP\n        proxy_set_header X-Real-IP $remote_addr;\n        #对应upstream的配置\n        proxy_pass   http://service;\n    }\n}\n```\n\n* 权重\n```\nupstream service {\n    server 192.168.1.10 weight=1;\n    server 192.168.1.11 weight=2;\n}\n```\n* IP Hash\n```\nupstream service {\n    ip_hash;\n    server 192.168.1.7;\n    server 192.168.1.8;\n}\n```\n\n* 最少连接\n```\nupstream service {\n    least_conn;\n    server 192.168.1.7;\n    server 192.168.1.8;\n}\n```","source":"_posts/Nginx应用 - 负载均衡.md","raw":"---\ntitle: Nginx应用 - 负载均衡\ncategories:\n- 中间件\ndate: 2018-06-01 \ntags:\n- Nginx\n---\n#### 负载策略\n`轮循（默认）`\n根据Nginx配置文件中的顺序，依次把客户端的Web请求分发到不同的后端服务器上。\n\n`权重`\n配置Nginx把请求更多地分发到高配置的后端服务器上，把相对较少的请求分发到低配服务器。\n\n`IP Hash`\n同一客户端连续的Web请求都会被分发到同一服务器进行处理。\n\n`最少连接`\n请求会被转发到连接数最少的服务器上。\n\n#### 配置示例\n* 轮循（默认）\n\n```\nupstream service {\n    server 192.168.1.7;\n    server 192.168.1.8;\n}\n\nserver {\n    listen       80;\n    location / {\n        proxy_pass_header Server;\n        #保留Host请求头\n        proxy_set_header Host $http_host;\n        #保留用户真实IP\n        proxy_set_header X-Real-IP $remote_addr;\n        #对应upstream的配置\n        proxy_pass   http://service;\n    }\n}\n```\n\n* 权重\n```\nupstream service {\n    server 192.168.1.10 weight=1;\n    server 192.168.1.11 weight=2;\n}\n```\n* IP Hash\n```\nupstream service {\n    ip_hash;\n    server 192.168.1.7;\n    server 192.168.1.8;\n}\n```\n\n* 最少连接\n```\nupstream service {\n    least_conn;\n    server 192.168.1.7;\n    server 192.168.1.8;\n}\n```","slug":"Nginx应用 - 负载均衡","published":1,"updated":"2018-12-25T01:48:13.266Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjwq2jfd2000hqxpja2l8gcpa","content":"<h4 id=\"负载策略\"><a href=\"#负载策略\" class=\"headerlink\" title=\"负载策略\"></a>负载策略</h4><p><code>轮循（默认）</code><br>根据Nginx配置文件中的顺序，依次把客户端的Web请求分发到不同的后端服务器上。</p>\n<p><code>权重</code><br>配置Nginx把请求更多地分发到高配置的后端服务器上，把相对较少的请求分发到低配服务器。</p>\n<p><code>IP Hash</code><br>同一客户端连续的Web请求都会被分发到同一服务器进行处理。</p>\n<p><code>最少连接</code><br>请求会被转发到连接数最少的服务器上。</p>\n<h4 id=\"配置示例\"><a href=\"#配置示例\" class=\"headerlink\" title=\"配置示例\"></a>配置示例</h4><ul>\n<li>轮循（默认）</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">upstream service &#123;</span><br><span class=\"line\">    server 192.168.1.7;</span><br><span class=\"line\">    server 192.168.1.8;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">server &#123;</span><br><span class=\"line\">    listen       80;</span><br><span class=\"line\">    location / &#123;</span><br><span class=\"line\">        proxy_pass_header Server;</span><br><span class=\"line\">        #保留Host请求头</span><br><span class=\"line\">        proxy_set_header Host $http_host;</span><br><span class=\"line\">        #保留用户真实IP</span><br><span class=\"line\">        proxy_set_header X-Real-IP $remote_addr;</span><br><span class=\"line\">        #对应upstream的配置</span><br><span class=\"line\">        proxy_pass   http://service;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>权重</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">upstream service &#123;</span><br><span class=\"line\">    server 192.168.1.10 weight=1;</span><br><span class=\"line\">    server 192.168.1.11 weight=2;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>IP Hash</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">upstream service &#123;</span><br><span class=\"line\">    ip_hash;</span><br><span class=\"line\">    server 192.168.1.7;</span><br><span class=\"line\">    server 192.168.1.8;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>最少连接</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">upstream service &#123;</span><br><span class=\"line\">    least_conn;</span><br><span class=\"line\">    server 192.168.1.7;</span><br><span class=\"line\">    server 192.168.1.8;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"负载策略\"><a href=\"#负载策略\" class=\"headerlink\" title=\"负载策略\"></a>负载策略</h4><p><code>轮循（默认）</code><br>根据Nginx配置文件中的顺序，依次把客户端的Web请求分发到不同的后端服务器上。</p>\n<p><code>权重</code><br>配置Nginx把请求更多地分发到高配置的后端服务器上，把相对较少的请求分发到低配服务器。</p>\n<p><code>IP Hash</code><br>同一客户端连续的Web请求都会被分发到同一服务器进行处理。</p>\n<p><code>最少连接</code><br>请求会被转发到连接数最少的服务器上。</p>\n<h4 id=\"配置示例\"><a href=\"#配置示例\" class=\"headerlink\" title=\"配置示例\"></a>配置示例</h4><ul>\n<li>轮循（默认）</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">upstream service &#123;</span><br><span class=\"line\">    server 192.168.1.7;</span><br><span class=\"line\">    server 192.168.1.8;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">server &#123;</span><br><span class=\"line\">    listen       80;</span><br><span class=\"line\">    location / &#123;</span><br><span class=\"line\">        proxy_pass_header Server;</span><br><span class=\"line\">        #保留Host请求头</span><br><span class=\"line\">        proxy_set_header Host $http_host;</span><br><span class=\"line\">        #保留用户真实IP</span><br><span class=\"line\">        proxy_set_header X-Real-IP $remote_addr;</span><br><span class=\"line\">        #对应upstream的配置</span><br><span class=\"line\">        proxy_pass   http://service;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>权重</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">upstream service &#123;</span><br><span class=\"line\">    server 192.168.1.10 weight=1;</span><br><span class=\"line\">    server 192.168.1.11 weight=2;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>IP Hash</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">upstream service &#123;</span><br><span class=\"line\">    ip_hash;</span><br><span class=\"line\">    server 192.168.1.7;</span><br><span class=\"line\">    server 192.168.1.8;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>最少连接</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">upstream service &#123;</span><br><span class=\"line\">    least_conn;</span><br><span class=\"line\">    server 192.168.1.7;</span><br><span class=\"line\">    server 192.168.1.8;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n"},{"title":"Nginx应用 - 跨域访问","date":"2018-10-12T16:00:00.000Z","_content":"#### 跨域问题\n跨域，指的是浏览器不能执行其他网站的脚本。 \n它是由浏览器的同源策略造成的，是浏览器施加的安全限制。\n所谓同源是指，域名，协议，端口均相同。\nNginx代替后端服务，处理跨域问题。\n\n#### 配置示例\n```\nlocation / {  \n    if ($request_method = 'OPTIONS') {\n    add_header Access-Control-Allow-Origin *;\n    add_header Access-Control-Allow-Methods 'GET, POST, OPTIONS';\n    return 204;\n    }\n} \n```","source":"_posts/Nginx应用 - 跨域访问.md","raw":"---\ntitle: Nginx应用 - 跨域访问\ncategories:\n- 中间件\ndate: 2018-10-13 \ntags:\n- Nginx\n---\n#### 跨域问题\n跨域，指的是浏览器不能执行其他网站的脚本。 \n它是由浏览器的同源策略造成的，是浏览器施加的安全限制。\n所谓同源是指，域名，协议，端口均相同。\nNginx代替后端服务，处理跨域问题。\n\n#### 配置示例\n```\nlocation / {  \n    if ($request_method = 'OPTIONS') {\n    add_header Access-Control-Allow-Origin *;\n    add_header Access-Control-Allow-Methods 'GET, POST, OPTIONS';\n    return 204;\n    }\n} \n```","slug":"Nginx应用 - 跨域访问","published":1,"updated":"2018-12-25T01:48:13.125Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjwq2jfd5000lqxpjrskb6gr4","content":"<h4 id=\"跨域问题\"><a href=\"#跨域问题\" class=\"headerlink\" title=\"跨域问题\"></a>跨域问题</h4><p>跨域，指的是浏览器不能执行其他网站的脚本。<br>它是由浏览器的同源策略造成的，是浏览器施加的安全限制。<br>所谓同源是指，域名，协议，端口均相同。<br>Nginx代替后端服务，处理跨域问题。</p>\n<h4 id=\"配置示例\"><a href=\"#配置示例\" class=\"headerlink\" title=\"配置示例\"></a>配置示例</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">location / &#123;  </span><br><span class=\"line\">    if ($request_method = &apos;OPTIONS&apos;) &#123;</span><br><span class=\"line\">    add_header Access-Control-Allow-Origin *;</span><br><span class=\"line\">    add_header Access-Control-Allow-Methods &apos;GET, POST, OPTIONS&apos;;</span><br><span class=\"line\">    return 204;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h4 id=\"跨域问题\"><a href=\"#跨域问题\" class=\"headerlink\" title=\"跨域问题\"></a>跨域问题</h4><p>跨域，指的是浏览器不能执行其他网站的脚本。<br>它是由浏览器的同源策略造成的，是浏览器施加的安全限制。<br>所谓同源是指，域名，协议，端口均相同。<br>Nginx代替后端服务，处理跨域问题。</p>\n<h4 id=\"配置示例\"><a href=\"#配置示例\" class=\"headerlink\" title=\"配置示例\"></a>配置示例</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">location / &#123;  </span><br><span class=\"line\">    if ($request_method = &apos;OPTIONS&apos;) &#123;</span><br><span class=\"line\">    add_header Access-Control-Allow-Origin *;</span><br><span class=\"line\">    add_header Access-Control-Allow-Methods &apos;GET, POST, OPTIONS&apos;;</span><br><span class=\"line\">    return 204;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"RabbitMQ - 延迟消息","date":"2018-01-24T16:00:00.000Z","_content":"#### 什么是延迟消息\n所谓”延时消息”是指当消息被发送以后，并不想让消费者立即拿到消息，而是等待指定时间后，消费者才拿到这个消息进行消费。\n常用来处理“超时取消”，“定时执行”等业务场景。\n#### 如何实现\n\n`实现原理`\nmessage达到生存时间，变为dead letter，被转发到指定的队列。\n对Queue设置x-expires，或对Message设置x-message-ttl，来控制消息的生存时间。\n配置x-dead-letter-exchange和x-dead-letter-routing-key，重新路由转发到指定的队列。\n\n`配置示例`\n\n```\n@Component\npublic class DelayQueue {\n\n    @Autowired\n    private RabbitTemplate rabbitTemplate;\n\n    @Override\n    @RabbitListener(queues = DEAD_QUEUE)\n    public void doJob(Message token) {\n        \n        //发送延迟消息\n        rabbitTemplate.convertAndSend(BLOCKED_QUEUE, new Date(), message -> {\n            message.getMessageProperties().setExpiration(\"120000\");\n            return message;\n        });\n\n    }\n\n    //定义延迟消息队列\n    @Bean\n    public Queue blockedQueue() {\n        return QueueBuilder\n            .durable(BLOCKED_QUEUE)\n            //绑定dead letter到Dead Letter Exchanges（DLX）\n            .withArgument(\"x-dead-letter-exchange\", \"\")\n            .withArgument(\"x-dead-letter-routing-key\", TOKEN_QUEUE)\n            .build();\n    }\n\n    //绑定延迟消息队列，到default exchange\n    @Bean\n    public Binding bindBlockedQueue() {\n        return BindingBuilder\n            .bind(blockedQueue())\n            .to(DirectExchange.DEFAULT)\n            .with(BLOCKED_TOKEN_QUEUE);\n    }\n    \n    //定义dead letter接收队列\n    @Bean\n    public Queue deadQueue() {\n        return QueueBuilder\n            .durable(TOKEN_QUEUE)\n            .build();\n    }\n\n    //绑定dead letter接收队列，到default exchange\n    @Bean\n    public Binding bindDeadQueue() {\n        return BindingBuilder\n            .bind(deadQueue())\n            .to(DirectExchange.DEFAULT)\n            .with(TOKEN_QUEUE);\n    }\n}\n\n```\n#### 注意\n如果在同一queue中，message分配不同的ttl值，message可能会被延迟dead。\n在延迟队列中，所有的消息等待队列头部消息过期后，开始延迟倒计时。","source":"_posts/RabbitMQ - 延迟消息.md","raw":"---\ntitle: RabbitMQ - 延迟消息\ncategories:\n- 中间件\ndate: 2018-01-25 \ntags:\n- RabbitMQ\n---\n#### 什么是延迟消息\n所谓”延时消息”是指当消息被发送以后，并不想让消费者立即拿到消息，而是等待指定时间后，消费者才拿到这个消息进行消费。\n常用来处理“超时取消”，“定时执行”等业务场景。\n#### 如何实现\n\n`实现原理`\nmessage达到生存时间，变为dead letter，被转发到指定的队列。\n对Queue设置x-expires，或对Message设置x-message-ttl，来控制消息的生存时间。\n配置x-dead-letter-exchange和x-dead-letter-routing-key，重新路由转发到指定的队列。\n\n`配置示例`\n\n```\n@Component\npublic class DelayQueue {\n\n    @Autowired\n    private RabbitTemplate rabbitTemplate;\n\n    @Override\n    @RabbitListener(queues = DEAD_QUEUE)\n    public void doJob(Message token) {\n        \n        //发送延迟消息\n        rabbitTemplate.convertAndSend(BLOCKED_QUEUE, new Date(), message -> {\n            message.getMessageProperties().setExpiration(\"120000\");\n            return message;\n        });\n\n    }\n\n    //定义延迟消息队列\n    @Bean\n    public Queue blockedQueue() {\n        return QueueBuilder\n            .durable(BLOCKED_QUEUE)\n            //绑定dead letter到Dead Letter Exchanges（DLX）\n            .withArgument(\"x-dead-letter-exchange\", \"\")\n            .withArgument(\"x-dead-letter-routing-key\", TOKEN_QUEUE)\n            .build();\n    }\n\n    //绑定延迟消息队列，到default exchange\n    @Bean\n    public Binding bindBlockedQueue() {\n        return BindingBuilder\n            .bind(blockedQueue())\n            .to(DirectExchange.DEFAULT)\n            .with(BLOCKED_TOKEN_QUEUE);\n    }\n    \n    //定义dead letter接收队列\n    @Bean\n    public Queue deadQueue() {\n        return QueueBuilder\n            .durable(TOKEN_QUEUE)\n            .build();\n    }\n\n    //绑定dead letter接收队列，到default exchange\n    @Bean\n    public Binding bindDeadQueue() {\n        return BindingBuilder\n            .bind(deadQueue())\n            .to(DirectExchange.DEFAULT)\n            .with(TOKEN_QUEUE);\n    }\n}\n\n```\n#### 注意\n如果在同一queue中，message分配不同的ttl值，message可能会被延迟dead。\n在延迟队列中，所有的消息等待队列头部消息过期后，开始延迟倒计时。","slug":"RabbitMQ - 延迟消息","published":1,"updated":"2018-12-25T01:48:11.633Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjwq2jfd7000nqxpjadn1o9m9","content":"<h4 id=\"什么是延迟消息\"><a href=\"#什么是延迟消息\" class=\"headerlink\" title=\"什么是延迟消息\"></a>什么是延迟消息</h4><p>所谓”延时消息”是指当消息被发送以后，并不想让消费者立即拿到消息，而是等待指定时间后，消费者才拿到这个消息进行消费。<br>常用来处理“超时取消”，“定时执行”等业务场景。</p>\n<h4 id=\"如何实现\"><a href=\"#如何实现\" class=\"headerlink\" title=\"如何实现\"></a>如何实现</h4><p><code>实现原理</code><br>message达到生存时间，变为dead letter，被转发到指定的队列。<br>对Queue设置x-expires，或对Message设置x-message-ttl，来控制消息的生存时间。<br>配置x-dead-letter-exchange和x-dead-letter-routing-key，重新路由转发到指定的队列。</p>\n<p><code>配置示例</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Component</span><br><span class=\"line\">public class DelayQueue &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Autowired</span><br><span class=\"line\">    private RabbitTemplate rabbitTemplate;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    @RabbitListener(queues = DEAD_QUEUE)</span><br><span class=\"line\">    public void doJob(Message token) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        //发送延迟消息</span><br><span class=\"line\">        rabbitTemplate.convertAndSend(BLOCKED_QUEUE, new Date(), message -&gt; &#123;</span><br><span class=\"line\">            message.getMessageProperties().setExpiration(&quot;120000&quot;);</span><br><span class=\"line\">            return message;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    //定义延迟消息队列</span><br><span class=\"line\">    @Bean</span><br><span class=\"line\">    public Queue blockedQueue() &#123;</span><br><span class=\"line\">        return QueueBuilder</span><br><span class=\"line\">            .durable(BLOCKED_QUEUE)</span><br><span class=\"line\">            //绑定dead letter到Dead Letter Exchanges（DLX）</span><br><span class=\"line\">            .withArgument(&quot;x-dead-letter-exchange&quot;, &quot;&quot;)</span><br><span class=\"line\">            .withArgument(&quot;x-dead-letter-routing-key&quot;, TOKEN_QUEUE)</span><br><span class=\"line\">            .build();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    //绑定延迟消息队列，到default exchange</span><br><span class=\"line\">    @Bean</span><br><span class=\"line\">    public Binding bindBlockedQueue() &#123;</span><br><span class=\"line\">        return BindingBuilder</span><br><span class=\"line\">            .bind(blockedQueue())</span><br><span class=\"line\">            .to(DirectExchange.DEFAULT)</span><br><span class=\"line\">            .with(BLOCKED_TOKEN_QUEUE);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    //定义dead letter接收队列</span><br><span class=\"line\">    @Bean</span><br><span class=\"line\">    public Queue deadQueue() &#123;</span><br><span class=\"line\">        return QueueBuilder</span><br><span class=\"line\">            .durable(TOKEN_QUEUE)</span><br><span class=\"line\">            .build();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    //绑定dead letter接收队列，到default exchange</span><br><span class=\"line\">    @Bean</span><br><span class=\"line\">    public Binding bindDeadQueue() &#123;</span><br><span class=\"line\">        return BindingBuilder</span><br><span class=\"line\">            .bind(deadQueue())</span><br><span class=\"line\">            .to(DirectExchange.DEFAULT)</span><br><span class=\"line\">            .with(TOKEN_QUEUE);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h4><p>如果在同一queue中，message分配不同的ttl值，message可能会被延迟dead。<br>在延迟队列中，所有的消息等待队列头部消息过期后，开始延迟倒计时。</p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"什么是延迟消息\"><a href=\"#什么是延迟消息\" class=\"headerlink\" title=\"什么是延迟消息\"></a>什么是延迟消息</h4><p>所谓”延时消息”是指当消息被发送以后，并不想让消费者立即拿到消息，而是等待指定时间后，消费者才拿到这个消息进行消费。<br>常用来处理“超时取消”，“定时执行”等业务场景。</p>\n<h4 id=\"如何实现\"><a href=\"#如何实现\" class=\"headerlink\" title=\"如何实现\"></a>如何实现</h4><p><code>实现原理</code><br>message达到生存时间，变为dead letter，被转发到指定的队列。<br>对Queue设置x-expires，或对Message设置x-message-ttl，来控制消息的生存时间。<br>配置x-dead-letter-exchange和x-dead-letter-routing-key，重新路由转发到指定的队列。</p>\n<p><code>配置示例</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Component</span><br><span class=\"line\">public class DelayQueue &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Autowired</span><br><span class=\"line\">    private RabbitTemplate rabbitTemplate;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    @RabbitListener(queues = DEAD_QUEUE)</span><br><span class=\"line\">    public void doJob(Message token) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        //发送延迟消息</span><br><span class=\"line\">        rabbitTemplate.convertAndSend(BLOCKED_QUEUE, new Date(), message -&gt; &#123;</span><br><span class=\"line\">            message.getMessageProperties().setExpiration(&quot;120000&quot;);</span><br><span class=\"line\">            return message;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    //定义延迟消息队列</span><br><span class=\"line\">    @Bean</span><br><span class=\"line\">    public Queue blockedQueue() &#123;</span><br><span class=\"line\">        return QueueBuilder</span><br><span class=\"line\">            .durable(BLOCKED_QUEUE)</span><br><span class=\"line\">            //绑定dead letter到Dead Letter Exchanges（DLX）</span><br><span class=\"line\">            .withArgument(&quot;x-dead-letter-exchange&quot;, &quot;&quot;)</span><br><span class=\"line\">            .withArgument(&quot;x-dead-letter-routing-key&quot;, TOKEN_QUEUE)</span><br><span class=\"line\">            .build();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    //绑定延迟消息队列，到default exchange</span><br><span class=\"line\">    @Bean</span><br><span class=\"line\">    public Binding bindBlockedQueue() &#123;</span><br><span class=\"line\">        return BindingBuilder</span><br><span class=\"line\">            .bind(blockedQueue())</span><br><span class=\"line\">            .to(DirectExchange.DEFAULT)</span><br><span class=\"line\">            .with(BLOCKED_TOKEN_QUEUE);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    //定义dead letter接收队列</span><br><span class=\"line\">    @Bean</span><br><span class=\"line\">    public Queue deadQueue() &#123;</span><br><span class=\"line\">        return QueueBuilder</span><br><span class=\"line\">            .durable(TOKEN_QUEUE)</span><br><span class=\"line\">            .build();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    //绑定dead letter接收队列，到default exchange</span><br><span class=\"line\">    @Bean</span><br><span class=\"line\">    public Binding bindDeadQueue() &#123;</span><br><span class=\"line\">        return BindingBuilder</span><br><span class=\"line\">            .bind(deadQueue())</span><br><span class=\"line\">            .to(DirectExchange.DEFAULT)</span><br><span class=\"line\">            .with(TOKEN_QUEUE);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h4><p>如果在同一queue中，message分配不同的ttl值，message可能会被延迟dead。<br>在延迟队列中，所有的消息等待队列头部消息过期后，开始延迟倒计时。</p>\n"},{"title":"RabbitMQ - 消息幂等","date":"2018-03-23T16:00:00.000Z","_content":"#### 什么是消息幂等\npublisher重复发送消息，导致业务重复执行。\nconsumer重复收到消息，导致业务重复执行。\n\n#### 如何处理\n\n`发送消息幂等`\n如果在publisher发送消息后，没有接收到ack，publisher会重发消息。\n对每条消息，MQ系统内部必须生成一个inner-msg-id，作为去重和幂等的依据。\n\n`消费消息幂等`\n如果在consumer消费完消息后，ack没有成功的被broker接收，broker会重发消息。\n对每条消息，业务消息体中，必须有一个biz-id，作为去重和幂等的依据","source":"_posts/RabbitMQ - 消息幂等.md","raw":"---\ntitle: RabbitMQ - 消息幂等\ncategories:\n- 中间件\ndate: 2018-03-24 \ntags:\n- RabbitMQ\n---\n#### 什么是消息幂等\npublisher重复发送消息，导致业务重复执行。\nconsumer重复收到消息，导致业务重复执行。\n\n#### 如何处理\n\n`发送消息幂等`\n如果在publisher发送消息后，没有接收到ack，publisher会重发消息。\n对每条消息，MQ系统内部必须生成一个inner-msg-id，作为去重和幂等的依据。\n\n`消费消息幂等`\n如果在consumer消费完消息后，ack没有成功的被broker接收，broker会重发消息。\n对每条消息，业务消息体中，必须有一个biz-id，作为去重和幂等的依据","slug":"RabbitMQ - 消息幂等","published":1,"updated":"2018-12-25T01:48:11.654Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjwq2jfdb000sqxpjmkm700au","content":"<h4 id=\"什么是消息幂等\"><a href=\"#什么是消息幂等\" class=\"headerlink\" title=\"什么是消息幂等\"></a>什么是消息幂等</h4><p>publisher重复发送消息，导致业务重复执行。<br>consumer重复收到消息，导致业务重复执行。</p>\n<h4 id=\"如何处理\"><a href=\"#如何处理\" class=\"headerlink\" title=\"如何处理\"></a>如何处理</h4><p><code>发送消息幂等</code><br>如果在publisher发送消息后，没有接收到ack，publisher会重发消息。<br>对每条消息，MQ系统内部必须生成一个inner-msg-id，作为去重和幂等的依据。</p>\n<p><code>消费消息幂等</code><br>如果在consumer消费完消息后，ack没有成功的被broker接收，broker会重发消息。<br>对每条消息，业务消息体中，必须有一个biz-id，作为去重和幂等的依据</p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"什么是消息幂等\"><a href=\"#什么是消息幂等\" class=\"headerlink\" title=\"什么是消息幂等\"></a>什么是消息幂等</h4><p>publisher重复发送消息，导致业务重复执行。<br>consumer重复收到消息，导致业务重复执行。</p>\n<h4 id=\"如何处理\"><a href=\"#如何处理\" class=\"headerlink\" title=\"如何处理\"></a>如何处理</h4><p><code>发送消息幂等</code><br>如果在publisher发送消息后，没有接收到ack，publisher会重发消息。<br>对每条消息，MQ系统内部必须生成一个inner-msg-id，作为去重和幂等的依据。</p>\n<p><code>消费消息幂等</code><br>如果在consumer消费完消息后，ack没有成功的被broker接收，broker会重发消息。<br>对每条消息，业务消息体中，必须有一个biz-id，作为去重和幂等的依据</p>\n"},{"title":"RabbitMQ - 顺序消息","date":"2017-05-28T16:00:00.000Z","_content":"#### 什么是顺序消息\n\n消息有序指的是可以按照消息的发送顺序来消费。\n\n#### 如何实现\n\npublisher - broker - consumer 一一对应的关系，可以保证顺序消费。\n这样处理，并行度就会成为消息系统的瓶颈。\n应该将根据业务主体将消息分片，比如根据订单id分片。\n不同的订单消息，进入不同的队列。同一订单消息，进入唯一匹配的队列。\n使用分区顺序消息，既保证业务的顺序，同时又能保证业务的高性能。\n\n","source":"_posts/RabbitMQ - 顺序消息.md","raw":"---\ntitle: RabbitMQ - 顺序消息\ncategories:\n- 中间件\ndate: 2017-05-29 \ntags:\n- RabbitMQ\n---\n#### 什么是顺序消息\n\n消息有序指的是可以按照消息的发送顺序来消费。\n\n#### 如何实现\n\npublisher - broker - consumer 一一对应的关系，可以保证顺序消费。\n这样处理，并行度就会成为消息系统的瓶颈。\n应该将根据业务主体将消息分片，比如根据订单id分片。\n不同的订单消息，进入不同的队列。同一订单消息，进入唯一匹配的队列。\n使用分区顺序消息，既保证业务的顺序，同时又能保证业务的高性能。\n\n","slug":"RabbitMQ - 顺序消息","published":1,"updated":"2018-12-25T01:48:12.294Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjwq2jfdd000uqxpjfpk1g19i","content":"<h4 id=\"什么是顺序消息\"><a href=\"#什么是顺序消息\" class=\"headerlink\" title=\"什么是顺序消息\"></a>什么是顺序消息</h4><p>消息有序指的是可以按照消息的发送顺序来消费。</p>\n<h4 id=\"如何实现\"><a href=\"#如何实现\" class=\"headerlink\" title=\"如何实现\"></a>如何实现</h4><p>publisher - broker - consumer 一一对应的关系，可以保证顺序消费。<br>这样处理，并行度就会成为消息系统的瓶颈。<br>应该将根据业务主体将消息分片，比如根据订单id分片。<br>不同的订单消息，进入不同的队列。同一订单消息，进入唯一匹配的队列。<br>使用分区顺序消息，既保证业务的顺序，同时又能保证业务的高性能。</p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"什么是顺序消息\"><a href=\"#什么是顺序消息\" class=\"headerlink\" title=\"什么是顺序消息\"></a>什么是顺序消息</h4><p>消息有序指的是可以按照消息的发送顺序来消费。</p>\n<h4 id=\"如何实现\"><a href=\"#如何实现\" class=\"headerlink\" title=\"如何实现\"></a>如何实现</h4><p>publisher - broker - consumer 一一对应的关系，可以保证顺序消费。<br>这样处理，并行度就会成为消息系统的瓶颈。<br>应该将根据业务主体将消息分片，比如根据订单id分片。<br>不同的订单消息，进入不同的队列。同一订单消息，进入唯一匹配的队列。<br>使用分区顺序消息，既保证业务的顺序，同时又能保证业务的高性能。</p>\n"},{"title":"RabbitMQ必知必会","date":"2018-09-15T16:00:00.000Z","_content":">支持AMQP协议\n>用Erlang语言编写，并发性能好\n>支持消息持久化\n>支持集群扩展\n>Spring AMQP支持\n>Spring Cloud Stream支持\n\n#### 应用场景\n\n`应用解耦`\n消费者可以随意增加，而不需要修改生产者的代码。对于非核心流程，可以放到消息队列中让消息消费者去按需消费，而不影响核心主流程。\n\n`异步处理`\n任务异步化，提高系统响应性能。\n\n`限流削峰`\n利用消息队列做一个通用的“漏斗”，防止短时间内高流量压垮应用。\n\n#### 组件\n`server（broker）`\n接收和分发消息的应用，RabbitMQ Server就是消息代理服务器。\n\n`virtualHost`\n虚拟的broker，拥有自己的队列、交换器和绑定，拥有自己的权限机制，virtualHost之间是绝对隔离的。\n\n`exchange`\n接收消息，消息到达代broker的第一站。\n路由消息，根据路由键分发消息到queue。\n\n`Queue`\n它是消息的容器，消息最终到达队列中，等待消费者消费。\n一个消息可投入一个或多个队列。\n\n`message`\n它由消息头和消息体组成。消息体是不透明的，而消息头则由一系列的可选属性组成，这些属性包括routing-key（路由键）、priority（相对于其他消息的优先权）、delivery-mode（指出该消息可能需要持久性存储）等。\n\n#### Exchange模式\n\n`Direct Exchange`\n这种模式下不需要将Exchange进行任何绑定(binding)操作。\n该模式的自带Exchange，称其为default Exchange，名字为空字符串。\n消息传递时需要“RouteKey”，为要发送到的队列名字。\n如果vhost中不存在RouteKey中指定的队列名，则该消息会被抛弃。\n\n`Fanout Exchange`\n不需要RouteKey，转发到与该Exchange绑定(Binding)的所有Queue上。\n\n`Topic Exchange`\n这种模式支持路由键的模糊匹配，匹配成功会被路由到相应队列。","source":"_posts/RabbitMQ必知必会.md","raw":"---\ntitle: RabbitMQ必知必会\ncategories:\n- 中间件\ndate: 2018-09-16 \ntags:\n- RabbitMQ\n---\n>支持AMQP协议\n>用Erlang语言编写，并发性能好\n>支持消息持久化\n>支持集群扩展\n>Spring AMQP支持\n>Spring Cloud Stream支持\n\n#### 应用场景\n\n`应用解耦`\n消费者可以随意增加，而不需要修改生产者的代码。对于非核心流程，可以放到消息队列中让消息消费者去按需消费，而不影响核心主流程。\n\n`异步处理`\n任务异步化，提高系统响应性能。\n\n`限流削峰`\n利用消息队列做一个通用的“漏斗”，防止短时间内高流量压垮应用。\n\n#### 组件\n`server（broker）`\n接收和分发消息的应用，RabbitMQ Server就是消息代理服务器。\n\n`virtualHost`\n虚拟的broker，拥有自己的队列、交换器和绑定，拥有自己的权限机制，virtualHost之间是绝对隔离的。\n\n`exchange`\n接收消息，消息到达代broker的第一站。\n路由消息，根据路由键分发消息到queue。\n\n`Queue`\n它是消息的容器，消息最终到达队列中，等待消费者消费。\n一个消息可投入一个或多个队列。\n\n`message`\n它由消息头和消息体组成。消息体是不透明的，而消息头则由一系列的可选属性组成，这些属性包括routing-key（路由键）、priority（相对于其他消息的优先权）、delivery-mode（指出该消息可能需要持久性存储）等。\n\n#### Exchange模式\n\n`Direct Exchange`\n这种模式下不需要将Exchange进行任何绑定(binding)操作。\n该模式的自带Exchange，称其为default Exchange，名字为空字符串。\n消息传递时需要“RouteKey”，为要发送到的队列名字。\n如果vhost中不存在RouteKey中指定的队列名，则该消息会被抛弃。\n\n`Fanout Exchange`\n不需要RouteKey，转发到与该Exchange绑定(Binding)的所有Queue上。\n\n`Topic Exchange`\n这种模式支持路由键的模糊匹配，匹配成功会被路由到相应队列。","slug":"RabbitMQ必知必会","published":1,"updated":"2018-12-25T01:48:11.574Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjwq2jfde000yqxpj4244zgd6","content":"<blockquote>\n<p>支持AMQP协议<br>用Erlang语言编写，并发性能好<br>支持消息持久化<br>支持集群扩展<br>Spring AMQP支持<br>Spring Cloud Stream支持</p>\n</blockquote>\n<h4 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h4><p><code>应用解耦</code><br>消费者可以随意增加，而不需要修改生产者的代码。对于非核心流程，可以放到消息队列中让消息消费者去按需消费，而不影响核心主流程。</p>\n<p><code>异步处理</code><br>任务异步化，提高系统响应性能。</p>\n<p><code>限流削峰</code><br>利用消息队列做一个通用的“漏斗”，防止短时间内高流量压垮应用。</p>\n<h4 id=\"组件\"><a href=\"#组件\" class=\"headerlink\" title=\"组件\"></a>组件</h4><p><code>server（broker）</code><br>接收和分发消息的应用，RabbitMQ Server就是消息代理服务器。</p>\n<p><code>virtualHost</code><br>虚拟的broker，拥有自己的队列、交换器和绑定，拥有自己的权限机制，virtualHost之间是绝对隔离的。</p>\n<p><code>exchange</code><br>接收消息，消息到达代broker的第一站。<br>路由消息，根据路由键分发消息到queue。</p>\n<p><code>Queue</code><br>它是消息的容器，消息最终到达队列中，等待消费者消费。<br>一个消息可投入一个或多个队列。</p>\n<p><code>message</code><br>它由消息头和消息体组成。消息体是不透明的，而消息头则由一系列的可选属性组成，这些属性包括routing-key（路由键）、priority（相对于其他消息的优先权）、delivery-mode（指出该消息可能需要持久性存储）等。</p>\n<h4 id=\"Exchange模式\"><a href=\"#Exchange模式\" class=\"headerlink\" title=\"Exchange模式\"></a>Exchange模式</h4><p><code>Direct Exchange</code><br>这种模式下不需要将Exchange进行任何绑定(binding)操作。<br>该模式的自带Exchange，称其为default Exchange，名字为空字符串。<br>消息传递时需要“RouteKey”，为要发送到的队列名字。<br>如果vhost中不存在RouteKey中指定的队列名，则该消息会被抛弃。</p>\n<p><code>Fanout Exchange</code><br>不需要RouteKey，转发到与该Exchange绑定(Binding)的所有Queue上。</p>\n<p><code>Topic Exchange</code><br>这种模式支持路由键的模糊匹配，匹配成功会被路由到相应队列。</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>支持AMQP协议<br>用Erlang语言编写，并发性能好<br>支持消息持久化<br>支持集群扩展<br>Spring AMQP支持<br>Spring Cloud Stream支持</p>\n</blockquote>\n<h4 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h4><p><code>应用解耦</code><br>消费者可以随意增加，而不需要修改生产者的代码。对于非核心流程，可以放到消息队列中让消息消费者去按需消费，而不影响核心主流程。</p>\n<p><code>异步处理</code><br>任务异步化，提高系统响应性能。</p>\n<p><code>限流削峰</code><br>利用消息队列做一个通用的“漏斗”，防止短时间内高流量压垮应用。</p>\n<h4 id=\"组件\"><a href=\"#组件\" class=\"headerlink\" title=\"组件\"></a>组件</h4><p><code>server（broker）</code><br>接收和分发消息的应用，RabbitMQ Server就是消息代理服务器。</p>\n<p><code>virtualHost</code><br>虚拟的broker，拥有自己的队列、交换器和绑定，拥有自己的权限机制，virtualHost之间是绝对隔离的。</p>\n<p><code>exchange</code><br>接收消息，消息到达代broker的第一站。<br>路由消息，根据路由键分发消息到queue。</p>\n<p><code>Queue</code><br>它是消息的容器，消息最终到达队列中，等待消费者消费。<br>一个消息可投入一个或多个队列。</p>\n<p><code>message</code><br>它由消息头和消息体组成。消息体是不透明的，而消息头则由一系列的可选属性组成，这些属性包括routing-key（路由键）、priority（相对于其他消息的优先权）、delivery-mode（指出该消息可能需要持久性存储）等。</p>\n<h4 id=\"Exchange模式\"><a href=\"#Exchange模式\" class=\"headerlink\" title=\"Exchange模式\"></a>Exchange模式</h4><p><code>Direct Exchange</code><br>这种模式下不需要将Exchange进行任何绑定(binding)操作。<br>该模式的自带Exchange，称其为default Exchange，名字为空字符串。<br>消息传递时需要“RouteKey”，为要发送到的队列名字。<br>如果vhost中不存在RouteKey中指定的队列名，则该消息会被抛弃。</p>\n<p><code>Fanout Exchange</code><br>不需要RouteKey，转发到与该Exchange绑定(Binding)的所有Queue上。</p>\n<p><code>Topic Exchange</code><br>这种模式支持路由键的模糊匹配，匹配成功会被路由到相应队列。</p>\n"},{"title":"Redis必知必会","date":"2018-05-01T16:00:00.000Z","_content":">开源KV数据库\n>由C语言编写\n>支持丰富的数据类型：string，set，list，sorted set，hash\n>数据操作具有原子性\n>支持数据持久化\n>可集群扩展 \n\n#### 优势\n\n- 速度快，整个数据库统统加载在内存当中进行操作；\n- 支持保存多种数据结构；\n- 操作都是原子性；\n- 支持事务；\n- 丰富的特性，支持有序集合，支持ttl，支持发布订阅；\n\n#### 数据结构\n\n`string`\n- 赋值：SET key value。如set hello world\n- 取值：GET key。如get hello。返回是world\n- 自增：INCR key。该key的值都会+1。该操作是原子操作。\n- 自减：DECR key。该key的值都会-1。该操作是原子操作。\n\n`list`\n- 向头部插入：LPUSH key value1 value2...\n- 向尾部插入：RPUSH key value1 value2...\n- 从头部弹出：LPOP key。返回被弹出的元素值。\n- 从尾部弹出：RPOP key。返回被弹出的元素值。\n- 列表元素个数：LLEN key。key不存在返回0。\n- 获取列表的子列表：LRANGE start end。\n            \n`set`\n- 增加：SADD key value。\n- 删除：SREM key value。\n- 获取指定集合的所有元素：SMEMBERS key。\n- 判断某个元素是否存在：SISMEMBER key value。\n- 差集运算：SDIFF key1 key2...。对多个集合进行差集运算。\n- 交集运算：SINNER key1 key2...。对多个集合进行交集运算。\n- 并集运算：SUNION key1 key2...。对多个集合进行并集运算。\n- 获取集合中元素个数：SCARD key。返回集合中元素的总个数。\n            \n`sorted set`\n- 增加：ZADD key sorce1 value1 sorce2 value2...。\n- 获取分数：ZSCORE key value。\n- 获取分数范围内的元素：ZRANGEBYSCORE key min max \n- 为某个元素增加分数：ZINCRBY key increment value。\n\n`hash`\n- 赋值：HSET key field value。\n- 取值：HGET key field。\n- 同一个key多个字段赋值：HMSET key field1 value1 field2 value2...。\n- 同一个KEY多个字段取值：HMGET key field1 fields2...。\n- 获取KEY的所有字段和所有值：HGETALL key。\n- 字段是否存在：HEXISTS key field。存在返回1，不存在返回0。\n当字段不存在时赋值：HSETNX key field value。如果key下面的字段field不存在，则建立field字段，且值为value。如果field字段存在，则不执行任何操作。这个命令的是原子操作。\n            \n#### 持久化\n\n`RDB`\n>#在900秒之后，如果至少有1个key发生变化，则dump内存快照\n>save 900 1  \n          \n\n- RDB持久化是指在指定的时间间隔内将内存中的数据集快照写入磁盘，实际操作过程是fork一个子进程，先将数据集写入临时文件，写入成功后，再替换之前的文件，用二进制压缩存储。\n- 性能最大化。对于Redis的服务进程而言，在开始持久化时，它唯一需要做的只是fork出子进程，之后再由子进程完成这些持久化的工作，这样就可以极大的避免服务进程执行IO操作了。\n- 相比于AOF机制，如果数据集很大，RDB的启动效率会更高。\n- 如果当数据集较大时，可能会导致整个服务器停止服务。\n\n`AOF`\n>appendfsync always     #每次有数据修改发生时都会写入AOF文件。\n>appendfsync everysec  #每秒钟同步一次，该策略为AOF的缺省策略。\n>appendfsync no          #从不同步。高效但是数据不会被持久化。\n\n- AOF持久化以日志的形式记录服务器所处理的每一个写、删除操作，查询操作不会记录，以文本的方式记录，可以打开文件看到详细的操作记录。\n- 该机制可以带来更高的数据安全性。\n- Redis 4.0 推出RDB-AOF 混合持久化。\n\n#### 内存淘汰\nmaxmemory参数，可以控制其最大可用内存大小（字节）。\n超过maxmemory时，根据maxmemory-policy参数进行内存淘汰。\n>volatile-lru     使用LRU算法删除一个键（只对设置了生存时间的键）\nallkeys-lru       使用LRU算法删除一个键\nvolatile-random   随机删除一个键（只对设置了生存时间的键）\nallkeys-random    随机删除一个键\nvolatile-ttl      删除生存时间最近的一个键\nnoeviction（默认配置）  不删除键，只返回错误\n\n#### 集群扩展\n`官方cluster方案`\n配置成主从结构，即一个master主节点，挂n个slave从节点。如果主节点失效，redis cluster会根据选举算法从slave节点中选择一个上升为master节点，整个集群继续对外提供服务。\n\n`twemproxy`\ntwitter开源的代理分区方案。\n\n`codis`\n豌豆荚开源的代理分区方案。\n\n`客户端分片`\n分区的逻辑在客户端实现，由客户端自己选择请求到哪个节点。\n\n#### 注意\n\n- keys指令会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复。\n- 使得过期时间分散一些，否则可能会出现短暂的卡顿现象。","source":"_posts/Redis必知必会.md","raw":"---\ntitle: Redis必知必会\ncategories:\n- 数据库\ndate: 2018-05-02 \ntags:\n- Redis\n---\n>开源KV数据库\n>由C语言编写\n>支持丰富的数据类型：string，set，list，sorted set，hash\n>数据操作具有原子性\n>支持数据持久化\n>可集群扩展 \n\n#### 优势\n\n- 速度快，整个数据库统统加载在内存当中进行操作；\n- 支持保存多种数据结构；\n- 操作都是原子性；\n- 支持事务；\n- 丰富的特性，支持有序集合，支持ttl，支持发布订阅；\n\n#### 数据结构\n\n`string`\n- 赋值：SET key value。如set hello world\n- 取值：GET key。如get hello。返回是world\n- 自增：INCR key。该key的值都会+1。该操作是原子操作。\n- 自减：DECR key。该key的值都会-1。该操作是原子操作。\n\n`list`\n- 向头部插入：LPUSH key value1 value2...\n- 向尾部插入：RPUSH key value1 value2...\n- 从头部弹出：LPOP key。返回被弹出的元素值。\n- 从尾部弹出：RPOP key。返回被弹出的元素值。\n- 列表元素个数：LLEN key。key不存在返回0。\n- 获取列表的子列表：LRANGE start end。\n            \n`set`\n- 增加：SADD key value。\n- 删除：SREM key value。\n- 获取指定集合的所有元素：SMEMBERS key。\n- 判断某个元素是否存在：SISMEMBER key value。\n- 差集运算：SDIFF key1 key2...。对多个集合进行差集运算。\n- 交集运算：SINNER key1 key2...。对多个集合进行交集运算。\n- 并集运算：SUNION key1 key2...。对多个集合进行并集运算。\n- 获取集合中元素个数：SCARD key。返回集合中元素的总个数。\n            \n`sorted set`\n- 增加：ZADD key sorce1 value1 sorce2 value2...。\n- 获取分数：ZSCORE key value。\n- 获取分数范围内的元素：ZRANGEBYSCORE key min max \n- 为某个元素增加分数：ZINCRBY key increment value。\n\n`hash`\n- 赋值：HSET key field value。\n- 取值：HGET key field。\n- 同一个key多个字段赋值：HMSET key field1 value1 field2 value2...。\n- 同一个KEY多个字段取值：HMGET key field1 fields2...。\n- 获取KEY的所有字段和所有值：HGETALL key。\n- 字段是否存在：HEXISTS key field。存在返回1，不存在返回0。\n当字段不存在时赋值：HSETNX key field value。如果key下面的字段field不存在，则建立field字段，且值为value。如果field字段存在，则不执行任何操作。这个命令的是原子操作。\n            \n#### 持久化\n\n`RDB`\n>#在900秒之后，如果至少有1个key发生变化，则dump内存快照\n>save 900 1  \n          \n\n- RDB持久化是指在指定的时间间隔内将内存中的数据集快照写入磁盘，实际操作过程是fork一个子进程，先将数据集写入临时文件，写入成功后，再替换之前的文件，用二进制压缩存储。\n- 性能最大化。对于Redis的服务进程而言，在开始持久化时，它唯一需要做的只是fork出子进程，之后再由子进程完成这些持久化的工作，这样就可以极大的避免服务进程执行IO操作了。\n- 相比于AOF机制，如果数据集很大，RDB的启动效率会更高。\n- 如果当数据集较大时，可能会导致整个服务器停止服务。\n\n`AOF`\n>appendfsync always     #每次有数据修改发生时都会写入AOF文件。\n>appendfsync everysec  #每秒钟同步一次，该策略为AOF的缺省策略。\n>appendfsync no          #从不同步。高效但是数据不会被持久化。\n\n- AOF持久化以日志的形式记录服务器所处理的每一个写、删除操作，查询操作不会记录，以文本的方式记录，可以打开文件看到详细的操作记录。\n- 该机制可以带来更高的数据安全性。\n- Redis 4.0 推出RDB-AOF 混合持久化。\n\n#### 内存淘汰\nmaxmemory参数，可以控制其最大可用内存大小（字节）。\n超过maxmemory时，根据maxmemory-policy参数进行内存淘汰。\n>volatile-lru     使用LRU算法删除一个键（只对设置了生存时间的键）\nallkeys-lru       使用LRU算法删除一个键\nvolatile-random   随机删除一个键（只对设置了生存时间的键）\nallkeys-random    随机删除一个键\nvolatile-ttl      删除生存时间最近的一个键\nnoeviction（默认配置）  不删除键，只返回错误\n\n#### 集群扩展\n`官方cluster方案`\n配置成主从结构，即一个master主节点，挂n个slave从节点。如果主节点失效，redis cluster会根据选举算法从slave节点中选择一个上升为master节点，整个集群继续对外提供服务。\n\n`twemproxy`\ntwitter开源的代理分区方案。\n\n`codis`\n豌豆荚开源的代理分区方案。\n\n`客户端分片`\n分区的逻辑在客户端实现，由客户端自己选择请求到哪个节点。\n\n#### 注意\n\n- keys指令会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复。\n- 使得过期时间分散一些，否则可能会出现短暂的卡顿现象。","slug":"Redis必知必会","published":1,"updated":"2018-12-25T01:48:13.378Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjwq2jfdg0011qxpjasiwm64s","content":"<blockquote>\n<p>开源KV数据库<br>由C语言编写<br>支持丰富的数据类型：string，set，list，sorted set，hash<br>数据操作具有原子性<br>支持数据持久化<br>可集群扩展 </p>\n</blockquote>\n<h4 id=\"优势\"><a href=\"#优势\" class=\"headerlink\" title=\"优势\"></a>优势</h4><ul>\n<li>速度快，整个数据库统统加载在内存当中进行操作；</li>\n<li>支持保存多种数据结构；</li>\n<li>操作都是原子性；</li>\n<li>支持事务；</li>\n<li>丰富的特性，支持有序集合，支持ttl，支持发布订阅；</li>\n</ul>\n<h4 id=\"数据结构\"><a href=\"#数据结构\" class=\"headerlink\" title=\"数据结构\"></a>数据结构</h4><p><code>string</code></p>\n<ul>\n<li>赋值：SET key value。如set hello world</li>\n<li>取值：GET key。如get hello。返回是world</li>\n<li>自增：INCR key。该key的值都会+1。该操作是原子操作。</li>\n<li>自减：DECR key。该key的值都会-1。该操作是原子操作。</li>\n</ul>\n<p><code>list</code></p>\n<ul>\n<li>向头部插入：LPUSH key value1 value2…</li>\n<li>向尾部插入：RPUSH key value1 value2…</li>\n<li>从头部弹出：LPOP key。返回被弹出的元素值。</li>\n<li>从尾部弹出：RPOP key。返回被弹出的元素值。</li>\n<li>列表元素个数：LLEN key。key不存在返回0。</li>\n<li>获取列表的子列表：LRANGE start end。</li>\n</ul>\n<p><code>set</code></p>\n<ul>\n<li>增加：SADD key value。</li>\n<li>删除：SREM key value。</li>\n<li>获取指定集合的所有元素：SMEMBERS key。</li>\n<li>判断某个元素是否存在：SISMEMBER key value。</li>\n<li>差集运算：SDIFF key1 key2…。对多个集合进行差集运算。</li>\n<li>交集运算：SINNER key1 key2…。对多个集合进行交集运算。</li>\n<li>并集运算：SUNION key1 key2…。对多个集合进行并集运算。</li>\n<li>获取集合中元素个数：SCARD key。返回集合中元素的总个数。</li>\n</ul>\n<p><code>sorted set</code></p>\n<ul>\n<li>增加：ZADD key sorce1 value1 sorce2 value2…。</li>\n<li>获取分数：ZSCORE key value。</li>\n<li>获取分数范围内的元素：ZRANGEBYSCORE key min max </li>\n<li>为某个元素增加分数：ZINCRBY key increment value。</li>\n</ul>\n<p><code>hash</code></p>\n<ul>\n<li>赋值：HSET key field value。</li>\n<li>取值：HGET key field。</li>\n<li>同一个key多个字段赋值：HMSET key field1 value1 field2 value2…。</li>\n<li>同一个KEY多个字段取值：HMGET key field1 fields2…。</li>\n<li>获取KEY的所有字段和所有值：HGETALL key。</li>\n<li>字段是否存在：HEXISTS key field。存在返回1，不存在返回0。<br>当字段不存在时赋值：HSETNX key field value。如果key下面的字段field不存在，则建立field字段，且值为value。如果field字段存在，则不执行任何操作。这个命令的是原子操作。</li>\n</ul>\n<h4 id=\"持久化\"><a href=\"#持久化\" class=\"headerlink\" title=\"持久化\"></a>持久化</h4><p><code>RDB</code></p>\n<blockquote>\n<p>#在900秒之后，如果至少有1个key发生变化，则dump内存快照<br>save 900 1  </p>\n</blockquote>\n<ul>\n<li>RDB持久化是指在指定的时间间隔内将内存中的数据集快照写入磁盘，实际操作过程是fork一个子进程，先将数据集写入临时文件，写入成功后，再替换之前的文件，用二进制压缩存储。</li>\n<li>性能最大化。对于Redis的服务进程而言，在开始持久化时，它唯一需要做的只是fork出子进程，之后再由子进程完成这些持久化的工作，这样就可以极大的避免服务进程执行IO操作了。</li>\n<li>相比于AOF机制，如果数据集很大，RDB的启动效率会更高。</li>\n<li>如果当数据集较大时，可能会导致整个服务器停止服务。</li>\n</ul>\n<p><code>AOF</code></p>\n<blockquote>\n<p>appendfsync always     #每次有数据修改发生时都会写入AOF文件。<br>appendfsync everysec  #每秒钟同步一次，该策略为AOF的缺省策略。<br>appendfsync no          #从不同步。高效但是数据不会被持久化。</p>\n</blockquote>\n<ul>\n<li>AOF持久化以日志的形式记录服务器所处理的每一个写、删除操作，查询操作不会记录，以文本的方式记录，可以打开文件看到详细的操作记录。</li>\n<li>该机制可以带来更高的数据安全性。</li>\n<li>Redis 4.0 推出RDB-AOF 混合持久化。</li>\n</ul>\n<h4 id=\"内存淘汰\"><a href=\"#内存淘汰\" class=\"headerlink\" title=\"内存淘汰\"></a>内存淘汰</h4><p>maxmemory参数，可以控制其最大可用内存大小（字节）。<br>超过maxmemory时，根据maxmemory-policy参数进行内存淘汰。</p>\n<blockquote>\n<p>volatile-lru     使用LRU算法删除一个键（只对设置了生存时间的键）<br>allkeys-lru       使用LRU算法删除一个键<br>volatile-random   随机删除一个键（只对设置了生存时间的键）<br>allkeys-random    随机删除一个键<br>volatile-ttl      删除生存时间最近的一个键<br>noeviction（默认配置）  不删除键，只返回错误</p>\n</blockquote>\n<h4 id=\"集群扩展\"><a href=\"#集群扩展\" class=\"headerlink\" title=\"集群扩展\"></a>集群扩展</h4><p><code>官方cluster方案</code><br>配置成主从结构，即一个master主节点，挂n个slave从节点。如果主节点失效，redis cluster会根据选举算法从slave节点中选择一个上升为master节点，整个集群继续对外提供服务。</p>\n<p><code>twemproxy</code><br>twitter开源的代理分区方案。</p>\n<p><code>codis</code><br>豌豆荚开源的代理分区方案。</p>\n<p><code>客户端分片</code><br>分区的逻辑在客户端实现，由客户端自己选择请求到哪个节点。</p>\n<h4 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h4><ul>\n<li>keys指令会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复。</li>\n<li>使得过期时间分散一些，否则可能会出现短暂的卡顿现象。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>开源KV数据库<br>由C语言编写<br>支持丰富的数据类型：string，set，list，sorted set，hash<br>数据操作具有原子性<br>支持数据持久化<br>可集群扩展 </p>\n</blockquote>\n<h4 id=\"优势\"><a href=\"#优势\" class=\"headerlink\" title=\"优势\"></a>优势</h4><ul>\n<li>速度快，整个数据库统统加载在内存当中进行操作；</li>\n<li>支持保存多种数据结构；</li>\n<li>操作都是原子性；</li>\n<li>支持事务；</li>\n<li>丰富的特性，支持有序集合，支持ttl，支持发布订阅；</li>\n</ul>\n<h4 id=\"数据结构\"><a href=\"#数据结构\" class=\"headerlink\" title=\"数据结构\"></a>数据结构</h4><p><code>string</code></p>\n<ul>\n<li>赋值：SET key value。如set hello world</li>\n<li>取值：GET key。如get hello。返回是world</li>\n<li>自增：INCR key。该key的值都会+1。该操作是原子操作。</li>\n<li>自减：DECR key。该key的值都会-1。该操作是原子操作。</li>\n</ul>\n<p><code>list</code></p>\n<ul>\n<li>向头部插入：LPUSH key value1 value2…</li>\n<li>向尾部插入：RPUSH key value1 value2…</li>\n<li>从头部弹出：LPOP key。返回被弹出的元素值。</li>\n<li>从尾部弹出：RPOP key。返回被弹出的元素值。</li>\n<li>列表元素个数：LLEN key。key不存在返回0。</li>\n<li>获取列表的子列表：LRANGE start end。</li>\n</ul>\n<p><code>set</code></p>\n<ul>\n<li>增加：SADD key value。</li>\n<li>删除：SREM key value。</li>\n<li>获取指定集合的所有元素：SMEMBERS key。</li>\n<li>判断某个元素是否存在：SISMEMBER key value。</li>\n<li>差集运算：SDIFF key1 key2…。对多个集合进行差集运算。</li>\n<li>交集运算：SINNER key1 key2…。对多个集合进行交集运算。</li>\n<li>并集运算：SUNION key1 key2…。对多个集合进行并集运算。</li>\n<li>获取集合中元素个数：SCARD key。返回集合中元素的总个数。</li>\n</ul>\n<p><code>sorted set</code></p>\n<ul>\n<li>增加：ZADD key sorce1 value1 sorce2 value2…。</li>\n<li>获取分数：ZSCORE key value。</li>\n<li>获取分数范围内的元素：ZRANGEBYSCORE key min max </li>\n<li>为某个元素增加分数：ZINCRBY key increment value。</li>\n</ul>\n<p><code>hash</code></p>\n<ul>\n<li>赋值：HSET key field value。</li>\n<li>取值：HGET key field。</li>\n<li>同一个key多个字段赋值：HMSET key field1 value1 field2 value2…。</li>\n<li>同一个KEY多个字段取值：HMGET key field1 fields2…。</li>\n<li>获取KEY的所有字段和所有值：HGETALL key。</li>\n<li>字段是否存在：HEXISTS key field。存在返回1，不存在返回0。<br>当字段不存在时赋值：HSETNX key field value。如果key下面的字段field不存在，则建立field字段，且值为value。如果field字段存在，则不执行任何操作。这个命令的是原子操作。</li>\n</ul>\n<h4 id=\"持久化\"><a href=\"#持久化\" class=\"headerlink\" title=\"持久化\"></a>持久化</h4><p><code>RDB</code></p>\n<blockquote>\n<p>#在900秒之后，如果至少有1个key发生变化，则dump内存快照<br>save 900 1  </p>\n</blockquote>\n<ul>\n<li>RDB持久化是指在指定的时间间隔内将内存中的数据集快照写入磁盘，实际操作过程是fork一个子进程，先将数据集写入临时文件，写入成功后，再替换之前的文件，用二进制压缩存储。</li>\n<li>性能最大化。对于Redis的服务进程而言，在开始持久化时，它唯一需要做的只是fork出子进程，之后再由子进程完成这些持久化的工作，这样就可以极大的避免服务进程执行IO操作了。</li>\n<li>相比于AOF机制，如果数据集很大，RDB的启动效率会更高。</li>\n<li>如果当数据集较大时，可能会导致整个服务器停止服务。</li>\n</ul>\n<p><code>AOF</code></p>\n<blockquote>\n<p>appendfsync always     #每次有数据修改发生时都会写入AOF文件。<br>appendfsync everysec  #每秒钟同步一次，该策略为AOF的缺省策略。<br>appendfsync no          #从不同步。高效但是数据不会被持久化。</p>\n</blockquote>\n<ul>\n<li>AOF持久化以日志的形式记录服务器所处理的每一个写、删除操作，查询操作不会记录，以文本的方式记录，可以打开文件看到详细的操作记录。</li>\n<li>该机制可以带来更高的数据安全性。</li>\n<li>Redis 4.0 推出RDB-AOF 混合持久化。</li>\n</ul>\n<h4 id=\"内存淘汰\"><a href=\"#内存淘汰\" class=\"headerlink\" title=\"内存淘汰\"></a>内存淘汰</h4><p>maxmemory参数，可以控制其最大可用内存大小（字节）。<br>超过maxmemory时，根据maxmemory-policy参数进行内存淘汰。</p>\n<blockquote>\n<p>volatile-lru     使用LRU算法删除一个键（只对设置了生存时间的键）<br>allkeys-lru       使用LRU算法删除一个键<br>volatile-random   随机删除一个键（只对设置了生存时间的键）<br>allkeys-random    随机删除一个键<br>volatile-ttl      删除生存时间最近的一个键<br>noeviction（默认配置）  不删除键，只返回错误</p>\n</blockquote>\n<h4 id=\"集群扩展\"><a href=\"#集群扩展\" class=\"headerlink\" title=\"集群扩展\"></a>集群扩展</h4><p><code>官方cluster方案</code><br>配置成主从结构，即一个master主节点，挂n个slave从节点。如果主节点失效，redis cluster会根据选举算法从slave节点中选择一个上升为master节点，整个集群继续对外提供服务。</p>\n<p><code>twemproxy</code><br>twitter开源的代理分区方案。</p>\n<p><code>codis</code><br>豌豆荚开源的代理分区方案。</p>\n<p><code>客户端分片</code><br>分区的逻辑在客户端实现，由客户端自己选择请求到哪个节点。</p>\n<h4 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h4><ul>\n<li>keys指令会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复。</li>\n<li>使得过期时间分散一些，否则可能会出现短暂的卡顿现象。</li>\n</ul>\n"},{"title":"并发编程必知必会","date":"2018-07-11T16:00:00.000Z","_content":"#### 线程创建的方式\n`继承Thread类`\n```\npublic class ThreadTest extends Thread {\n\n    //重写run方法\n    @Override\n    public void run() {\n        System.out.println(getName());\n    }\n\n    public static void main(String[] args) {\n        //调用start方法启动线程\n        new ThreadTest().start();\n        System.out.println(\"main\");\n    }\n\n}\n```\n\n`实现Runable接口`\n```\npublic class RunnableTest implements Runnable {\n\n    //实现run方法\n    @Override\n    public void run() {\n        System.out.println(\"run\");\n    }\n\n    public static void main(String[] args) {\n        //使用Runnable对象，创建Thread对象\n        new Thread(new RunnableTest()).start();\n        System.out.println(\"main\");\n    }\n\n}\n```\n\n`实现Callable接口，结合FutureTask`\n```\npublic class CallableTest implements Callable<String> {\n\n    //实现call方法\n    @Override\n    public String call() throws Exception {\n        return \"call\";\n    }\n\n    public static void main(String[] args) {\n        //使用Callable对象，创建FutureTask对象\n        FutureTask<String> future = new FutureTask<>(new CallableTest());\n        //使用FutureTask对象，创建Thread对象\n        new Thread(future).start();\n        System.out.println(future.get());\n        System.out.println(\"main\");\n    }\n\n}\n```\n#### 线程的生命周期\n新建（new），就绪（runable），运行（running），阻塞（blocked），死亡（dead）五个状态。\n![](https://github.com/echolixiaopeng/blog/raw/master/data/java-thread-life-cycle.png)\n\n`new -> runable`\n新建的线程调用start方法，进入runable状态。\n\n`runable -> running`\n就绪的线程，由线程调度器调度，获取到CPU资源后进入running状态。\n\n`running -> runable`\n运行的线程，失去CPU资源或调用yield方法后，回到runable状态。\n\n`running -> blocked`\n运行的线程，调用sleep方法后，或调用阻塞IO方法时，或等待同步监视器，或等待notify时，或调用suspend方法后，进入阻塞状态。\n\n`blocked -> runable`\nsleep过了设定的时间，阻塞的IO方法已返回，已获取同步监视器，已收到notify，已调用resume方法恢复，进去就绪状态。\n\n`running -> dead`\n方法已经执行完毕，或执行时抛出未捕获的异常，或调用stop方法结束该线程。\n\n#### 线程控制\n\n`thread.join()`\n当前线程等待指定线程完成。\n调用线程将被阻塞，直到join方法加入的线程执行完毕为止。\njoin(long millis)，超过时间后将不再等待该线程。\n\n`Thread.sleep()`\n当前线程进入阻塞状态。\nsleep(long millis)，当前线程将阻塞状态，暂停指定时间。\n即使系统中没有其他可执行的线程，sleep后的线程也不会执行。\n\n`Thread.yield()`\n当前线程进入就绪状态。\n多CPU环境下，该操作的效果不明显。\n\n`Thread.currentThread.setPriority()`\n设置当前线程的优先级。\n使用JDK常量指定优先级，保证移植性。\n\n`thread.setDaemon()`\n设置线程为后台线程。\n设置必须在调用start方法之前。\n所有的前台线程都死亡，后台线程都会死亡。\n前台线程默认创建的事前台线程，后台线程亦然。\n\n#### 线程同步\n>死锁：两个线程互相等待对方释放同步监视器。\n\n`同步代码块`\n```\nsynchronized(obj){\n//同步的代码\n}\n```\n逻辑：加锁 -> 修改 -> 释放锁\nobj是同步监视器。\n任何时刻只能有一个线程获取同步监视器。\n线程开始执行同步代码块之前，必须先获得同步监视器。\n同步代码块执行完成之后，会释放同步监视器。\n\n`同步方法`\n```\npublic synchronized void test(){\n}\n```\n逻辑：加锁 -> 修改 -> 释放锁\nthis是同步监视器。\n\n`同步锁`\n```\nreentrantLock.lock();\ntry{}\nfinally{\nreentrantLock.unlock;\n}\n```\n显式的定义同步锁，显式的加锁，显式的释放锁。\n只能有一个线程对Lock对象进行加锁。\nReentrantLock是Lock的实现。\nReentrantLock是重入锁，可对已经加锁的锁再次加锁。\n\n#### 线程通信\n`传统的线程通信`\nobj.wait()方法：释放同步监视器，当前线程进入Blocked状态，不会再次竞争。\nobj.notify()方法：唤醒在此同步监视器上的单个线程，选择是随机的。\nobj.notifyAll()方法：唤醒在此同步监视器上的所有线程。\nnotify后，被唤醒的线程会再次竞争同步监视器。\n\n`使用Condition控制`\n通过Lock对象的lock.newCondition()获取condition对象。\ncondition.await()相当于obj.wait()。\ncondition.signal()相当于obj.notify()。\ncondition.signalAll()相当于obj.notifyAll()。\n\n`使用BlockingQueue`\nput时，队列已满，则阻塞该线程。\ntake时，队列已空，则阻塞该线程。\n\n#### 线程池\n>线程池适合任务处理时间短，且任务数量大的场景。\n>线程池优点：降低资源消耗，减少线程创建和销毁的消耗。\n>线程池优点：加快响应速度，不用等待线程创建。\n>线程池优点：线程可管理，无限制创建线程会降低系统稳定性，线程池可统一管理。\n>Executors 返回的线程池对象，会引起OOM问题。\n>推荐通过 ThreadPoolExecutor 的方式，创建线程池。\n\n##### ThreadPoolExecutor\n\n* `构造参数`\n  corePoolSize：核心线程数量；\n  maximumPoolSize：最大线程数量；\n  workQueue：等待队列；\n  handler：表示线程池的饱和策略；\n  \n* `方法`\n  execute()，提交任务。\n  shutdown（），将线程池设置成SHUTDOWN状态，然后中断所有正在执行的任务。\n  shutdownNow（），将线程池的状态设置为STOP，，然后尝试停止所有正在执行或暂停任务的线程，并返回等待执行任务的列表。\n  \n  \n* `执行过程`\n如果workerCount < corePoolSize，则创建并启动一个线程来执行新提交的任务；\n如果workerCount >= corePoolSize，且线程池内的阻塞队列未满，则将任务添加到该阻塞队列中；\n如果workerCount >= corePoolSize && workerCount < maximumPoolSize，且线程池内的阻塞队列已满，则创建并启动一个线程来执行新提交的任务；\n如果workerCount >= maximumPoolSize，并且线程池内的阻塞队列已满, 则根据拒绝策略来处理该任务, 默认的处理方式是直接抛异常。\n\n* `线程池分配`\nCPU密集型任务：N+1个线程。\nIO密集型任务：2N个线程。\n混合型任务：拆分成一个CPU密集型任务和一个IO密集型任务。\n\n\n\n\n","source":"_posts/并发编程必知必会.md","raw":"---\ntitle: 并发编程必知必会\ncategories:\n- JAVA\ndate: 2018-07-12 \ntags:\n- JVM\n---\n#### 线程创建的方式\n`继承Thread类`\n```\npublic class ThreadTest extends Thread {\n\n    //重写run方法\n    @Override\n    public void run() {\n        System.out.println(getName());\n    }\n\n    public static void main(String[] args) {\n        //调用start方法启动线程\n        new ThreadTest().start();\n        System.out.println(\"main\");\n    }\n\n}\n```\n\n`实现Runable接口`\n```\npublic class RunnableTest implements Runnable {\n\n    //实现run方法\n    @Override\n    public void run() {\n        System.out.println(\"run\");\n    }\n\n    public static void main(String[] args) {\n        //使用Runnable对象，创建Thread对象\n        new Thread(new RunnableTest()).start();\n        System.out.println(\"main\");\n    }\n\n}\n```\n\n`实现Callable接口，结合FutureTask`\n```\npublic class CallableTest implements Callable<String> {\n\n    //实现call方法\n    @Override\n    public String call() throws Exception {\n        return \"call\";\n    }\n\n    public static void main(String[] args) {\n        //使用Callable对象，创建FutureTask对象\n        FutureTask<String> future = new FutureTask<>(new CallableTest());\n        //使用FutureTask对象，创建Thread对象\n        new Thread(future).start();\n        System.out.println(future.get());\n        System.out.println(\"main\");\n    }\n\n}\n```\n#### 线程的生命周期\n新建（new），就绪（runable），运行（running），阻塞（blocked），死亡（dead）五个状态。\n![](https://github.com/echolixiaopeng/blog/raw/master/data/java-thread-life-cycle.png)\n\n`new -> runable`\n新建的线程调用start方法，进入runable状态。\n\n`runable -> running`\n就绪的线程，由线程调度器调度，获取到CPU资源后进入running状态。\n\n`running -> runable`\n运行的线程，失去CPU资源或调用yield方法后，回到runable状态。\n\n`running -> blocked`\n运行的线程，调用sleep方法后，或调用阻塞IO方法时，或等待同步监视器，或等待notify时，或调用suspend方法后，进入阻塞状态。\n\n`blocked -> runable`\nsleep过了设定的时间，阻塞的IO方法已返回，已获取同步监视器，已收到notify，已调用resume方法恢复，进去就绪状态。\n\n`running -> dead`\n方法已经执行完毕，或执行时抛出未捕获的异常，或调用stop方法结束该线程。\n\n#### 线程控制\n\n`thread.join()`\n当前线程等待指定线程完成。\n调用线程将被阻塞，直到join方法加入的线程执行完毕为止。\njoin(long millis)，超过时间后将不再等待该线程。\n\n`Thread.sleep()`\n当前线程进入阻塞状态。\nsleep(long millis)，当前线程将阻塞状态，暂停指定时间。\n即使系统中没有其他可执行的线程，sleep后的线程也不会执行。\n\n`Thread.yield()`\n当前线程进入就绪状态。\n多CPU环境下，该操作的效果不明显。\n\n`Thread.currentThread.setPriority()`\n设置当前线程的优先级。\n使用JDK常量指定优先级，保证移植性。\n\n`thread.setDaemon()`\n设置线程为后台线程。\n设置必须在调用start方法之前。\n所有的前台线程都死亡，后台线程都会死亡。\n前台线程默认创建的事前台线程，后台线程亦然。\n\n#### 线程同步\n>死锁：两个线程互相等待对方释放同步监视器。\n\n`同步代码块`\n```\nsynchronized(obj){\n//同步的代码\n}\n```\n逻辑：加锁 -> 修改 -> 释放锁\nobj是同步监视器。\n任何时刻只能有一个线程获取同步监视器。\n线程开始执行同步代码块之前，必须先获得同步监视器。\n同步代码块执行完成之后，会释放同步监视器。\n\n`同步方法`\n```\npublic synchronized void test(){\n}\n```\n逻辑：加锁 -> 修改 -> 释放锁\nthis是同步监视器。\n\n`同步锁`\n```\nreentrantLock.lock();\ntry{}\nfinally{\nreentrantLock.unlock;\n}\n```\n显式的定义同步锁，显式的加锁，显式的释放锁。\n只能有一个线程对Lock对象进行加锁。\nReentrantLock是Lock的实现。\nReentrantLock是重入锁，可对已经加锁的锁再次加锁。\n\n#### 线程通信\n`传统的线程通信`\nobj.wait()方法：释放同步监视器，当前线程进入Blocked状态，不会再次竞争。\nobj.notify()方法：唤醒在此同步监视器上的单个线程，选择是随机的。\nobj.notifyAll()方法：唤醒在此同步监视器上的所有线程。\nnotify后，被唤醒的线程会再次竞争同步监视器。\n\n`使用Condition控制`\n通过Lock对象的lock.newCondition()获取condition对象。\ncondition.await()相当于obj.wait()。\ncondition.signal()相当于obj.notify()。\ncondition.signalAll()相当于obj.notifyAll()。\n\n`使用BlockingQueue`\nput时，队列已满，则阻塞该线程。\ntake时，队列已空，则阻塞该线程。\n\n#### 线程池\n>线程池适合任务处理时间短，且任务数量大的场景。\n>线程池优点：降低资源消耗，减少线程创建和销毁的消耗。\n>线程池优点：加快响应速度，不用等待线程创建。\n>线程池优点：线程可管理，无限制创建线程会降低系统稳定性，线程池可统一管理。\n>Executors 返回的线程池对象，会引起OOM问题。\n>推荐通过 ThreadPoolExecutor 的方式，创建线程池。\n\n##### ThreadPoolExecutor\n\n* `构造参数`\n  corePoolSize：核心线程数量；\n  maximumPoolSize：最大线程数量；\n  workQueue：等待队列；\n  handler：表示线程池的饱和策略；\n  \n* `方法`\n  execute()，提交任务。\n  shutdown（），将线程池设置成SHUTDOWN状态，然后中断所有正在执行的任务。\n  shutdownNow（），将线程池的状态设置为STOP，，然后尝试停止所有正在执行或暂停任务的线程，并返回等待执行任务的列表。\n  \n  \n* `执行过程`\n如果workerCount < corePoolSize，则创建并启动一个线程来执行新提交的任务；\n如果workerCount >= corePoolSize，且线程池内的阻塞队列未满，则将任务添加到该阻塞队列中；\n如果workerCount >= corePoolSize && workerCount < maximumPoolSize，且线程池内的阻塞队列已满，则创建并启动一个线程来执行新提交的任务；\n如果workerCount >= maximumPoolSize，并且线程池内的阻塞队列已满, 则根据拒绝策略来处理该任务, 默认的处理方式是直接抛异常。\n\n* `线程池分配`\nCPU密集型任务：N+1个线程。\nIO密集型任务：2N个线程。\n混合型任务：拆分成一个CPU密集型任务和一个IO密集型任务。\n\n\n\n\n","slug":"并发编程必知必会","published":1,"updated":"2018-12-25T01:53:38.104Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjwq2jfdi0015qxpjx947kl52","content":"<h4 id=\"线程创建的方式\"><a href=\"#线程创建的方式\" class=\"headerlink\" title=\"线程创建的方式\"></a>线程创建的方式</h4><p><code>继承Thread类</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class ThreadTest extends Thread &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    //重写run方法</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void run() &#123;</span><br><span class=\"line\">        System.out.println(getName());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        //调用start方法启动线程</span><br><span class=\"line\">        new ThreadTest().start();</span><br><span class=\"line\">        System.out.println(&quot;main&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>实现Runable接口</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class RunnableTest implements Runnable &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    //实现run方法</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void run() &#123;</span><br><span class=\"line\">        System.out.println(&quot;run&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        //使用Runnable对象，创建Thread对象</span><br><span class=\"line\">        new Thread(new RunnableTest()).start();</span><br><span class=\"line\">        System.out.println(&quot;main&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>实现Callable接口，结合FutureTask</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class CallableTest implements Callable&lt;String&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    //实现call方法</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public String call() throws Exception &#123;</span><br><span class=\"line\">        return &quot;call&quot;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        //使用Callable对象，创建FutureTask对象</span><br><span class=\"line\">        FutureTask&lt;String&gt; future = new FutureTask&lt;&gt;(new CallableTest());</span><br><span class=\"line\">        //使用FutureTask对象，创建Thread对象</span><br><span class=\"line\">        new Thread(future).start();</span><br><span class=\"line\">        System.out.println(future.get());</span><br><span class=\"line\">        System.out.println(&quot;main&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"线程的生命周期\"><a href=\"#线程的生命周期\" class=\"headerlink\" title=\"线程的生命周期\"></a>线程的生命周期</h4><p>新建（new），就绪（runable），运行（running），阻塞（blocked），死亡（dead）五个状态。<br><img src=\"https://github.com/echolixiaopeng/blog/raw/master/data/java-thread-life-cycle.png\" alt></p>\n<p><code>new -&gt; runable</code><br>新建的线程调用start方法，进入runable状态。</p>\n<p><code>runable -&gt; running</code><br>就绪的线程，由线程调度器调度，获取到CPU资源后进入running状态。</p>\n<p><code>running -&gt; runable</code><br>运行的线程，失去CPU资源或调用yield方法后，回到runable状态。</p>\n<p><code>running -&gt; blocked</code><br>运行的线程，调用sleep方法后，或调用阻塞IO方法时，或等待同步监视器，或等待notify时，或调用suspend方法后，进入阻塞状态。</p>\n<p><code>blocked -&gt; runable</code><br>sleep过了设定的时间，阻塞的IO方法已返回，已获取同步监视器，已收到notify，已调用resume方法恢复，进去就绪状态。</p>\n<p><code>running -&gt; dead</code><br>方法已经执行完毕，或执行时抛出未捕获的异常，或调用stop方法结束该线程。</p>\n<h4 id=\"线程控制\"><a href=\"#线程控制\" class=\"headerlink\" title=\"线程控制\"></a>线程控制</h4><p><code>thread.join()</code><br>当前线程等待指定线程完成。<br>调用线程将被阻塞，直到join方法加入的线程执行完毕为止。<br>join(long millis)，超过时间后将不再等待该线程。</p>\n<p><code>Thread.sleep()</code><br>当前线程进入阻塞状态。<br>sleep(long millis)，当前线程将阻塞状态，暂停指定时间。<br>即使系统中没有其他可执行的线程，sleep后的线程也不会执行。</p>\n<p><code>Thread.yield()</code><br>当前线程进入就绪状态。<br>多CPU环境下，该操作的效果不明显。</p>\n<p><code>Thread.currentThread.setPriority()</code><br>设置当前线程的优先级。<br>使用JDK常量指定优先级，保证移植性。</p>\n<p><code>thread.setDaemon()</code><br>设置线程为后台线程。<br>设置必须在调用start方法之前。<br>所有的前台线程都死亡，后台线程都会死亡。<br>前台线程默认创建的事前台线程，后台线程亦然。</p>\n<h4 id=\"线程同步\"><a href=\"#线程同步\" class=\"headerlink\" title=\"线程同步\"></a>线程同步</h4><blockquote>\n<p>死锁：两个线程互相等待对方释放同步监视器。</p>\n</blockquote>\n<p><code>同步代码块</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">synchronized(obj)&#123;</span><br><span class=\"line\">//同步的代码</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>逻辑：加锁 -&gt; 修改 -&gt; 释放锁<br>obj是同步监视器。<br>任何时刻只能有一个线程获取同步监视器。<br>线程开始执行同步代码块之前，必须先获得同步监视器。<br>同步代码块执行完成之后，会释放同步监视器。</p>\n<p><code>同步方法</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public synchronized void test()&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>逻辑：加锁 -&gt; 修改 -&gt; 释放锁<br>this是同步监视器。</p>\n<p><code>同步锁</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">reentrantLock.lock();</span><br><span class=\"line\">try&#123;&#125;</span><br><span class=\"line\">finally&#123;</span><br><span class=\"line\">reentrantLock.unlock;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>显式的定义同步锁，显式的加锁，显式的释放锁。<br>只能有一个线程对Lock对象进行加锁。<br>ReentrantLock是Lock的实现。<br>ReentrantLock是重入锁，可对已经加锁的锁再次加锁。</p>\n<h4 id=\"线程通信\"><a href=\"#线程通信\" class=\"headerlink\" title=\"线程通信\"></a>线程通信</h4><p><code>传统的线程通信</code><br>obj.wait()方法：释放同步监视器，当前线程进入Blocked状态，不会再次竞争。<br>obj.notify()方法：唤醒在此同步监视器上的单个线程，选择是随机的。<br>obj.notifyAll()方法：唤醒在此同步监视器上的所有线程。<br>notify后，被唤醒的线程会再次竞争同步监视器。</p>\n<p><code>使用Condition控制</code><br>通过Lock对象的lock.newCondition()获取condition对象。<br>condition.await()相当于obj.wait()。<br>condition.signal()相当于obj.notify()。<br>condition.signalAll()相当于obj.notifyAll()。</p>\n<p><code>使用BlockingQueue</code><br>put时，队列已满，则阻塞该线程。<br>take时，队列已空，则阻塞该线程。</p>\n<h4 id=\"线程池\"><a href=\"#线程池\" class=\"headerlink\" title=\"线程池\"></a>线程池</h4><blockquote>\n<p>线程池适合任务处理时间短，且任务数量大的场景。<br>线程池优点：降低资源消耗，减少线程创建和销毁的消耗。<br>线程池优点：加快响应速度，不用等待线程创建。<br>线程池优点：线程可管理，无限制创建线程会降低系统稳定性，线程池可统一管理。<br>Executors 返回的线程池对象，会引起OOM问题。<br>推荐通过 ThreadPoolExecutor 的方式，创建线程池。</p>\n</blockquote>\n<h5 id=\"ThreadPoolExecutor\"><a href=\"#ThreadPoolExecutor\" class=\"headerlink\" title=\"ThreadPoolExecutor\"></a>ThreadPoolExecutor</h5><ul>\n<li><p><code>构造参数</code><br>corePoolSize：核心线程数量；<br>maximumPoolSize：最大线程数量；<br>workQueue：等待队列；<br>handler：表示线程池的饱和策略；</p>\n</li>\n<li><p><code>方法</code><br>execute()，提交任务。<br>shutdown（），将线程池设置成SHUTDOWN状态，然后中断所有正在执行的任务。<br>shutdownNow（），将线程池的状态设置为STOP，，然后尝试停止所有正在执行或暂停任务的线程，并返回等待执行任务的列表。</p>\n</li>\n</ul>\n<ul>\n<li><p><code>执行过程</code><br>如果workerCount &lt; corePoolSize，则创建并启动一个线程来执行新提交的任务；<br>如果workerCount &gt;= corePoolSize，且线程池内的阻塞队列未满，则将任务添加到该阻塞队列中；<br>如果workerCount &gt;= corePoolSize &amp;&amp; workerCount &lt; maximumPoolSize，且线程池内的阻塞队列已满，则创建并启动一个线程来执行新提交的任务；<br>如果workerCount &gt;= maximumPoolSize，并且线程池内的阻塞队列已满, 则根据拒绝策略来处理该任务, 默认的处理方式是直接抛异常。</p>\n</li>\n<li><p><code>线程池分配</code><br>CPU密集型任务：N+1个线程。<br>IO密集型任务：2N个线程。<br>混合型任务：拆分成一个CPU密集型任务和一个IO密集型任务。</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"线程创建的方式\"><a href=\"#线程创建的方式\" class=\"headerlink\" title=\"线程创建的方式\"></a>线程创建的方式</h4><p><code>继承Thread类</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class ThreadTest extends Thread &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    //重写run方法</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void run() &#123;</span><br><span class=\"line\">        System.out.println(getName());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        //调用start方法启动线程</span><br><span class=\"line\">        new ThreadTest().start();</span><br><span class=\"line\">        System.out.println(&quot;main&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>实现Runable接口</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class RunnableTest implements Runnable &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    //实现run方法</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void run() &#123;</span><br><span class=\"line\">        System.out.println(&quot;run&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        //使用Runnable对象，创建Thread对象</span><br><span class=\"line\">        new Thread(new RunnableTest()).start();</span><br><span class=\"line\">        System.out.println(&quot;main&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>实现Callable接口，结合FutureTask</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class CallableTest implements Callable&lt;String&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    //实现call方法</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public String call() throws Exception &#123;</span><br><span class=\"line\">        return &quot;call&quot;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        //使用Callable对象，创建FutureTask对象</span><br><span class=\"line\">        FutureTask&lt;String&gt; future = new FutureTask&lt;&gt;(new CallableTest());</span><br><span class=\"line\">        //使用FutureTask对象，创建Thread对象</span><br><span class=\"line\">        new Thread(future).start();</span><br><span class=\"line\">        System.out.println(future.get());</span><br><span class=\"line\">        System.out.println(&quot;main&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"线程的生命周期\"><a href=\"#线程的生命周期\" class=\"headerlink\" title=\"线程的生命周期\"></a>线程的生命周期</h4><p>新建（new），就绪（runable），运行（running），阻塞（blocked），死亡（dead）五个状态。<br><img src=\"https://github.com/echolixiaopeng/blog/raw/master/data/java-thread-life-cycle.png\" alt></p>\n<p><code>new -&gt; runable</code><br>新建的线程调用start方法，进入runable状态。</p>\n<p><code>runable -&gt; running</code><br>就绪的线程，由线程调度器调度，获取到CPU资源后进入running状态。</p>\n<p><code>running -&gt; runable</code><br>运行的线程，失去CPU资源或调用yield方法后，回到runable状态。</p>\n<p><code>running -&gt; blocked</code><br>运行的线程，调用sleep方法后，或调用阻塞IO方法时，或等待同步监视器，或等待notify时，或调用suspend方法后，进入阻塞状态。</p>\n<p><code>blocked -&gt; runable</code><br>sleep过了设定的时间，阻塞的IO方法已返回，已获取同步监视器，已收到notify，已调用resume方法恢复，进去就绪状态。</p>\n<p><code>running -&gt; dead</code><br>方法已经执行完毕，或执行时抛出未捕获的异常，或调用stop方法结束该线程。</p>\n<h4 id=\"线程控制\"><a href=\"#线程控制\" class=\"headerlink\" title=\"线程控制\"></a>线程控制</h4><p><code>thread.join()</code><br>当前线程等待指定线程完成。<br>调用线程将被阻塞，直到join方法加入的线程执行完毕为止。<br>join(long millis)，超过时间后将不再等待该线程。</p>\n<p><code>Thread.sleep()</code><br>当前线程进入阻塞状态。<br>sleep(long millis)，当前线程将阻塞状态，暂停指定时间。<br>即使系统中没有其他可执行的线程，sleep后的线程也不会执行。</p>\n<p><code>Thread.yield()</code><br>当前线程进入就绪状态。<br>多CPU环境下，该操作的效果不明显。</p>\n<p><code>Thread.currentThread.setPriority()</code><br>设置当前线程的优先级。<br>使用JDK常量指定优先级，保证移植性。</p>\n<p><code>thread.setDaemon()</code><br>设置线程为后台线程。<br>设置必须在调用start方法之前。<br>所有的前台线程都死亡，后台线程都会死亡。<br>前台线程默认创建的事前台线程，后台线程亦然。</p>\n<h4 id=\"线程同步\"><a href=\"#线程同步\" class=\"headerlink\" title=\"线程同步\"></a>线程同步</h4><blockquote>\n<p>死锁：两个线程互相等待对方释放同步监视器。</p>\n</blockquote>\n<p><code>同步代码块</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">synchronized(obj)&#123;</span><br><span class=\"line\">//同步的代码</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>逻辑：加锁 -&gt; 修改 -&gt; 释放锁<br>obj是同步监视器。<br>任何时刻只能有一个线程获取同步监视器。<br>线程开始执行同步代码块之前，必须先获得同步监视器。<br>同步代码块执行完成之后，会释放同步监视器。</p>\n<p><code>同步方法</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public synchronized void test()&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>逻辑：加锁 -&gt; 修改 -&gt; 释放锁<br>this是同步监视器。</p>\n<p><code>同步锁</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">reentrantLock.lock();</span><br><span class=\"line\">try&#123;&#125;</span><br><span class=\"line\">finally&#123;</span><br><span class=\"line\">reentrantLock.unlock;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>显式的定义同步锁，显式的加锁，显式的释放锁。<br>只能有一个线程对Lock对象进行加锁。<br>ReentrantLock是Lock的实现。<br>ReentrantLock是重入锁，可对已经加锁的锁再次加锁。</p>\n<h4 id=\"线程通信\"><a href=\"#线程通信\" class=\"headerlink\" title=\"线程通信\"></a>线程通信</h4><p><code>传统的线程通信</code><br>obj.wait()方法：释放同步监视器，当前线程进入Blocked状态，不会再次竞争。<br>obj.notify()方法：唤醒在此同步监视器上的单个线程，选择是随机的。<br>obj.notifyAll()方法：唤醒在此同步监视器上的所有线程。<br>notify后，被唤醒的线程会再次竞争同步监视器。</p>\n<p><code>使用Condition控制</code><br>通过Lock对象的lock.newCondition()获取condition对象。<br>condition.await()相当于obj.wait()。<br>condition.signal()相当于obj.notify()。<br>condition.signalAll()相当于obj.notifyAll()。</p>\n<p><code>使用BlockingQueue</code><br>put时，队列已满，则阻塞该线程。<br>take时，队列已空，则阻塞该线程。</p>\n<h4 id=\"线程池\"><a href=\"#线程池\" class=\"headerlink\" title=\"线程池\"></a>线程池</h4><blockquote>\n<p>线程池适合任务处理时间短，且任务数量大的场景。<br>线程池优点：降低资源消耗，减少线程创建和销毁的消耗。<br>线程池优点：加快响应速度，不用等待线程创建。<br>线程池优点：线程可管理，无限制创建线程会降低系统稳定性，线程池可统一管理。<br>Executors 返回的线程池对象，会引起OOM问题。<br>推荐通过 ThreadPoolExecutor 的方式，创建线程池。</p>\n</blockquote>\n<h5 id=\"ThreadPoolExecutor\"><a href=\"#ThreadPoolExecutor\" class=\"headerlink\" title=\"ThreadPoolExecutor\"></a>ThreadPoolExecutor</h5><ul>\n<li><p><code>构造参数</code><br>corePoolSize：核心线程数量；<br>maximumPoolSize：最大线程数量；<br>workQueue：等待队列；<br>handler：表示线程池的饱和策略；</p>\n</li>\n<li><p><code>方法</code><br>execute()，提交任务。<br>shutdown（），将线程池设置成SHUTDOWN状态，然后中断所有正在执行的任务。<br>shutdownNow（），将线程池的状态设置为STOP，，然后尝试停止所有正在执行或暂停任务的线程，并返回等待执行任务的列表。</p>\n</li>\n</ul>\n<ul>\n<li><p><code>执行过程</code><br>如果workerCount &lt; corePoolSize，则创建并启动一个线程来执行新提交的任务；<br>如果workerCount &gt;= corePoolSize，且线程池内的阻塞队列未满，则将任务添加到该阻塞队列中；<br>如果workerCount &gt;= corePoolSize &amp;&amp; workerCount &lt; maximumPoolSize，且线程池内的阻塞队列已满，则创建并启动一个线程来执行新提交的任务；<br>如果workerCount &gt;= maximumPoolSize，并且线程池内的阻塞队列已满, 则根据拒绝策略来处理该任务, 默认的处理方式是直接抛异常。</p>\n</li>\n<li><p><code>线程池分配</code><br>CPU密集型任务：N+1个线程。<br>IO密集型任务：2N个线程。<br>混合型任务：拆分成一个CPU密集型任务和一个IO密集型任务。</p>\n</li>\n</ul>\n"},{"title":"排错卷宗 - MySQL引发MongoDB查询慢","date":"2018-08-07T16:00:00.000Z","_content":"#### 场景还原\n>`小B`：小A，你X业务的查询还是很慢呀！\n>`小A`：不可能呀，我昨天刚优化过速度，溜溜地！\n>`小B`：不信你自己试一下就知道了。\n>`小A`：我去。。。还真的可慢。\n>`小A`：不对！优化过后的查询效率是没有问题的，肯定是发生了其他的事情。\n>`小A`：其他基于MongoDB的业务查询也变慢了，难道是MongoDB出现了问题？\n>`小A`：啃爹呀！系统资源快被MySQL吃完了，MongoDB能不慢？\n\n#### 问题定位\n`微服务资源隔离`\n微服务之间应该是资源隔离的。每个微服务在不同系统进程，每个微服务应该有自己的数据库。\n\n`SHOW PROCESSLIST`\n显示哪些线程正在运行。\n\n`max_connections`\n当遇到MySQL的连接数不够用时，不可盲目扩大该配置。此举虽然可以暂时结局问题，但可能引起更大的问题，应该以优化减少连接入手。\n\n`MySQL dbuser`\n不同的连接者尽量使用不同的dbuser，方便SHOW PROCESSLIST时，区别连接端。","source":"_posts/排错卷宗 - MySQL引发MongoDB查询慢.md","raw":"---\ntitle: 排错卷宗 - MySQL引发MongoDB查询慢\ncategories:\n- 排错卷宗\ndate: 2018-08-08  \ntags:\n- MongoDB\n---\n#### 场景还原\n>`小B`：小A，你X业务的查询还是很慢呀！\n>`小A`：不可能呀，我昨天刚优化过速度，溜溜地！\n>`小B`：不信你自己试一下就知道了。\n>`小A`：我去。。。还真的可慢。\n>`小A`：不对！优化过后的查询效率是没有问题的，肯定是发生了其他的事情。\n>`小A`：其他基于MongoDB的业务查询也变慢了，难道是MongoDB出现了问题？\n>`小A`：啃爹呀！系统资源快被MySQL吃完了，MongoDB能不慢？\n\n#### 问题定位\n`微服务资源隔离`\n微服务之间应该是资源隔离的。每个微服务在不同系统进程，每个微服务应该有自己的数据库。\n\n`SHOW PROCESSLIST`\n显示哪些线程正在运行。\n\n`max_connections`\n当遇到MySQL的连接数不够用时，不可盲目扩大该配置。此举虽然可以暂时结局问题，但可能引起更大的问题，应该以优化减少连接入手。\n\n`MySQL dbuser`\n不同的连接者尽量使用不同的dbuser，方便SHOW PROCESSLIST时，区别连接端。","slug":"排错卷宗 - MySQL引发MongoDB查询慢","published":1,"updated":"2018-12-25T01:48:09.789Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjwq2jfdl0018qxpjd7l75te2","content":"<h4 id=\"场景还原\"><a href=\"#场景还原\" class=\"headerlink\" title=\"场景还原\"></a>场景还原</h4><blockquote>\n<p><code>小B</code>：小A，你X业务的查询还是很慢呀！<br><code>小A</code>：不可能呀，我昨天刚优化过速度，溜溜地！<br><code>小B</code>：不信你自己试一下就知道了。<br><code>小A</code>：我去。。。还真的可慢。<br><code>小A</code>：不对！优化过后的查询效率是没有问题的，肯定是发生了其他的事情。<br><code>小A</code>：其他基于MongoDB的业务查询也变慢了，难道是MongoDB出现了问题？<br><code>小A</code>：啃爹呀！系统资源快被MySQL吃完了，MongoDB能不慢？</p>\n</blockquote>\n<h4 id=\"问题定位\"><a href=\"#问题定位\" class=\"headerlink\" title=\"问题定位\"></a>问题定位</h4><p><code>微服务资源隔离</code><br>微服务之间应该是资源隔离的。每个微服务在不同系统进程，每个微服务应该有自己的数据库。</p>\n<p><code>SHOW PROCESSLIST</code><br>显示哪些线程正在运行。</p>\n<p><code>max_connections</code><br>当遇到MySQL的连接数不够用时，不可盲目扩大该配置。此举虽然可以暂时结局问题，但可能引起更大的问题，应该以优化减少连接入手。</p>\n<p><code>MySQL dbuser</code><br>不同的连接者尽量使用不同的dbuser，方便SHOW PROCESSLIST时，区别连接端。</p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"场景还原\"><a href=\"#场景还原\" class=\"headerlink\" title=\"场景还原\"></a>场景还原</h4><blockquote>\n<p><code>小B</code>：小A，你X业务的查询还是很慢呀！<br><code>小A</code>：不可能呀，我昨天刚优化过速度，溜溜地！<br><code>小B</code>：不信你自己试一下就知道了。<br><code>小A</code>：我去。。。还真的可慢。<br><code>小A</code>：不对！优化过后的查询效率是没有问题的，肯定是发生了其他的事情。<br><code>小A</code>：其他基于MongoDB的业务查询也变慢了，难道是MongoDB出现了问题？<br><code>小A</code>：啃爹呀！系统资源快被MySQL吃完了，MongoDB能不慢？</p>\n</blockquote>\n<h4 id=\"问题定位\"><a href=\"#问题定位\" class=\"headerlink\" title=\"问题定位\"></a>问题定位</h4><p><code>微服务资源隔离</code><br>微服务之间应该是资源隔离的。每个微服务在不同系统进程，每个微服务应该有自己的数据库。</p>\n<p><code>SHOW PROCESSLIST</code><br>显示哪些线程正在运行。</p>\n<p><code>max_connections</code><br>当遇到MySQL的连接数不够用时，不可盲目扩大该配置。此举虽然可以暂时结局问题，但可能引起更大的问题，应该以优化减少连接入手。</p>\n<p><code>MySQL dbuser</code><br>不同的连接者尽量使用不同的dbuser，方便SHOW PROCESSLIST时，区别连接端。</p>\n"},{"title":"排错卷宗 - POI引发的OOM","date":"2017-10-20T16:00:00.000Z","_content":"#### 场景还原\n>`小A`：该死！service-a又假死了，马上重启一波。\n>`小A`：肯定又有运营导出表格数据了。几万条地导，服务就撑不住了。\n>`小A`：这次一定要在技术角度解决这个问题！\n>`小A`：简单来说，就是POI类库在导出Excel是引发了OOM问题。\n>`小A`：业务导出的数据量大，JVM又不能成功的回收这些POI的对象，该怎么办呐？\n\n#### 问题定位\n`jmap堆栈分析`\n使用jmap工具列出堆内存中所有对象的名称和数目。果然是POI的锅！SXSSFRow，SXSSFCell这几个POI的对象大量占用了堆内存。\n\n`SXSSFWorkbook`\nSXSSFWorkbook提供了OOM的解决方案，会临时写到临时文件中，避免OOM。\n\n","source":"_posts/排错卷宗 - POI引发的OOM.md","raw":"---\ntitle: 排错卷宗 - POI引发的OOM\ncategories:\n- 排错卷宗\ndate: 2017-10-21 \ntags:\n- OOM\n---\n#### 场景还原\n>`小A`：该死！service-a又假死了，马上重启一波。\n>`小A`：肯定又有运营导出表格数据了。几万条地导，服务就撑不住了。\n>`小A`：这次一定要在技术角度解决这个问题！\n>`小A`：简单来说，就是POI类库在导出Excel是引发了OOM问题。\n>`小A`：业务导出的数据量大，JVM又不能成功的回收这些POI的对象，该怎么办呐？\n\n#### 问题定位\n`jmap堆栈分析`\n使用jmap工具列出堆内存中所有对象的名称和数目。果然是POI的锅！SXSSFRow，SXSSFCell这几个POI的对象大量占用了堆内存。\n\n`SXSSFWorkbook`\nSXSSFWorkbook提供了OOM的解决方案，会临时写到临时文件中，避免OOM。\n\n","slug":"排错卷宗 - POI引发的OOM","published":1,"updated":"2018-12-25T01:48:09.022Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjwq2jfdn001cqxpjg1dlpx65","content":"<h4 id=\"场景还原\"><a href=\"#场景还原\" class=\"headerlink\" title=\"场景还原\"></a>场景还原</h4><blockquote>\n<p><code>小A</code>：该死！service-a又假死了，马上重启一波。<br><code>小A</code>：肯定又有运营导出表格数据了。几万条地导，服务就撑不住了。<br><code>小A</code>：这次一定要在技术角度解决这个问题！<br><code>小A</code>：简单来说，就是POI类库在导出Excel是引发了OOM问题。<br><code>小A</code>：业务导出的数据量大，JVM又不能成功的回收这些POI的对象，该怎么办呐？</p>\n</blockquote>\n<h4 id=\"问题定位\"><a href=\"#问题定位\" class=\"headerlink\" title=\"问题定位\"></a>问题定位</h4><p><code>jmap堆栈分析</code><br>使用jmap工具列出堆内存中所有对象的名称和数目。果然是POI的锅！SXSSFRow，SXSSFCell这几个POI的对象大量占用了堆内存。</p>\n<p><code>SXSSFWorkbook</code><br>SXSSFWorkbook提供了OOM的解决方案，会临时写到临时文件中，避免OOM。</p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"场景还原\"><a href=\"#场景还原\" class=\"headerlink\" title=\"场景还原\"></a>场景还原</h4><blockquote>\n<p><code>小A</code>：该死！service-a又假死了，马上重启一波。<br><code>小A</code>：肯定又有运营导出表格数据了。几万条地导，服务就撑不住了。<br><code>小A</code>：这次一定要在技术角度解决这个问题！<br><code>小A</code>：简单来说，就是POI类库在导出Excel是引发了OOM问题。<br><code>小A</code>：业务导出的数据量大，JVM又不能成功的回收这些POI的对象，该怎么办呐？</p>\n</blockquote>\n<h4 id=\"问题定位\"><a href=\"#问题定位\" class=\"headerlink\" title=\"问题定位\"></a>问题定位</h4><p><code>jmap堆栈分析</code><br>使用jmap工具列出堆内存中所有对象的名称和数目。果然是POI的锅！SXSSFRow，SXSSFCell这几个POI的对象大量占用了堆内存。</p>\n<p><code>SXSSFWorkbook</code><br>SXSSFWorkbook提供了OOM的解决方案，会临时写到临时文件中，避免OOM。</p>\n"},{"title":"排错卷宗 - UDP肉机","date":"2018-09-13T16:00:00.000Z","_content":"#### 场景还原\n>您的云服务器（47.x.x.x）由于被检测到对外攻击，已阻断该服务器对其它服务器端口（UDP:ALL）的访问，阻断预计将在时间内结束，请及时进行安全自查。若有疑问，请工单或电话联系阿里云售后，感谢您对阿里云的支持。\n\n#### 问题定位\n`UDP漏洞`\n由于UDP类服务（Memcache,NTP,NTP,SSDP,SNMP）的协议漏洞，该服务器成为UDP反射攻击的肉机，对其他主机进行拒绝服务攻击。本身的主机资源（CPU，内存，外网带宽）也遭受损耗。此主机运行了SNMP和NTP服务，并且对外网开放161端口（SNMP），该情况满足进行UDP反射攻击的条件。","source":"_posts/排错卷宗 - UDP肉机.md","raw":"---\ntitle: 排错卷宗 - UDP肉机\ncategories:\n- 排错卷宗\ndate: 2018-09-14  \ntags:\n- UDP\n---\n#### 场景还原\n>您的云服务器（47.x.x.x）由于被检测到对外攻击，已阻断该服务器对其它服务器端口（UDP:ALL）的访问，阻断预计将在时间内结束，请及时进行安全自查。若有疑问，请工单或电话联系阿里云售后，感谢您对阿里云的支持。\n\n#### 问题定位\n`UDP漏洞`\n由于UDP类服务（Memcache,NTP,NTP,SSDP,SNMP）的协议漏洞，该服务器成为UDP反射攻击的肉机，对其他主机进行拒绝服务攻击。本身的主机资源（CPU，内存，外网带宽）也遭受损耗。此主机运行了SNMP和NTP服务，并且对外网开放161端口（SNMP），该情况满足进行UDP反射攻击的条件。","slug":"排错卷宗 - UDP肉机","published":1,"updated":"2018-12-25T01:48:14.387Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjwq2jfdp001fqxpj7eln946a","content":"<h4 id=\"场景还原\"><a href=\"#场景还原\" class=\"headerlink\" title=\"场景还原\"></a>场景还原</h4><blockquote>\n<p>您的云服务器（47.x.x.x）由于被检测到对外攻击，已阻断该服务器对其它服务器端口（UDP:ALL）的访问，阻断预计将在时间内结束，请及时进行安全自查。若有疑问，请工单或电话联系阿里云售后，感谢您对阿里云的支持。</p>\n</blockquote>\n<h4 id=\"问题定位\"><a href=\"#问题定位\" class=\"headerlink\" title=\"问题定位\"></a>问题定位</h4><p><code>UDP漏洞</code><br>由于UDP类服务（Memcache,NTP,NTP,SSDP,SNMP）的协议漏洞，该服务器成为UDP反射攻击的肉机，对其他主机进行拒绝服务攻击。本身的主机资源（CPU，内存，外网带宽）也遭受损耗。此主机运行了SNMP和NTP服务，并且对外网开放161端口（SNMP），该情况满足进行UDP反射攻击的条件。</p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"场景还原\"><a href=\"#场景还原\" class=\"headerlink\" title=\"场景还原\"></a>场景还原</h4><blockquote>\n<p>您的云服务器（47.x.x.x）由于被检测到对外攻击，已阻断该服务器对其它服务器端口（UDP:ALL）的访问，阻断预计将在时间内结束，请及时进行安全自查。若有疑问，请工单或电话联系阿里云售后，感谢您对阿里云的支持。</p>\n</blockquote>\n<h4 id=\"问题定位\"><a href=\"#问题定位\" class=\"headerlink\" title=\"问题定位\"></a>问题定位</h4><p><code>UDP漏洞</code><br>由于UDP类服务（Memcache,NTP,NTP,SSDP,SNMP）的协议漏洞，该服务器成为UDP反射攻击的肉机，对其他主机进行拒绝服务攻击。本身的主机资源（CPU，内存，外网带宽）也遭受损耗。此主机运行了SNMP和NTP服务，并且对外网开放161端口（SNMP），该情况满足进行UDP反射攻击的条件。</p>\n"},{"title":"排错卷宗 - redis连接timeout","date":"2018-09-24T16:00:00.000Z","_content":"#### 场景还原\n>`小A`：奇怪！生产环境service-a这两天怎么偶尔会报redis的连接timeout错误？\n>`小A`：这个错误出现的频率毫无规律，而且每次只有一两个报错。\n>`小A`：难道是本机到redis服务器的网络有抖动？\n>`小A`：不回呀。内网环境下不应该有这样的抖动。\n>`小A`：咦？其他service会不会也有这样的报错？\n>`小A`：要是其他service也有，岂不是redis端的问题？\n>`小A`：小B，你负责的service-b这几天有没有redis的连接timeout报错？\n>`小B`：小A哥，service-b这几天真有redis的连接timeout报错！你料事如神呀！\n>`小A`：小C，小D，小E，你们都看下，是不是有相同情况？\n>`小C`：有！\n>`小D`：也有！\n>`小E`：+1\n>`小A`：真相永远只有一个！一定是redis端出现了问题！\n\n#### 问题定位\n`慢查询阻塞`\nredis是单线程处理的。一些耗时长的命令会造成阻塞，如keys、sort等命令。应该在生产环境禁用这些危险的命令。\n\n`SLOWLOG命令`\nSLOWLOG GET获取所有慢日志；SLOWLOG GET N获取最近N条慢日志；SLOWLOG LEN获取当前慢日志长度；\n\n`慢查询日志配置`\nslowlog-max-len线上可以设置为1000以上；slowlog-log-lower-than建议设置为1毫秒；","source":"_posts/排错卷宗 - redis连接timeout.md","raw":"---\ntitle: 排错卷宗 - redis连接timeout\ncategories:\n- 排错卷宗\ndate: 2018-09-25 \ntags:\n- redis\n---\n#### 场景还原\n>`小A`：奇怪！生产环境service-a这两天怎么偶尔会报redis的连接timeout错误？\n>`小A`：这个错误出现的频率毫无规律，而且每次只有一两个报错。\n>`小A`：难道是本机到redis服务器的网络有抖动？\n>`小A`：不回呀。内网环境下不应该有这样的抖动。\n>`小A`：咦？其他service会不会也有这样的报错？\n>`小A`：要是其他service也有，岂不是redis端的问题？\n>`小A`：小B，你负责的service-b这几天有没有redis的连接timeout报错？\n>`小B`：小A哥，service-b这几天真有redis的连接timeout报错！你料事如神呀！\n>`小A`：小C，小D，小E，你们都看下，是不是有相同情况？\n>`小C`：有！\n>`小D`：也有！\n>`小E`：+1\n>`小A`：真相永远只有一个！一定是redis端出现了问题！\n\n#### 问题定位\n`慢查询阻塞`\nredis是单线程处理的。一些耗时长的命令会造成阻塞，如keys、sort等命令。应该在生产环境禁用这些危险的命令。\n\n`SLOWLOG命令`\nSLOWLOG GET获取所有慢日志；SLOWLOG GET N获取最近N条慢日志；SLOWLOG LEN获取当前慢日志长度；\n\n`慢查询日志配置`\nslowlog-max-len线上可以设置为1000以上；slowlog-log-lower-than建议设置为1毫秒；","slug":"排错卷宗 - redis连接timeout","published":1,"updated":"2018-12-25T01:48:08.926Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjwq2jfdt001kqxpjj4nfjitr","content":"<h4 id=\"场景还原\"><a href=\"#场景还原\" class=\"headerlink\" title=\"场景还原\"></a>场景还原</h4><blockquote>\n<p><code>小A</code>：奇怪！生产环境service-a这两天怎么偶尔会报redis的连接timeout错误？<br><code>小A</code>：这个错误出现的频率毫无规律，而且每次只有一两个报错。<br><code>小A</code>：难道是本机到redis服务器的网络有抖动？<br><code>小A</code>：不回呀。内网环境下不应该有这样的抖动。<br><code>小A</code>：咦？其他service会不会也有这样的报错？<br><code>小A</code>：要是其他service也有，岂不是redis端的问题？<br><code>小A</code>：小B，你负责的service-b这几天有没有redis的连接timeout报错？<br><code>小B</code>：小A哥，service-b这几天真有redis的连接timeout报错！你料事如神呀！<br><code>小A</code>：小C，小D，小E，你们都看下，是不是有相同情况？<br><code>小C</code>：有！<br><code>小D</code>：也有！<br><code>小E</code>：+1<br><code>小A</code>：真相永远只有一个！一定是redis端出现了问题！</p>\n</blockquote>\n<h4 id=\"问题定位\"><a href=\"#问题定位\" class=\"headerlink\" title=\"问题定位\"></a>问题定位</h4><p><code>慢查询阻塞</code><br>redis是单线程处理的。一些耗时长的命令会造成阻塞，如keys、sort等命令。应该在生产环境禁用这些危险的命令。</p>\n<p><code>SLOWLOG命令</code><br>SLOWLOG GET获取所有慢日志；SLOWLOG GET N获取最近N条慢日志；SLOWLOG LEN获取当前慢日志长度；</p>\n<p><code>慢查询日志配置</code><br>slowlog-max-len线上可以设置为1000以上；slowlog-log-lower-than建议设置为1毫秒；</p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"场景还原\"><a href=\"#场景还原\" class=\"headerlink\" title=\"场景还原\"></a>场景还原</h4><blockquote>\n<p><code>小A</code>：奇怪！生产环境service-a这两天怎么偶尔会报redis的连接timeout错误？<br><code>小A</code>：这个错误出现的频率毫无规律，而且每次只有一两个报错。<br><code>小A</code>：难道是本机到redis服务器的网络有抖动？<br><code>小A</code>：不回呀。内网环境下不应该有这样的抖动。<br><code>小A</code>：咦？其他service会不会也有这样的报错？<br><code>小A</code>：要是其他service也有，岂不是redis端的问题？<br><code>小A</code>：小B，你负责的service-b这几天有没有redis的连接timeout报错？<br><code>小B</code>：小A哥，service-b这几天真有redis的连接timeout报错！你料事如神呀！<br><code>小A</code>：小C，小D，小E，你们都看下，是不是有相同情况？<br><code>小C</code>：有！<br><code>小D</code>：也有！<br><code>小E</code>：+1<br><code>小A</code>：真相永远只有一个！一定是redis端出现了问题！</p>\n</blockquote>\n<h4 id=\"问题定位\"><a href=\"#问题定位\" class=\"headerlink\" title=\"问题定位\"></a>问题定位</h4><p><code>慢查询阻塞</code><br>redis是单线程处理的。一些耗时长的命令会造成阻塞，如keys、sort等命令。应该在生产环境禁用这些危险的命令。</p>\n<p><code>SLOWLOG命令</code><br>SLOWLOG GET获取所有慢日志；SLOWLOG GET N获取最近N条慢日志；SLOWLOG LEN获取当前慢日志长度；</p>\n<p><code>慢查询日志配置</code><br>slowlog-max-len线上可以设置为1000以上；slowlog-log-lower-than建议设置为1毫秒；</p>\n"},{"title":"杂谈MySQL - 优化篇","date":"2018-04-13T16:00:00.000Z","_content":"* `show processlist`\n>显示哪些线程正在运行。\n>id       #ID标识，要kill一个语句的时候很有用\nuse      #当前连接用户\nhost     #显示这个连接从哪个ip的哪个端口上发出\ndb       #数据库名\ncommand  #连接状态，一般是休眠（sleep），查询（query），连接（connect）\ntime     #连接持续时间，单位是秒\nstate    #显示当前sql语句的状态\ninfo     #显示这个sql语句\n\n* `explain`\n>查询SQL的执行计划。\n>possible_keys       #字段上存在的索引\n>key                 #实际决定使用的索引\n>rows              #估算的找到所需的记录所需要读取的行数\n\n* `索引的优化`\n>LIKE查询，%不能在前，否则用不到索引。\n>列类型是字符串，查询时一定要给值加引号，否则索引失效。\n>确保GROUP BY和ORDER BY只有一个表中的列，这样MySQL才有可能使用索引。\n>is null将导致引擎放弃使用索引。\n>使用!=或<>操作符，否则引擎将放弃使用索引。\n>使用or 来连接条件，否则将导致引擎放弃使用索引。\n>in 和 not in ，会导致全表扫描。\n>where子句中对字段进行表达式操作，将导致引擎放弃使用索引。\n>where子句中对字段进行函数操作，将导致引擎放弃使用索引。\n\n* `LIMIT优化`\n>LIMIT偏移量大的时候，查询效率较低。\n可以记录上次查询的最大ID，下次查询时直接根据该ID来查询。\n\n* `随机查询优化`\n```\nSELECT * FROM users \nWHERE \nid >= \n((SELECT MAX(id) FROM users)-(SELECT MIN(id) FROM users)) \n* \nRAND() + (SELECT MIN(id) FROM users)\nLIMIT 10\n```\n\n* `count优化`\n>COUNT(1)和COUNT(\\*)性能相似\n>count(列名)性能差\n\n* `分区表`\n>分区表是一个独立的逻辑表，但是底层MySQL将其分成了多个物理子表。\n>执行查询时，优化器会根据分区定义，只需要查询数据所在分区。\n>所有分区都必须使用相同的存储引擎。\n>一个表最多只能有1024个分区。\n\n* `主从复制`\n>主库上把二进制日志，复制到从库，从库重放日志。\n>降低单个服务器的压力。\n>避免单点失败。\n\n\n\n","source":"_posts/杂谈MySQL - 优化篇.md","raw":"---\ntitle: 杂谈MySQL - 优化篇\ncategories:\n- 数据库\ndate: 2018-04-14 \ntags:\n- MySQL\n---\n* `show processlist`\n>显示哪些线程正在运行。\n>id       #ID标识，要kill一个语句的时候很有用\nuse      #当前连接用户\nhost     #显示这个连接从哪个ip的哪个端口上发出\ndb       #数据库名\ncommand  #连接状态，一般是休眠（sleep），查询（query），连接（connect）\ntime     #连接持续时间，单位是秒\nstate    #显示当前sql语句的状态\ninfo     #显示这个sql语句\n\n* `explain`\n>查询SQL的执行计划。\n>possible_keys       #字段上存在的索引\n>key                 #实际决定使用的索引\n>rows              #估算的找到所需的记录所需要读取的行数\n\n* `索引的优化`\n>LIKE查询，%不能在前，否则用不到索引。\n>列类型是字符串，查询时一定要给值加引号，否则索引失效。\n>确保GROUP BY和ORDER BY只有一个表中的列，这样MySQL才有可能使用索引。\n>is null将导致引擎放弃使用索引。\n>使用!=或<>操作符，否则引擎将放弃使用索引。\n>使用or 来连接条件，否则将导致引擎放弃使用索引。\n>in 和 not in ，会导致全表扫描。\n>where子句中对字段进行表达式操作，将导致引擎放弃使用索引。\n>where子句中对字段进行函数操作，将导致引擎放弃使用索引。\n\n* `LIMIT优化`\n>LIMIT偏移量大的时候，查询效率较低。\n可以记录上次查询的最大ID，下次查询时直接根据该ID来查询。\n\n* `随机查询优化`\n```\nSELECT * FROM users \nWHERE \nid >= \n((SELECT MAX(id) FROM users)-(SELECT MIN(id) FROM users)) \n* \nRAND() + (SELECT MIN(id) FROM users)\nLIMIT 10\n```\n\n* `count优化`\n>COUNT(1)和COUNT(\\*)性能相似\n>count(列名)性能差\n\n* `分区表`\n>分区表是一个独立的逻辑表，但是底层MySQL将其分成了多个物理子表。\n>执行查询时，优化器会根据分区定义，只需要查询数据所在分区。\n>所有分区都必须使用相同的存储引擎。\n>一个表最多只能有1024个分区。\n\n* `主从复制`\n>主库上把二进制日志，复制到从库，从库重放日志。\n>降低单个服务器的压力。\n>避免单点失败。\n\n\n\n","slug":"杂谈MySQL - 优化篇","published":1,"updated":"2018-12-25T01:48:14.209Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjwq2jfdv001nqxpj9d5k4uaa","content":"<ul>\n<li><p><code>show processlist</code></p>\n<blockquote>\n<p>显示哪些线程正在运行。<br>id       #ID标识，要kill一个语句的时候很有用<br>use      #当前连接用户<br>host     #显示这个连接从哪个ip的哪个端口上发出<br>db       #数据库名<br>command  #连接状态，一般是休眠（sleep），查询（query），连接（connect）<br>time     #连接持续时间，单位是秒<br>state    #显示当前sql语句的状态<br>info     #显示这个sql语句</p>\n</blockquote>\n</li>\n<li><p><code>explain</code></p>\n<blockquote>\n<p>查询SQL的执行计划。<br>possible_keys       #字段上存在的索引<br>key                 #实际决定使用的索引<br>rows              #估算的找到所需的记录所需要读取的行数</p>\n</blockquote>\n</li>\n<li><p><code>索引的优化</code></p>\n<blockquote>\n<p>LIKE查询，%不能在前，否则用不到索引。<br>列类型是字符串，查询时一定要给值加引号，否则索引失效。<br>确保GROUP BY和ORDER BY只有一个表中的列，这样MySQL才有可能使用索引。<br>is null将导致引擎放弃使用索引。<br>使用!=或&lt;&gt;操作符，否则引擎将放弃使用索引。<br>使用or 来连接条件，否则将导致引擎放弃使用索引。<br>in 和 not in ，会导致全表扫描。<br>where子句中对字段进行表达式操作，将导致引擎放弃使用索引。<br>where子句中对字段进行函数操作，将导致引擎放弃使用索引。</p>\n</blockquote>\n</li>\n<li><p><code>LIMIT优化</code></p>\n<blockquote>\n<p>LIMIT偏移量大的时候，查询效率较低。<br>可以记录上次查询的最大ID，下次查询时直接根据该ID来查询。</p>\n</blockquote>\n</li>\n<li><p><code>随机查询优化</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT * FROM users </span><br><span class=\"line\">WHERE </span><br><span class=\"line\">id &gt;= </span><br><span class=\"line\">((SELECT MAX(id) FROM users)-(SELECT MIN(id) FROM users)) </span><br><span class=\"line\">* </span><br><span class=\"line\">RAND() + (SELECT MIN(id) FROM users)</span><br><span class=\"line\">LIMIT 10</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><code>count优化</code></p>\n<blockquote>\n<p>COUNT(1)和COUNT(*)性能相似<br>count(列名)性能差</p>\n</blockquote>\n</li>\n<li><p><code>分区表</code></p>\n<blockquote>\n<p>分区表是一个独立的逻辑表，但是底层MySQL将其分成了多个物理子表。<br>执行查询时，优化器会根据分区定义，只需要查询数据所在分区。<br>所有分区都必须使用相同的存储引擎。<br>一个表最多只能有1024个分区。</p>\n</blockquote>\n</li>\n<li><p><code>主从复制</code></p>\n<blockquote>\n<p>主库上把二进制日志，复制到从库，从库重放日志。<br>降低单个服务器的压力。<br>避免单点失败。</p>\n</blockquote>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<ul>\n<li><p><code>show processlist</code></p>\n<blockquote>\n<p>显示哪些线程正在运行。<br>id       #ID标识，要kill一个语句的时候很有用<br>use      #当前连接用户<br>host     #显示这个连接从哪个ip的哪个端口上发出<br>db       #数据库名<br>command  #连接状态，一般是休眠（sleep），查询（query），连接（connect）<br>time     #连接持续时间，单位是秒<br>state    #显示当前sql语句的状态<br>info     #显示这个sql语句</p>\n</blockquote>\n</li>\n<li><p><code>explain</code></p>\n<blockquote>\n<p>查询SQL的执行计划。<br>possible_keys       #字段上存在的索引<br>key                 #实际决定使用的索引<br>rows              #估算的找到所需的记录所需要读取的行数</p>\n</blockquote>\n</li>\n<li><p><code>索引的优化</code></p>\n<blockquote>\n<p>LIKE查询，%不能在前，否则用不到索引。<br>列类型是字符串，查询时一定要给值加引号，否则索引失效。<br>确保GROUP BY和ORDER BY只有一个表中的列，这样MySQL才有可能使用索引。<br>is null将导致引擎放弃使用索引。<br>使用!=或&lt;&gt;操作符，否则引擎将放弃使用索引。<br>使用or 来连接条件，否则将导致引擎放弃使用索引。<br>in 和 not in ，会导致全表扫描。<br>where子句中对字段进行表达式操作，将导致引擎放弃使用索引。<br>where子句中对字段进行函数操作，将导致引擎放弃使用索引。</p>\n</blockquote>\n</li>\n<li><p><code>LIMIT优化</code></p>\n<blockquote>\n<p>LIMIT偏移量大的时候，查询效率较低。<br>可以记录上次查询的最大ID，下次查询时直接根据该ID来查询。</p>\n</blockquote>\n</li>\n<li><p><code>随机查询优化</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT * FROM users </span><br><span class=\"line\">WHERE </span><br><span class=\"line\">id &gt;= </span><br><span class=\"line\">((SELECT MAX(id) FROM users)-(SELECT MIN(id) FROM users)) </span><br><span class=\"line\">* </span><br><span class=\"line\">RAND() + (SELECT MIN(id) FROM users)</span><br><span class=\"line\">LIMIT 10</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><code>count优化</code></p>\n<blockquote>\n<p>COUNT(1)和COUNT(*)性能相似<br>count(列名)性能差</p>\n</blockquote>\n</li>\n<li><p><code>分区表</code></p>\n<blockquote>\n<p>分区表是一个独立的逻辑表，但是底层MySQL将其分成了多个物理子表。<br>执行查询时，优化器会根据分区定义，只需要查询数据所在分区。<br>所有分区都必须使用相同的存储引擎。<br>一个表最多只能有1024个分区。</p>\n</blockquote>\n</li>\n<li><p><code>主从复制</code></p>\n<blockquote>\n<p>主库上把二进制日志，复制到从库，从库重放日志。<br>降低单个服务器的压力。<br>避免单点失败。</p>\n</blockquote>\n</li>\n</ul>\n"},{"title":"杂谈MySQL - 基础篇","date":"2017-08-11T16:00:00.000Z","_content":"* `CHAR 与 VARCHAR`\n>CHAR以固定长度的分配存储空间。\nVARCHAR根据实际存储的数据来分配最终的存储空间。\nVARCHAR类型的实际长度是它的值的实际长度+1。\nCHAR(M)定义的列的长度为固定的，M取值可以为0～255之间。\nVARCHAR(M)定义的列的长度为可变长字符串，M取值可以为0~65535之间。\nCHAR当字符位数不足时，系统并不会采用空格来填充。\nCHAR和VARCHAR存储的内容超出设置的长度时，内容会被截断。\nVARCHAR(50)和(200)存储hello所占空间一样，但后者在排序时会消耗更多内存。\n\n* `TRUNCATE 与 DELETE`\n>DELETE命令删除的数据将存储在系统回滚段中，需要的时候，数据可以回滚恢复。\nTRUNCATE命令删除的数据是不可以恢复的。\nTRUNCATE TABLE是非常快的。\nTRUNCATE之后的自增字段从头开始计数了，而DELETE的仍保留原来的最大数值。\n\n* `float double 与 decimal`\n>float，double非标准类型，在DB中保存的是近似值。\n>Decimal则以字符串的形式保存数值。\n>小数类型为 decimal，禁止使用 float 和 double。\n>存储商品价格可以使用分作为单位，存储整数。\n\n* `InnoDB 与 MyISAM`\n>InnoDB支持事务，MyISAM不支持；\nInnoDB数据存储在共享表空间，MyISAM数据存储在文件中；\nInnoDB支持行级锁，MyISAM只支持表锁；\nInnoDB支持崩溃后的恢复，MyISAM不支持；\nInnoDB支持外键，MyISAM不支持；\nInnoDB不支持全文索引，MyISAM支持全文索引；\n\n* `共享锁(读锁) 与 排他锁(写锁)`\n>共享锁又称读锁（在查询语句后面增加LOCK IN SHARE MODE），是读取操作创建的锁。其他用户可以并发读取数据，但任何事务都不能对数据进行修改（获取数据上的排他锁），直到已释放所有共享锁。\n>排他锁又称写锁（在查询语句后面增加FOR UPDATE），如果事务T对数据A加上排他锁后，则其他事务不能再对A加任任何类型的封锁。获准排他锁的事务既能读数据，又能修改数据。\n\n* `表锁 与 行锁`\n>行锁的劣势：开销大，加锁慢，会出现死锁。\n>行锁的优势：锁的粒度小，发生锁冲突的概率低，处理并发的能力强。\n>表锁的优势：开销小；加锁快；无死锁 \n>表锁的劣势：锁粒度大，发生锁冲突的概率高，并发处理能力低。\n\n* `索引的类型`\n>普通索引：最基本的索引，没有任何约束限制。\n唯一索引：和普通索引类似，但是具有唯一性约束。\n主键索引：特殊的唯一索引，不允许有空值。\n\n* `索引的创建原则`\n>创建索引的列是出现在WHERE或ON子句中的列。\n>索引列的基数越大，数据区分度越高，索引的效果越好。\n>对于字符串进行索引，应该制定一个前缀长度，可以节省大量的索引空间。\n>避免创建过多的索引，索引会额外占用磁盘空间，降低写操作效率。\n\n* `索引的前缀原则`\n```\nKEY(a,b,c)\nWHERE a = 1 AND b = 2 AND c = 3\nWHERE a = 1 AND b = 2\nWHERE a = 1\n#以上SQL语句可以用到索引\nWHERE b = 2 AND c = 3\nWHERE a = 1 AND c = 3\n#以上SQL语句用不到索引\n```\n* `关联查询`\n>内连接（INNER JOIN），外连接（LEFT/RIGHT JOIN）\n>INNER JOIN可以缩写为JOIN\n\n* `联合查询`\n>UNION与UNION ALL\n>UNION ALL，不会合并重复的记录行\n>UNION 效率高于 UNION ALL\n\n\n\n\n\n","source":"_posts/杂谈MySQL - 基础篇.md","raw":"---\ntitle: 杂谈MySQL - 基础篇\ncategories:\n- 数据库\ndate: 2017-08-12 \ntags:\n- MySQL\n---\n* `CHAR 与 VARCHAR`\n>CHAR以固定长度的分配存储空间。\nVARCHAR根据实际存储的数据来分配最终的存储空间。\nVARCHAR类型的实际长度是它的值的实际长度+1。\nCHAR(M)定义的列的长度为固定的，M取值可以为0～255之间。\nVARCHAR(M)定义的列的长度为可变长字符串，M取值可以为0~65535之间。\nCHAR当字符位数不足时，系统并不会采用空格来填充。\nCHAR和VARCHAR存储的内容超出设置的长度时，内容会被截断。\nVARCHAR(50)和(200)存储hello所占空间一样，但后者在排序时会消耗更多内存。\n\n* `TRUNCATE 与 DELETE`\n>DELETE命令删除的数据将存储在系统回滚段中，需要的时候，数据可以回滚恢复。\nTRUNCATE命令删除的数据是不可以恢复的。\nTRUNCATE TABLE是非常快的。\nTRUNCATE之后的自增字段从头开始计数了，而DELETE的仍保留原来的最大数值。\n\n* `float double 与 decimal`\n>float，double非标准类型，在DB中保存的是近似值。\n>Decimal则以字符串的形式保存数值。\n>小数类型为 decimal，禁止使用 float 和 double。\n>存储商品价格可以使用分作为单位，存储整数。\n\n* `InnoDB 与 MyISAM`\n>InnoDB支持事务，MyISAM不支持；\nInnoDB数据存储在共享表空间，MyISAM数据存储在文件中；\nInnoDB支持行级锁，MyISAM只支持表锁；\nInnoDB支持崩溃后的恢复，MyISAM不支持；\nInnoDB支持外键，MyISAM不支持；\nInnoDB不支持全文索引，MyISAM支持全文索引；\n\n* `共享锁(读锁) 与 排他锁(写锁)`\n>共享锁又称读锁（在查询语句后面增加LOCK IN SHARE MODE），是读取操作创建的锁。其他用户可以并发读取数据，但任何事务都不能对数据进行修改（获取数据上的排他锁），直到已释放所有共享锁。\n>排他锁又称写锁（在查询语句后面增加FOR UPDATE），如果事务T对数据A加上排他锁后，则其他事务不能再对A加任任何类型的封锁。获准排他锁的事务既能读数据，又能修改数据。\n\n* `表锁 与 行锁`\n>行锁的劣势：开销大，加锁慢，会出现死锁。\n>行锁的优势：锁的粒度小，发生锁冲突的概率低，处理并发的能力强。\n>表锁的优势：开销小；加锁快；无死锁 \n>表锁的劣势：锁粒度大，发生锁冲突的概率高，并发处理能力低。\n\n* `索引的类型`\n>普通索引：最基本的索引，没有任何约束限制。\n唯一索引：和普通索引类似，但是具有唯一性约束。\n主键索引：特殊的唯一索引，不允许有空值。\n\n* `索引的创建原则`\n>创建索引的列是出现在WHERE或ON子句中的列。\n>索引列的基数越大，数据区分度越高，索引的效果越好。\n>对于字符串进行索引，应该制定一个前缀长度，可以节省大量的索引空间。\n>避免创建过多的索引，索引会额外占用磁盘空间，降低写操作效率。\n\n* `索引的前缀原则`\n```\nKEY(a,b,c)\nWHERE a = 1 AND b = 2 AND c = 3\nWHERE a = 1 AND b = 2\nWHERE a = 1\n#以上SQL语句可以用到索引\nWHERE b = 2 AND c = 3\nWHERE a = 1 AND c = 3\n#以上SQL语句用不到索引\n```\n* `关联查询`\n>内连接（INNER JOIN），外连接（LEFT/RIGHT JOIN）\n>INNER JOIN可以缩写为JOIN\n\n* `联合查询`\n>UNION与UNION ALL\n>UNION ALL，不会合并重复的记录行\n>UNION 效率高于 UNION ALL\n\n\n\n\n\n","slug":"杂谈MySQL - 基础篇","published":1,"updated":"2018-12-25T01:48:14.251Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjwq2jfdx001rqxpjso0iahu3","content":"<ul>\n<li><p><code>CHAR 与 VARCHAR</code></p>\n<blockquote>\n<p>CHAR以固定长度的分配存储空间。<br>VARCHAR根据实际存储的数据来分配最终的存储空间。<br>VARCHAR类型的实际长度是它的值的实际长度+1。<br>CHAR(M)定义的列的长度为固定的，M取值可以为0～255之间。<br>VARCHAR(M)定义的列的长度为可变长字符串，M取值可以为0~65535之间。<br>CHAR当字符位数不足时，系统并不会采用空格来填充。<br>CHAR和VARCHAR存储的内容超出设置的长度时，内容会被截断。<br>VARCHAR(50)和(200)存储hello所占空间一样，但后者在排序时会消耗更多内存。</p>\n</blockquote>\n</li>\n<li><p><code>TRUNCATE 与 DELETE</code></p>\n<blockquote>\n<p>DELETE命令删除的数据将存储在系统回滚段中，需要的时候，数据可以回滚恢复。<br>TRUNCATE命令删除的数据是不可以恢复的。<br>TRUNCATE TABLE是非常快的。<br>TRUNCATE之后的自增字段从头开始计数了，而DELETE的仍保留原来的最大数值。</p>\n</blockquote>\n</li>\n<li><p><code>float double 与 decimal</code></p>\n<blockquote>\n<p>float，double非标准类型，在DB中保存的是近似值。<br>Decimal则以字符串的形式保存数值。<br>小数类型为 decimal，禁止使用 float 和 double。<br>存储商品价格可以使用分作为单位，存储整数。</p>\n</blockquote>\n</li>\n<li><p><code>InnoDB 与 MyISAM</code></p>\n<blockquote>\n<p>InnoDB支持事务，MyISAM不支持；<br>InnoDB数据存储在共享表空间，MyISAM数据存储在文件中；<br>InnoDB支持行级锁，MyISAM只支持表锁；<br>InnoDB支持崩溃后的恢复，MyISAM不支持；<br>InnoDB支持外键，MyISAM不支持；<br>InnoDB不支持全文索引，MyISAM支持全文索引；</p>\n</blockquote>\n</li>\n<li><p><code>共享锁(读锁) 与 排他锁(写锁)</code></p>\n<blockquote>\n<p>共享锁又称读锁（在查询语句后面增加LOCK IN SHARE MODE），是读取操作创建的锁。其他用户可以并发读取数据，但任何事务都不能对数据进行修改（获取数据上的排他锁），直到已释放所有共享锁。<br>排他锁又称写锁（在查询语句后面增加FOR UPDATE），如果事务T对数据A加上排他锁后，则其他事务不能再对A加任任何类型的封锁。获准排他锁的事务既能读数据，又能修改数据。</p>\n</blockquote>\n</li>\n<li><p><code>表锁 与 行锁</code></p>\n<blockquote>\n<p>行锁的劣势：开销大，加锁慢，会出现死锁。<br>行锁的优势：锁的粒度小，发生锁冲突的概率低，处理并发的能力强。<br>表锁的优势：开销小；加锁快；无死锁<br>表锁的劣势：锁粒度大，发生锁冲突的概率高，并发处理能力低。</p>\n</blockquote>\n</li>\n<li><p><code>索引的类型</code></p>\n<blockquote>\n<p>普通索引：最基本的索引，没有任何约束限制。<br>唯一索引：和普通索引类似，但是具有唯一性约束。<br>主键索引：特殊的唯一索引，不允许有空值。</p>\n</blockquote>\n</li>\n<li><p><code>索引的创建原则</code></p>\n<blockquote>\n<p>创建索引的列是出现在WHERE或ON子句中的列。<br>索引列的基数越大，数据区分度越高，索引的效果越好。<br>对于字符串进行索引，应该制定一个前缀长度，可以节省大量的索引空间。<br>避免创建过多的索引，索引会额外占用磁盘空间，降低写操作效率。</p>\n</blockquote>\n</li>\n<li><p><code>索引的前缀原则</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">KEY(a,b,c)</span><br><span class=\"line\">WHERE a = 1 AND b = 2 AND c = 3</span><br><span class=\"line\">WHERE a = 1 AND b = 2</span><br><span class=\"line\">WHERE a = 1</span><br><span class=\"line\">#以上SQL语句可以用到索引</span><br><span class=\"line\">WHERE b = 2 AND c = 3</span><br><span class=\"line\">WHERE a = 1 AND c = 3</span><br><span class=\"line\">#以上SQL语句用不到索引</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><code>关联查询</code></p>\n<blockquote>\n<p>内连接（INNER JOIN），外连接（LEFT/RIGHT JOIN）<br>INNER JOIN可以缩写为JOIN</p>\n</blockquote>\n</li>\n<li><p><code>联合查询</code></p>\n<blockquote>\n<p>UNION与UNION ALL<br>UNION ALL，不会合并重复的记录行<br>UNION 效率高于 UNION ALL</p>\n</blockquote>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<ul>\n<li><p><code>CHAR 与 VARCHAR</code></p>\n<blockquote>\n<p>CHAR以固定长度的分配存储空间。<br>VARCHAR根据实际存储的数据来分配最终的存储空间。<br>VARCHAR类型的实际长度是它的值的实际长度+1。<br>CHAR(M)定义的列的长度为固定的，M取值可以为0～255之间。<br>VARCHAR(M)定义的列的长度为可变长字符串，M取值可以为0~65535之间。<br>CHAR当字符位数不足时，系统并不会采用空格来填充。<br>CHAR和VARCHAR存储的内容超出设置的长度时，内容会被截断。<br>VARCHAR(50)和(200)存储hello所占空间一样，但后者在排序时会消耗更多内存。</p>\n</blockquote>\n</li>\n<li><p><code>TRUNCATE 与 DELETE</code></p>\n<blockquote>\n<p>DELETE命令删除的数据将存储在系统回滚段中，需要的时候，数据可以回滚恢复。<br>TRUNCATE命令删除的数据是不可以恢复的。<br>TRUNCATE TABLE是非常快的。<br>TRUNCATE之后的自增字段从头开始计数了，而DELETE的仍保留原来的最大数值。</p>\n</blockquote>\n</li>\n<li><p><code>float double 与 decimal</code></p>\n<blockquote>\n<p>float，double非标准类型，在DB中保存的是近似值。<br>Decimal则以字符串的形式保存数值。<br>小数类型为 decimal，禁止使用 float 和 double。<br>存储商品价格可以使用分作为单位，存储整数。</p>\n</blockquote>\n</li>\n<li><p><code>InnoDB 与 MyISAM</code></p>\n<blockquote>\n<p>InnoDB支持事务，MyISAM不支持；<br>InnoDB数据存储在共享表空间，MyISAM数据存储在文件中；<br>InnoDB支持行级锁，MyISAM只支持表锁；<br>InnoDB支持崩溃后的恢复，MyISAM不支持；<br>InnoDB支持外键，MyISAM不支持；<br>InnoDB不支持全文索引，MyISAM支持全文索引；</p>\n</blockquote>\n</li>\n<li><p><code>共享锁(读锁) 与 排他锁(写锁)</code></p>\n<blockquote>\n<p>共享锁又称读锁（在查询语句后面增加LOCK IN SHARE MODE），是读取操作创建的锁。其他用户可以并发读取数据，但任何事务都不能对数据进行修改（获取数据上的排他锁），直到已释放所有共享锁。<br>排他锁又称写锁（在查询语句后面增加FOR UPDATE），如果事务T对数据A加上排他锁后，则其他事务不能再对A加任任何类型的封锁。获准排他锁的事务既能读数据，又能修改数据。</p>\n</blockquote>\n</li>\n<li><p><code>表锁 与 行锁</code></p>\n<blockquote>\n<p>行锁的劣势：开销大，加锁慢，会出现死锁。<br>行锁的优势：锁的粒度小，发生锁冲突的概率低，处理并发的能力强。<br>表锁的优势：开销小；加锁快；无死锁<br>表锁的劣势：锁粒度大，发生锁冲突的概率高，并发处理能力低。</p>\n</blockquote>\n</li>\n<li><p><code>索引的类型</code></p>\n<blockquote>\n<p>普通索引：最基本的索引，没有任何约束限制。<br>唯一索引：和普通索引类似，但是具有唯一性约束。<br>主键索引：特殊的唯一索引，不允许有空值。</p>\n</blockquote>\n</li>\n<li><p><code>索引的创建原则</code></p>\n<blockquote>\n<p>创建索引的列是出现在WHERE或ON子句中的列。<br>索引列的基数越大，数据区分度越高，索引的效果越好。<br>对于字符串进行索引，应该制定一个前缀长度，可以节省大量的索引空间。<br>避免创建过多的索引，索引会额外占用磁盘空间，降低写操作效率。</p>\n</blockquote>\n</li>\n<li><p><code>索引的前缀原则</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">KEY(a,b,c)</span><br><span class=\"line\">WHERE a = 1 AND b = 2 AND c = 3</span><br><span class=\"line\">WHERE a = 1 AND b = 2</span><br><span class=\"line\">WHERE a = 1</span><br><span class=\"line\">#以上SQL语句可以用到索引</span><br><span class=\"line\">WHERE b = 2 AND c = 3</span><br><span class=\"line\">WHERE a = 1 AND c = 3</span><br><span class=\"line\">#以上SQL语句用不到索引</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><code>关联查询</code></p>\n<blockquote>\n<p>内连接（INNER JOIN），外连接（LEFT/RIGHT JOIN）<br>INNER JOIN可以缩写为JOIN</p>\n</blockquote>\n</li>\n<li><p><code>联合查询</code></p>\n<blockquote>\n<p>UNION与UNION ALL<br>UNION ALL，不会合并重复的记录行<br>UNION 效率高于 UNION ALL</p>\n</blockquote>\n</li>\n</ul>\n"},{"title":"杂谈Spring Framework","date":"2018-07-11T16:00:00.000Z","_content":"* `Bean的生命周期`\n>实例化bean对象\n>注入对象的属性\n>调用BeanNameAware.setBeanName()\n>调用BeanFactoryAware.setBeanFactory()\n>调用ApplicationContextAware.setApplicationContext()\n>调用BeanPostProcessor.postProcessBeforeInitialzation()\n>调用InitializingBean.afterPropertiesSet()\n>执行init-method\n>调用BeanPostProcessor.postProcessAfterInitialization()\n>使用该Bean\n>调用DisposableBean.destroy()\n>执行destroy-method方法\n\n* `Bean的作用域`\n>singleton，容器在启动时,自动实例化一个实例。\n>prototype，对bean请求的时，创建一个新的的实例。\n>request，对一次的http的请求，创建一个全新的bean实例。\n>session，对某个http seeision 同生通灭。\n>globalSession，对应全局Session的生命周期范围内。\n\n\n* `Spring MVC的工作原理`\n>客户端请求统一到达DispatcherServlet。\n>根据HandlerMapping获取对应的Handler。\n>Handler完成请求后，返回ModelAndView对象给DispatcherServlet。\n>根据ViewResolver完成视图解析\n>DispatcherServlet会利用视图对象对模型数据进行渲染。\n\n* `BeanFactory 与 ApplicationContexts`\n>ApplicationContext继承BeanFactory\n>ApplicationContexts提供了更高级的功能。\n>BeanFactory在启动时不加载实例，后者反之。\n\n* `事务管理`\n>事务四特性(ACID)：原子性，一致性，隔离性，持久性\n>编程式事务管理：灵活性，但是难维护。\n>声明式事务管理：业务代码和事务管理分离。\n\n* `隔离级别`\n>READ_UNCOMMITTED：允许读取尚未提交的更改。\n>READ_COMMITTED：允许从已经提交的并发事务读取。\n>REPEATABLE_READ：对相同字段的多次读取的结果是一致的。\n>SERIALIZABLE：确保不发生脏读、不可重复读和幻影读。\n\n* `传播行为`\n>REQUIRED 如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。\nREQUIRES_NEW 创建一个新的事务，如果当前存在事务，则把当前事务挂起。\nSUPPORTS 如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。\nNOT_SUPPORTED 以非事务方式运行，如果当前存在事务，则把当前事务挂起。\nNEVER 以非事务方式运行，如果当前存在事务，则抛出异常。\nMANDATORY 如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。\nNESTED 如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于TransactionDefinition.PROPAGATION_REQUIRED。\n\n* `工具类中注入bean`\n>加上@component和@PostConstruct注解。\n>@PostConstruct服务器启动时的做一些初始化工作。\n\n* `AOP的代理实现`\n>动态代理，基于JDK动态代理或CGLIB动态代理，jdk动态代理必须是目标类基于接口。\n静态代理，编译时进行织入，AspectJ\n\n* `BeanPostProcessor`\n> 在Spring容器中完成bean实例化、配置以及其他初始化方法前后要添加一些自己逻辑处理。\n> @Value的实现逻辑依赖于此。\n","source":"_posts/杂谈Spring Framework.md","raw":"---\ntitle: 杂谈Spring Framework\ncategories:\n- 开源框架\ndate: 2018-07-12 \ntags:\n- Spring\n---\n* `Bean的生命周期`\n>实例化bean对象\n>注入对象的属性\n>调用BeanNameAware.setBeanName()\n>调用BeanFactoryAware.setBeanFactory()\n>调用ApplicationContextAware.setApplicationContext()\n>调用BeanPostProcessor.postProcessBeforeInitialzation()\n>调用InitializingBean.afterPropertiesSet()\n>执行init-method\n>调用BeanPostProcessor.postProcessAfterInitialization()\n>使用该Bean\n>调用DisposableBean.destroy()\n>执行destroy-method方法\n\n* `Bean的作用域`\n>singleton，容器在启动时,自动实例化一个实例。\n>prototype，对bean请求的时，创建一个新的的实例。\n>request，对一次的http的请求，创建一个全新的bean实例。\n>session，对某个http seeision 同生通灭。\n>globalSession，对应全局Session的生命周期范围内。\n\n\n* `Spring MVC的工作原理`\n>客户端请求统一到达DispatcherServlet。\n>根据HandlerMapping获取对应的Handler。\n>Handler完成请求后，返回ModelAndView对象给DispatcherServlet。\n>根据ViewResolver完成视图解析\n>DispatcherServlet会利用视图对象对模型数据进行渲染。\n\n* `BeanFactory 与 ApplicationContexts`\n>ApplicationContext继承BeanFactory\n>ApplicationContexts提供了更高级的功能。\n>BeanFactory在启动时不加载实例，后者反之。\n\n* `事务管理`\n>事务四特性(ACID)：原子性，一致性，隔离性，持久性\n>编程式事务管理：灵活性，但是难维护。\n>声明式事务管理：业务代码和事务管理分离。\n\n* `隔离级别`\n>READ_UNCOMMITTED：允许读取尚未提交的更改。\n>READ_COMMITTED：允许从已经提交的并发事务读取。\n>REPEATABLE_READ：对相同字段的多次读取的结果是一致的。\n>SERIALIZABLE：确保不发生脏读、不可重复读和幻影读。\n\n* `传播行为`\n>REQUIRED 如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。\nREQUIRES_NEW 创建一个新的事务，如果当前存在事务，则把当前事务挂起。\nSUPPORTS 如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。\nNOT_SUPPORTED 以非事务方式运行，如果当前存在事务，则把当前事务挂起。\nNEVER 以非事务方式运行，如果当前存在事务，则抛出异常。\nMANDATORY 如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。\nNESTED 如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于TransactionDefinition.PROPAGATION_REQUIRED。\n\n* `工具类中注入bean`\n>加上@component和@PostConstruct注解。\n>@PostConstruct服务器启动时的做一些初始化工作。\n\n* `AOP的代理实现`\n>动态代理，基于JDK动态代理或CGLIB动态代理，jdk动态代理必须是目标类基于接口。\n静态代理，编译时进行织入，AspectJ\n\n* `BeanPostProcessor`\n> 在Spring容器中完成bean实例化、配置以及其他初始化方法前后要添加一些自己逻辑处理。\n> @Value的实现逻辑依赖于此。\n","slug":"杂谈Spring Framework","published":1,"updated":"2018-12-25T01:48:14.790Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjwq2jfdz001uqxpj6432y980","content":"<ul>\n<li><p><code>Bean的生命周期</code></p>\n<blockquote>\n<p>实例化bean对象<br>注入对象的属性<br>调用BeanNameAware.setBeanName()<br>调用BeanFactoryAware.setBeanFactory()<br>调用ApplicationContextAware.setApplicationContext()<br>调用BeanPostProcessor.postProcessBeforeInitialzation()<br>调用InitializingBean.afterPropertiesSet()<br>执行init-method<br>调用BeanPostProcessor.postProcessAfterInitialization()<br>使用该Bean<br>调用DisposableBean.destroy()<br>执行destroy-method方法</p>\n</blockquote>\n</li>\n<li><p><code>Bean的作用域</code></p>\n<blockquote>\n<p>singleton，容器在启动时,自动实例化一个实例。<br>prototype，对bean请求的时，创建一个新的的实例。<br>request，对一次的http的请求，创建一个全新的bean实例。<br>session，对某个http seeision 同生通灭。<br>globalSession，对应全局Session的生命周期范围内。</p>\n</blockquote>\n</li>\n</ul>\n<ul>\n<li><p><code>Spring MVC的工作原理</code></p>\n<blockquote>\n<p>客户端请求统一到达DispatcherServlet。<br>根据HandlerMapping获取对应的Handler。<br>Handler完成请求后，返回ModelAndView对象给DispatcherServlet。<br>根据ViewResolver完成视图解析<br>DispatcherServlet会利用视图对象对模型数据进行渲染。</p>\n</blockquote>\n</li>\n<li><p><code>BeanFactory 与 ApplicationContexts</code></p>\n<blockquote>\n<p>ApplicationContext继承BeanFactory<br>ApplicationContexts提供了更高级的功能。<br>BeanFactory在启动时不加载实例，后者反之。</p>\n</blockquote>\n</li>\n<li><p><code>事务管理</code></p>\n<blockquote>\n<p>事务四特性(ACID)：原子性，一致性，隔离性，持久性<br>编程式事务管理：灵活性，但是难维护。<br>声明式事务管理：业务代码和事务管理分离。</p>\n</blockquote>\n</li>\n<li><p><code>隔离级别</code></p>\n<blockquote>\n<p>READ_UNCOMMITTED：允许读取尚未提交的更改。<br>READ_COMMITTED：允许从已经提交的并发事务读取。<br>REPEATABLE_READ：对相同字段的多次读取的结果是一致的。<br>SERIALIZABLE：确保不发生脏读、不可重复读和幻影读。</p>\n</blockquote>\n</li>\n<li><p><code>传播行为</code></p>\n<blockquote>\n<p>REQUIRED 如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。<br>REQUIRES_NEW 创建一个新的事务，如果当前存在事务，则把当前事务挂起。<br>SUPPORTS 如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。<br>NOT_SUPPORTED 以非事务方式运行，如果当前存在事务，则把当前事务挂起。<br>NEVER 以非事务方式运行，如果当前存在事务，则抛出异常。<br>MANDATORY 如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。<br>NESTED 如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于TransactionDefinition.PROPAGATION_REQUIRED。</p>\n</blockquote>\n</li>\n<li><p><code>工具类中注入bean</code></p>\n<blockquote>\n<p>加上@component和@PostConstruct注解。<br>@PostConstruct服务器启动时的做一些初始化工作。</p>\n</blockquote>\n</li>\n<li><p><code>AOP的代理实现</code></p>\n<blockquote>\n<p>动态代理，基于JDK动态代理或CGLIB动态代理，jdk动态代理必须是目标类基于接口。<br>静态代理，编译时进行织入，AspectJ</p>\n</blockquote>\n</li>\n<li><p><code>BeanPostProcessor</code></p>\n<blockquote>\n<p>在Spring容器中完成bean实例化、配置以及其他初始化方法前后要添加一些自己逻辑处理。<br>@Value的实现逻辑依赖于此。</p>\n</blockquote>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<ul>\n<li><p><code>Bean的生命周期</code></p>\n<blockquote>\n<p>实例化bean对象<br>注入对象的属性<br>调用BeanNameAware.setBeanName()<br>调用BeanFactoryAware.setBeanFactory()<br>调用ApplicationContextAware.setApplicationContext()<br>调用BeanPostProcessor.postProcessBeforeInitialzation()<br>调用InitializingBean.afterPropertiesSet()<br>执行init-method<br>调用BeanPostProcessor.postProcessAfterInitialization()<br>使用该Bean<br>调用DisposableBean.destroy()<br>执行destroy-method方法</p>\n</blockquote>\n</li>\n<li><p><code>Bean的作用域</code></p>\n<blockquote>\n<p>singleton，容器在启动时,自动实例化一个实例。<br>prototype，对bean请求的时，创建一个新的的实例。<br>request，对一次的http的请求，创建一个全新的bean实例。<br>session，对某个http seeision 同生通灭。<br>globalSession，对应全局Session的生命周期范围内。</p>\n</blockquote>\n</li>\n</ul>\n<ul>\n<li><p><code>Spring MVC的工作原理</code></p>\n<blockquote>\n<p>客户端请求统一到达DispatcherServlet。<br>根据HandlerMapping获取对应的Handler。<br>Handler完成请求后，返回ModelAndView对象给DispatcherServlet。<br>根据ViewResolver完成视图解析<br>DispatcherServlet会利用视图对象对模型数据进行渲染。</p>\n</blockquote>\n</li>\n<li><p><code>BeanFactory 与 ApplicationContexts</code></p>\n<blockquote>\n<p>ApplicationContext继承BeanFactory<br>ApplicationContexts提供了更高级的功能。<br>BeanFactory在启动时不加载实例，后者反之。</p>\n</blockquote>\n</li>\n<li><p><code>事务管理</code></p>\n<blockquote>\n<p>事务四特性(ACID)：原子性，一致性，隔离性，持久性<br>编程式事务管理：灵活性，但是难维护。<br>声明式事务管理：业务代码和事务管理分离。</p>\n</blockquote>\n</li>\n<li><p><code>隔离级别</code></p>\n<blockquote>\n<p>READ_UNCOMMITTED：允许读取尚未提交的更改。<br>READ_COMMITTED：允许从已经提交的并发事务读取。<br>REPEATABLE_READ：对相同字段的多次读取的结果是一致的。<br>SERIALIZABLE：确保不发生脏读、不可重复读和幻影读。</p>\n</blockquote>\n</li>\n<li><p><code>传播行为</code></p>\n<blockquote>\n<p>REQUIRED 如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。<br>REQUIRES_NEW 创建一个新的事务，如果当前存在事务，则把当前事务挂起。<br>SUPPORTS 如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。<br>NOT_SUPPORTED 以非事务方式运行，如果当前存在事务，则把当前事务挂起。<br>NEVER 以非事务方式运行，如果当前存在事务，则抛出异常。<br>MANDATORY 如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。<br>NESTED 如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于TransactionDefinition.PROPAGATION_REQUIRED。</p>\n</blockquote>\n</li>\n<li><p><code>工具类中注入bean</code></p>\n<blockquote>\n<p>加上@component和@PostConstruct注解。<br>@PostConstruct服务器启动时的做一些初始化工作。</p>\n</blockquote>\n</li>\n<li><p><code>AOP的代理实现</code></p>\n<blockquote>\n<p>动态代理，基于JDK动态代理或CGLIB动态代理，jdk动态代理必须是目标类基于接口。<br>静态代理，编译时进行织入，AspectJ</p>\n</blockquote>\n</li>\n<li><p><code>BeanPostProcessor</code></p>\n<blockquote>\n<p>在Spring容器中完成bean实例化、配置以及其他初始化方法前后要添加一些自己逻辑处理。<br>@Value的实现逻辑依赖于此。</p>\n</blockquote>\n</li>\n</ul>\n"},{"title":"浅析JAVA垃圾回收","date":"2017-12-12T16:00:00.000Z","_content":"#### 哪些内存需要回收？\n`栈，寄存器，本地方法区`。这三个区域，内存随线程而生，随线程而灭，不需要过多考虑回收问题。\n`堆`和`方法区`。这两个区域，只有在运行期才确定创建那些对象，内存的分配和回收都是动态的。\n垃圾回收，回收的是堆和方法区中的内存。\n\n#### 哪些是垃圾对象？\n* `引用计数算法`\n给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用的。该算法不能解决相互引用问题。\n\n* `可达性分析算法`\n从`GC Roots`节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连（用图论的话来说，就是从GC Roots到这个对象不可达）时，则证明此对象是不可用的。\n栈，方法区，本地方法栈中的引用对象可作为GC Roots。\n\n#### 垃圾回收算法\n* 标记-清除算法\n首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。该算法有两个不足，一个是`效率低`，另一个是清除后会出现大量不连续的`内存碎片`。\n\n* 复制算法\n把内存分为两块，每次只使用其中的一块。当这一块用完了，就将还存活的对象复制到另一块，然后再把使用过的内存一次清理掉。优点是，`不会出现内存碎片`。缺点是，`缩小内存的大小`。\n新对象的内存分配都是先在`Eden区域`中进行的，当Eden区域的空间不足时，所有存活的对象（仍然可达对象）会被拷贝到其中一个`Survivor区域`，同时年龄增长为“1”。并清除整个Eden内存区域中的非可达对象。\n\n* 标记-清理算法\n首先标记出所有需要回收的对象，然后将所有存活的对象都向一端移动。\n\n* 分代收集算法\n把内存分为`年轻代`和`年老代`。\n`年轻代`中，对象大批死去，只有少量存活。选用`复制算法`。\n`年老代`中，对象存活率高，选用`标记-清除算法`或`标记-清理`算法","source":"_posts/浅析JAVA垃圾回收.md","raw":"---\ntitle: 浅析JAVA垃圾回收\ncategories:\n- JAVA\ndate: 2017-12-13 \ntags:\n- JVM\n---\n#### 哪些内存需要回收？\n`栈，寄存器，本地方法区`。这三个区域，内存随线程而生，随线程而灭，不需要过多考虑回收问题。\n`堆`和`方法区`。这两个区域，只有在运行期才确定创建那些对象，内存的分配和回收都是动态的。\n垃圾回收，回收的是堆和方法区中的内存。\n\n#### 哪些是垃圾对象？\n* `引用计数算法`\n给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用的。该算法不能解决相互引用问题。\n\n* `可达性分析算法`\n从`GC Roots`节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连（用图论的话来说，就是从GC Roots到这个对象不可达）时，则证明此对象是不可用的。\n栈，方法区，本地方法栈中的引用对象可作为GC Roots。\n\n#### 垃圾回收算法\n* 标记-清除算法\n首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。该算法有两个不足，一个是`效率低`，另一个是清除后会出现大量不连续的`内存碎片`。\n\n* 复制算法\n把内存分为两块，每次只使用其中的一块。当这一块用完了，就将还存活的对象复制到另一块，然后再把使用过的内存一次清理掉。优点是，`不会出现内存碎片`。缺点是，`缩小内存的大小`。\n新对象的内存分配都是先在`Eden区域`中进行的，当Eden区域的空间不足时，所有存活的对象（仍然可达对象）会被拷贝到其中一个`Survivor区域`，同时年龄增长为“1”。并清除整个Eden内存区域中的非可达对象。\n\n* 标记-清理算法\n首先标记出所有需要回收的对象，然后将所有存活的对象都向一端移动。\n\n* 分代收集算法\n把内存分为`年轻代`和`年老代`。\n`年轻代`中，对象大批死去，只有少量存活。选用`复制算法`。\n`年老代`中，对象存活率高，选用`标记-清除算法`或`标记-清理`算法","slug":"浅析JAVA垃圾回收","published":1,"updated":"2018-12-25T01:48:10.718Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjwq2jfe1001xqxpj0or3z00o","content":"<h4 id=\"哪些内存需要回收？\"><a href=\"#哪些内存需要回收？\" class=\"headerlink\" title=\"哪些内存需要回收？\"></a>哪些内存需要回收？</h4><p><code>栈，寄存器，本地方法区</code>。这三个区域，内存随线程而生，随线程而灭，不需要过多考虑回收问题。<br><code>堆</code>和<code>方法区</code>。这两个区域，只有在运行期才确定创建那些对象，内存的分配和回收都是动态的。<br>垃圾回收，回收的是堆和方法区中的内存。</p>\n<h4 id=\"哪些是垃圾对象？\"><a href=\"#哪些是垃圾对象？\" class=\"headerlink\" title=\"哪些是垃圾对象？\"></a>哪些是垃圾对象？</h4><ul>\n<li><p><code>引用计数算法</code><br>给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用的。该算法不能解决相互引用问题。</p>\n</li>\n<li><p><code>可达性分析算法</code><br>从<code>GC Roots</code>节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连（用图论的话来说，就是从GC Roots到这个对象不可达）时，则证明此对象是不可用的。<br>栈，方法区，本地方法栈中的引用对象可作为GC Roots。</p>\n</li>\n</ul>\n<h4 id=\"垃圾回收算法\"><a href=\"#垃圾回收算法\" class=\"headerlink\" title=\"垃圾回收算法\"></a>垃圾回收算法</h4><ul>\n<li><p>标记-清除算法<br>首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。该算法有两个不足，一个是<code>效率低</code>，另一个是清除后会出现大量不连续的<code>内存碎片</code>。</p>\n</li>\n<li><p>复制算法<br>把内存分为两块，每次只使用其中的一块。当这一块用完了，就将还存活的对象复制到另一块，然后再把使用过的内存一次清理掉。优点是，<code>不会出现内存碎片</code>。缺点是，<code>缩小内存的大小</code>。\n新对象的内存分配都是先在<code>Eden区域</code>中进行的，当Eden区域的空间不足时，所有存活的对象（仍然可达对象）会被拷贝到其中一个<code>Survivor区域</code>，同时年龄增长为“1”。并清除整个Eden内存区域中的非可达对象。</p>\n</li>\n<li><p>标记-清理算法<br>首先标记出所有需要回收的对象，然后将所有存活的对象都向一端移动。</p>\n</li>\n<li><p>分代收集算法<br>把内存分为<code>年轻代</code>和<code>年老代</code>。\n<code>年轻代</code>中，对象大批死去，只有少量存活。选用<code>复制算法</code>。\n<code>年老代</code>中，对象存活率高，选用<code>标记-清除算法</code>或<code>标记-清理</code>算法</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"哪些内存需要回收？\"><a href=\"#哪些内存需要回收？\" class=\"headerlink\" title=\"哪些内存需要回收？\"></a>哪些内存需要回收？</h4><p><code>栈，寄存器，本地方法区</code>。这三个区域，内存随线程而生，随线程而灭，不需要过多考虑回收问题。<br><code>堆</code>和<code>方法区</code>。这两个区域，只有在运行期才确定创建那些对象，内存的分配和回收都是动态的。<br>垃圾回收，回收的是堆和方法区中的内存。</p>\n<h4 id=\"哪些是垃圾对象？\"><a href=\"#哪些是垃圾对象？\" class=\"headerlink\" title=\"哪些是垃圾对象？\"></a>哪些是垃圾对象？</h4><ul>\n<li><p><code>引用计数算法</code><br>给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用的。该算法不能解决相互引用问题。</p>\n</li>\n<li><p><code>可达性分析算法</code><br>从<code>GC Roots</code>节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连（用图论的话来说，就是从GC Roots到这个对象不可达）时，则证明此对象是不可用的。<br>栈，方法区，本地方法栈中的引用对象可作为GC Roots。</p>\n</li>\n</ul>\n<h4 id=\"垃圾回收算法\"><a href=\"#垃圾回收算法\" class=\"headerlink\" title=\"垃圾回收算法\"></a>垃圾回收算法</h4><ul>\n<li><p>标记-清除算法<br>首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。该算法有两个不足，一个是<code>效率低</code>，另一个是清除后会出现大量不连续的<code>内存碎片</code>。</p>\n</li>\n<li><p>复制算法<br>把内存分为两块，每次只使用其中的一块。当这一块用完了，就将还存活的对象复制到另一块，然后再把使用过的内存一次清理掉。优点是，<code>不会出现内存碎片</code>。缺点是，<code>缩小内存的大小</code>。\n新对象的内存分配都是先在<code>Eden区域</code>中进行的，当Eden区域的空间不足时，所有存活的对象（仍然可达对象）会被拷贝到其中一个<code>Survivor区域</code>，同时年龄增长为“1”。并清除整个Eden内存区域中的非可达对象。</p>\n</li>\n<li><p>标记-清理算法<br>首先标记出所有需要回收的对象，然后将所有存活的对象都向一端移动。</p>\n</li>\n<li><p>分代收集算法<br>把内存分为<code>年轻代</code>和<code>年老代</code>。\n<code>年轻代</code>中，对象大批死去，只有少量存活。选用<code>复制算法</code>。\n<code>年老代</code>中，对象存活率高，选用<code>标记-清除算法</code>或<code>标记-清理</code>算法</p>\n</li>\n</ul>\n"},{"title":"浅析JAVA对象模型","date":"2018-07-14T16:00:00.000Z","_content":"Java对象在JVM中的存储也是有一定的结构的。而这个关于Java对象自身的存储模型称之为Java对象模型。\n\nJava对象模型,在HotSpot JVM中即`OOP-Klass`模型。\n\n`OOP`（Ordinary Object Pointer）指的是普通对象指针。使用new创建一个对象的时候，JVM会创建一个`instanceOopDesc`对象，保存在`堆`。\n\n`Klass`用来描述对象实例的具体类型。每一个Java类，在被JVM加载的时候，JVM会给这个类创建一个`instanceKlass`，保存在`方法区`。\n\n\n","source":"_posts/浅析JAVA对象模型.md","raw":"---\ntitle: 浅析JAVA对象模型\ncategories:\n- JAVA\ndate: 2018-07-15 \ntags:\n- JVM\n---\nJava对象在JVM中的存储也是有一定的结构的。而这个关于Java对象自身的存储模型称之为Java对象模型。\n\nJava对象模型,在HotSpot JVM中即`OOP-Klass`模型。\n\n`OOP`（Ordinary Object Pointer）指的是普通对象指针。使用new创建一个对象的时候，JVM会创建一个`instanceOopDesc`对象，保存在`堆`。\n\n`Klass`用来描述对象实例的具体类型。每一个Java类，在被JVM加载的时候，JVM会给这个类创建一个`instanceKlass`，保存在`方法区`。\n\n\n","slug":"浅析JAVA对象模型","published":1,"updated":"2018-12-25T01:48:10.796Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjwq2jfe40021qxpjovmxfrpl","content":"<p>Java对象在JVM中的存储也是有一定的结构的。而这个关于Java对象自身的存储模型称之为Java对象模型。</p>\n<p>Java对象模型,在HotSpot JVM中即<code>OOP-Klass</code>模型。</p>\n<p><code>OOP</code>（Ordinary Object Pointer）指的是普通对象指针。使用new创建一个对象的时候，JVM会创建一个<code>instanceOopDesc</code>对象，保存在<code>堆</code>。</p>\n<p><code>Klass</code>用来描述对象实例的具体类型。每一个Java类，在被JVM加载的时候，JVM会给这个类创建一个<code>instanceKlass</code>，保存在<code>方法区</code>。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>Java对象在JVM中的存储也是有一定的结构的。而这个关于Java对象自身的存储模型称之为Java对象模型。</p>\n<p>Java对象模型,在HotSpot JVM中即<code>OOP-Klass</code>模型。</p>\n<p><code>OOP</code>（Ordinary Object Pointer）指的是普通对象指针。使用new创建一个对象的时候，JVM会创建一个<code>instanceOopDesc</code>对象，保存在<code>堆</code>。</p>\n<p><code>Klass</code>用来描述对象实例的具体类型。每一个Java类，在被JVM加载的时候，JVM会给这个类创建一个<code>instanceKlass</code>，保存在<code>方法区</code>。</p>\n"},{"title":"浅析JAVA集合","date":"2018-06-07T16:00:00.000Z","_content":">Set，无序、不可重复的集合。\n>List，有序、可重复的集合。\n>Queue，队列集合实现。\n>Map，具有映射关系的集合。\n>数组需要在初始化的时候指定长度，集合可以保存不确定数量的数据。\n>集合只能保存对象，数组可以保存基本数据类型和对象。\n\n#### Collection 接口\n`Collection`是`Set`，`List`，`Queue`的父接口。\n`add(E e)`，添加元素。\n`size()`方法，返回元素数。\n`toArray(T[] a)`方法，返回所有元素的数组。\n`remove(Object o)`方法，移出单个元素。\n`removeAll(Collection<?> c)`，移出指定元素。\n`retainAll(Collection<?> c)`，取交集。\n`isEmpty()`方法，size=0返回true。\n`iterator()`方法，该方法的返回值是`Iterator\\<E\\>`。\nIterator 适合访问`链式结构`，for循环适合访问`顺序结构`。\n在LinkedList里，使用iterator较快；在ArrayList里，for循环较快。\nforeach和iterator遍历集合时不能修改元素。\n使用Collections的sync方法包装集合为线程安全的集合类。\n\n##### Set 接口\n>Set集合不允许包含相同的元素,集合是无序的。\n>Set的实现原理是基于Map的。\n\n`HashSet`\n线程不安全；\n实现：建立一个Map，“键”就是我们要存入的对象，“值”则是一个常量；\n允许包含值为null的元素，但最多只能有一个null元素；\n\n`LinkedHashSet`\n线程不安全；\n也是一个hash表，但是同时维护了一个双链表来记录插入的顺序；\n遍历该集合时候，LinkedHashSet将会以元素的添加顺序访问集合的元素；\n插入性能略低于HashSet，但是遍历性能优于HashSet；\n\n`TreeSet`\n线程不安全；\n基于Map来实现；\n其底层结构为红黑树，性能不如HashSet；\n遍历该集合时候，会以排序顺序方位集合元素。\n素需要实现Comparable接口，或者集合中传入自定义比较器；\n\n##### List 接口\n>List集合允许包含相同的元素，集合是有序的。\n>每个元素都有其对应的顺序索引。\n\n`ArrayList`\n线程不安全；\n基于动态数组实现；\n添加元素时会扩容数组，删除元素时不会缩小数组，trimToSize方法可以手动缩小；\n内部数组默认大小为10，减少动态分配次数，可提高性能；\n\n`LinkedList`\n线程不安全；\n基于双向链表实现；\n插入和删除性能优于ArrayList，查询性能不如ArrayList；\n\n`Vector`\n线程安全；\n\n##### Queue 接口\n>FIFO容器，队列头部的元素保存时间最长，尾部反之；\n>Deque是Queue的子接口，为双端队列，LinkedList为Deque的实现；\n>add()方法，添加元素到尾部；\n>element()方法，获取头部元素，但不删除；\n>peek()方法，获取头部元素，但不删除；\n>poll()方法，获取头部元素，并删除；\n>remove()方法，删除头部元素；\n\n`PriorityQueue`\n队列的顺序按照大小排序，不按照插入顺序。\n\n#### Map 接口\n>Key和Value必须是引用类型；\n>Key不允许重复；\n\n`HashMap`\n线程不安全；\nKey和Value都可以是null；\n实现基于数组和链表，key值hash取模值分布在数组上，entry形成链表；\n扩容时，生成新的数组，并重新计算写入。\n效率优于HashTable；\n\n`HashTable`\n线程安全；\nKey和Value都不可以是null；\n\n`LinkedHashMap`\n线程不安全；\n实现基于HashMap+LinkedList，LinkedList维护插入元素的先后顺序；\n迭代顺序就是是插入顺序；\n性能低于HashMap，需要维护顺序链表；\n\n`TreeMap`\n红黑树结构；\n根据Key的大小进行排序；\n","source":"_posts/浅析JAVA集合.md","raw":"---\ntitle: 浅析JAVA集合\ncategories:\n- JAVA\ndate: 2018-06-08 \ntags:\n- JVM\n---\n>Set，无序、不可重复的集合。\n>List，有序、可重复的集合。\n>Queue，队列集合实现。\n>Map，具有映射关系的集合。\n>数组需要在初始化的时候指定长度，集合可以保存不确定数量的数据。\n>集合只能保存对象，数组可以保存基本数据类型和对象。\n\n#### Collection 接口\n`Collection`是`Set`，`List`，`Queue`的父接口。\n`add(E e)`，添加元素。\n`size()`方法，返回元素数。\n`toArray(T[] a)`方法，返回所有元素的数组。\n`remove(Object o)`方法，移出单个元素。\n`removeAll(Collection<?> c)`，移出指定元素。\n`retainAll(Collection<?> c)`，取交集。\n`isEmpty()`方法，size=0返回true。\n`iterator()`方法，该方法的返回值是`Iterator\\<E\\>`。\nIterator 适合访问`链式结构`，for循环适合访问`顺序结构`。\n在LinkedList里，使用iterator较快；在ArrayList里，for循环较快。\nforeach和iterator遍历集合时不能修改元素。\n使用Collections的sync方法包装集合为线程安全的集合类。\n\n##### Set 接口\n>Set集合不允许包含相同的元素,集合是无序的。\n>Set的实现原理是基于Map的。\n\n`HashSet`\n线程不安全；\n实现：建立一个Map，“键”就是我们要存入的对象，“值”则是一个常量；\n允许包含值为null的元素，但最多只能有一个null元素；\n\n`LinkedHashSet`\n线程不安全；\n也是一个hash表，但是同时维护了一个双链表来记录插入的顺序；\n遍历该集合时候，LinkedHashSet将会以元素的添加顺序访问集合的元素；\n插入性能略低于HashSet，但是遍历性能优于HashSet；\n\n`TreeSet`\n线程不安全；\n基于Map来实现；\n其底层结构为红黑树，性能不如HashSet；\n遍历该集合时候，会以排序顺序方位集合元素。\n素需要实现Comparable接口，或者集合中传入自定义比较器；\n\n##### List 接口\n>List集合允许包含相同的元素，集合是有序的。\n>每个元素都有其对应的顺序索引。\n\n`ArrayList`\n线程不安全；\n基于动态数组实现；\n添加元素时会扩容数组，删除元素时不会缩小数组，trimToSize方法可以手动缩小；\n内部数组默认大小为10，减少动态分配次数，可提高性能；\n\n`LinkedList`\n线程不安全；\n基于双向链表实现；\n插入和删除性能优于ArrayList，查询性能不如ArrayList；\n\n`Vector`\n线程安全；\n\n##### Queue 接口\n>FIFO容器，队列头部的元素保存时间最长，尾部反之；\n>Deque是Queue的子接口，为双端队列，LinkedList为Deque的实现；\n>add()方法，添加元素到尾部；\n>element()方法，获取头部元素，但不删除；\n>peek()方法，获取头部元素，但不删除；\n>poll()方法，获取头部元素，并删除；\n>remove()方法，删除头部元素；\n\n`PriorityQueue`\n队列的顺序按照大小排序，不按照插入顺序。\n\n#### Map 接口\n>Key和Value必须是引用类型；\n>Key不允许重复；\n\n`HashMap`\n线程不安全；\nKey和Value都可以是null；\n实现基于数组和链表，key值hash取模值分布在数组上，entry形成链表；\n扩容时，生成新的数组，并重新计算写入。\n效率优于HashTable；\n\n`HashTable`\n线程安全；\nKey和Value都不可以是null；\n\n`LinkedHashMap`\n线程不安全；\n实现基于HashMap+LinkedList，LinkedList维护插入元素的先后顺序；\n迭代顺序就是是插入顺序；\n性能低于HashMap，需要维护顺序链表；\n\n`TreeMap`\n红黑树结构；\n根据Key的大小进行排序；\n","slug":"浅析JAVA集合","published":1,"updated":"2018-12-25T01:48:10.773Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjwq2jfe60023qxpjzc1z61ad","content":"<blockquote>\n<p>Set，无序、不可重复的集合。<br>List，有序、可重复的集合。<br>Queue，队列集合实现。<br>Map，具有映射关系的集合。<br>数组需要在初始化的时候指定长度，集合可以保存不确定数量的数据。<br>集合只能保存对象，数组可以保存基本数据类型和对象。</p>\n</blockquote>\n<h4 id=\"Collection-接口\"><a href=\"#Collection-接口\" class=\"headerlink\" title=\"Collection 接口\"></a>Collection 接口</h4><p><code>Collection</code>是<code>Set</code>，<code>List</code>，<code>Queue</code>的父接口。<br><code>add(E e)</code>，添加元素。<br><code>size()</code>方法，返回元素数。<br><code>toArray(T[] a)</code>方法，返回所有元素的数组。<br><code>remove(Object o)</code>方法，移出单个元素。<br><code>removeAll(Collection&lt;?&gt; c)</code>，移出指定元素。<br><code>retainAll(Collection&lt;?&gt; c)</code>，取交集。<br><code>isEmpty()</code>方法，size=0返回true。<br><code>iterator()</code>方法，该方法的返回值是<code>Iterator\\&lt;E\\&gt;</code>。\nIterator 适合访问<code>链式结构</code>，for循环适合访问<code>顺序结构</code>。\n在LinkedList里，使用iterator较快；在ArrayList里，for循环较快。<br>foreach和iterator遍历集合时不能修改元素。<br>使用Collections的sync方法包装集合为线程安全的集合类。</p>\n<h5 id=\"Set-接口\"><a href=\"#Set-接口\" class=\"headerlink\" title=\"Set 接口\"></a>Set 接口</h5><blockquote>\n<p>Set集合不允许包含相同的元素,集合是无序的。<br>Set的实现原理是基于Map的。</p>\n</blockquote>\n<p><code>HashSet</code><br>线程不安全；<br>实现：建立一个Map，“键”就是我们要存入的对象，“值”则是一个常量；<br>允许包含值为null的元素，但最多只能有一个null元素；</p>\n<p><code>LinkedHashSet</code><br>线程不安全；<br>也是一个hash表，但是同时维护了一个双链表来记录插入的顺序；<br>遍历该集合时候，LinkedHashSet将会以元素的添加顺序访问集合的元素；<br>插入性能略低于HashSet，但是遍历性能优于HashSet；</p>\n<p><code>TreeSet</code><br>线程不安全；<br>基于Map来实现；<br>其底层结构为红黑树，性能不如HashSet；<br>遍历该集合时候，会以排序顺序方位集合元素。<br>素需要实现Comparable接口，或者集合中传入自定义比较器；</p>\n<h5 id=\"List-接口\"><a href=\"#List-接口\" class=\"headerlink\" title=\"List 接口\"></a>List 接口</h5><blockquote>\n<p>List集合允许包含相同的元素，集合是有序的。<br>每个元素都有其对应的顺序索引。</p>\n</blockquote>\n<p><code>ArrayList</code><br>线程不安全；<br>基于动态数组实现；<br>添加元素时会扩容数组，删除元素时不会缩小数组，trimToSize方法可以手动缩小；<br>内部数组默认大小为10，减少动态分配次数，可提高性能；</p>\n<p><code>LinkedList</code><br>线程不安全；<br>基于双向链表实现；<br>插入和删除性能优于ArrayList，查询性能不如ArrayList；</p>\n<p><code>Vector</code><br>线程安全；</p>\n<h5 id=\"Queue-接口\"><a href=\"#Queue-接口\" class=\"headerlink\" title=\"Queue 接口\"></a>Queue 接口</h5><blockquote>\n<p>FIFO容器，队列头部的元素保存时间最长，尾部反之；<br>Deque是Queue的子接口，为双端队列，LinkedList为Deque的实现；<br>add()方法，添加元素到尾部；<br>element()方法，获取头部元素，但不删除；<br>peek()方法，获取头部元素，但不删除；<br>poll()方法，获取头部元素，并删除；<br>remove()方法，删除头部元素；</p>\n</blockquote>\n<p><code>PriorityQueue</code><br>队列的顺序按照大小排序，不按照插入顺序。</p>\n<h4 id=\"Map-接口\"><a href=\"#Map-接口\" class=\"headerlink\" title=\"Map 接口\"></a>Map 接口</h4><blockquote>\n<p>Key和Value必须是引用类型；<br>Key不允许重复；</p>\n</blockquote>\n<p><code>HashMap</code><br>线程不安全；<br>Key和Value都可以是null；<br>实现基于数组和链表，key值hash取模值分布在数组上，entry形成链表；<br>扩容时，生成新的数组，并重新计算写入。<br>效率优于HashTable；</p>\n<p><code>HashTable</code><br>线程安全；<br>Key和Value都不可以是null；</p>\n<p><code>LinkedHashMap</code><br>线程不安全；<br>实现基于HashMap+LinkedList，LinkedList维护插入元素的先后顺序；<br>迭代顺序就是是插入顺序；<br>性能低于HashMap，需要维护顺序链表；</p>\n<p><code>TreeMap</code><br>红黑树结构；<br>根据Key的大小进行排序；</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>Set，无序、不可重复的集合。<br>List，有序、可重复的集合。<br>Queue，队列集合实现。<br>Map，具有映射关系的集合。<br>数组需要在初始化的时候指定长度，集合可以保存不确定数量的数据。<br>集合只能保存对象，数组可以保存基本数据类型和对象。</p>\n</blockquote>\n<h4 id=\"Collection-接口\"><a href=\"#Collection-接口\" class=\"headerlink\" title=\"Collection 接口\"></a>Collection 接口</h4><p><code>Collection</code>是<code>Set</code>，<code>List</code>，<code>Queue</code>的父接口。<br><code>add(E e)</code>，添加元素。<br><code>size()</code>方法，返回元素数。<br><code>toArray(T[] a)</code>方法，返回所有元素的数组。<br><code>remove(Object o)</code>方法，移出单个元素。<br><code>removeAll(Collection&lt;?&gt; c)</code>，移出指定元素。<br><code>retainAll(Collection&lt;?&gt; c)</code>，取交集。<br><code>isEmpty()</code>方法，size=0返回true。<br><code>iterator()</code>方法，该方法的返回值是<code>Iterator\\&lt;E\\&gt;</code>。\nIterator 适合访问<code>链式结构</code>，for循环适合访问<code>顺序结构</code>。\n在LinkedList里，使用iterator较快；在ArrayList里，for循环较快。<br>foreach和iterator遍历集合时不能修改元素。<br>使用Collections的sync方法包装集合为线程安全的集合类。</p>\n<h5 id=\"Set-接口\"><a href=\"#Set-接口\" class=\"headerlink\" title=\"Set 接口\"></a>Set 接口</h5><blockquote>\n<p>Set集合不允许包含相同的元素,集合是无序的。<br>Set的实现原理是基于Map的。</p>\n</blockquote>\n<p><code>HashSet</code><br>线程不安全；<br>实现：建立一个Map，“键”就是我们要存入的对象，“值”则是一个常量；<br>允许包含值为null的元素，但最多只能有一个null元素；</p>\n<p><code>LinkedHashSet</code><br>线程不安全；<br>也是一个hash表，但是同时维护了一个双链表来记录插入的顺序；<br>遍历该集合时候，LinkedHashSet将会以元素的添加顺序访问集合的元素；<br>插入性能略低于HashSet，但是遍历性能优于HashSet；</p>\n<p><code>TreeSet</code><br>线程不安全；<br>基于Map来实现；<br>其底层结构为红黑树，性能不如HashSet；<br>遍历该集合时候，会以排序顺序方位集合元素。<br>素需要实现Comparable接口，或者集合中传入自定义比较器；</p>\n<h5 id=\"List-接口\"><a href=\"#List-接口\" class=\"headerlink\" title=\"List 接口\"></a>List 接口</h5><blockquote>\n<p>List集合允许包含相同的元素，集合是有序的。<br>每个元素都有其对应的顺序索引。</p>\n</blockquote>\n<p><code>ArrayList</code><br>线程不安全；<br>基于动态数组实现；<br>添加元素时会扩容数组，删除元素时不会缩小数组，trimToSize方法可以手动缩小；<br>内部数组默认大小为10，减少动态分配次数，可提高性能；</p>\n<p><code>LinkedList</code><br>线程不安全；<br>基于双向链表实现；<br>插入和删除性能优于ArrayList，查询性能不如ArrayList；</p>\n<p><code>Vector</code><br>线程安全；</p>\n<h5 id=\"Queue-接口\"><a href=\"#Queue-接口\" class=\"headerlink\" title=\"Queue 接口\"></a>Queue 接口</h5><blockquote>\n<p>FIFO容器，队列头部的元素保存时间最长，尾部反之；<br>Deque是Queue的子接口，为双端队列，LinkedList为Deque的实现；<br>add()方法，添加元素到尾部；<br>element()方法，获取头部元素，但不删除；<br>peek()方法，获取头部元素，但不删除；<br>poll()方法，获取头部元素，并删除；<br>remove()方法，删除头部元素；</p>\n</blockquote>\n<p><code>PriorityQueue</code><br>队列的顺序按照大小排序，不按照插入顺序。</p>\n<h4 id=\"Map-接口\"><a href=\"#Map-接口\" class=\"headerlink\" title=\"Map 接口\"></a>Map 接口</h4><blockquote>\n<p>Key和Value必须是引用类型；<br>Key不允许重复；</p>\n</blockquote>\n<p><code>HashMap</code><br>线程不安全；<br>Key和Value都可以是null；<br>实现基于数组和链表，key值hash取模值分布在数组上，entry形成链表；<br>扩容时，生成新的数组，并重新计算写入。<br>效率优于HashTable；</p>\n<p><code>HashTable</code><br>线程安全；<br>Key和Value都不可以是null；</p>\n<p><code>LinkedHashMap</code><br>线程不安全；<br>实现基于HashMap+LinkedList，LinkedList维护插入元素的先后顺序；<br>迭代顺序就是是插入顺序；<br>性能低于HashMap，需要维护顺序链表；</p>\n<p><code>TreeMap</code><br>红黑树结构；<br>根据Key的大小进行排序；</p>\n"},{"title":"浅析JMM","date":"2018-06-30T16:00:00.000Z","_content":"Java Memory Model（JMM），Java内存模型，是一个抽象的概念。JMM是围绕着多线程通信以及与其相关的一系列特性而建立的模型。JMM定义了一些语法集，这些语法集映射到Java语言中就是volatile、synchronized等关键字。\n\n![](https://github.com/echolixiaopeng/blog/raw/master/data/jmm.jpeg)\n\nJMM规定了所有的变量都存储在`主内存`（Main Memory）中。每个线程还有自己的`工作内存`（Working Memory）,线程的工作内存中保存了该线程使用到的变量的主内存的副本拷贝，线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行，而不能直接读写主内存中的变量（volatile变量仍然有工作内存的拷贝，但是由于它特殊的操作顺序性规定，所以看起来如同直接在主内存中读写访问一般）。不同的线程之间也无法直接访问对方工作内存中的变量，线程之间值的传递都需要通过主内存来完成。\n\nJava内存模型是围绕着并发编程中`原子性`、`可见性`、`有序性`这三个特征来建立。\n\n#### 原子性\n* 一个操作不能被打断，要么全部执行完毕，要么不执行。\n* 基本类型数据的访问都是`原子操作`。\n* 32位JVM中，long 和double类型的变量的读写操作是非原子操作。\n\n#### 可见性\n* 一个线程对共享变量做了修改之后，其他的线程立即能够看到（感知到）该变量这种修改（变化）。\n* Java内存模型是通过将在工作内存中的变量修改后的值同步到主内存，在读取变量前从主内存刷新最新值到工作内存中，这种依赖主内存的方式来实现可见性的。\n* volatile，synchronized，Lock，final关键字能实现可见性。\n* volatile：每次使用volatile变量前立即从主内存中刷新，修改后的新值立刻同步到主内存。\n* synchronized：同步块开始时，使用共享变量时会从主内存中刷新变量值到工作内存中；同步块结束时，将工作内存中的变量值同步到主内存中去。\n* Lock接口：最常用的实现ReentrantLock(重入锁)来实现可见性。\n\n#### 有序性\n* 在本线程内观察，操作都是有序的；如果在一个线程中观察另外一个线程，所有的操作都是无序的。\n* 无序指“`指令重排`”现象和“工作内存和主内存同步延迟”现象。\n* volatile和synchronized来保证多线程之间操作的有序性。\n\n#### happens-before原则\n* 解释：A happens-before B，A操作执行的结果对B操作可见。\n* `程序顺序规则`： 一个线程中的每个操作，happens-before于该线程中的任意后续操作。\n*  `监视器锁规则`：对一个锁的解锁，happens-before 于随后对这个锁的加锁。\n*  `volatile变量规则`：对一个 volatile域的写，happens-before于任意后续对这个volatile域的读。\n*  `传递性`：如果 A happens-before B,且 B happens-before C,那么A happens-before C\n\n\n","source":"_posts/浅析JMM.md","raw":"---\ntitle: 浅析JMM\ncategories:\n- JAVA\ndate: 2018-07-01 \ntags:\n- JVM\n---\nJava Memory Model（JMM），Java内存模型，是一个抽象的概念。JMM是围绕着多线程通信以及与其相关的一系列特性而建立的模型。JMM定义了一些语法集，这些语法集映射到Java语言中就是volatile、synchronized等关键字。\n\n![](https://github.com/echolixiaopeng/blog/raw/master/data/jmm.jpeg)\n\nJMM规定了所有的变量都存储在`主内存`（Main Memory）中。每个线程还有自己的`工作内存`（Working Memory）,线程的工作内存中保存了该线程使用到的变量的主内存的副本拷贝，线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行，而不能直接读写主内存中的变量（volatile变量仍然有工作内存的拷贝，但是由于它特殊的操作顺序性规定，所以看起来如同直接在主内存中读写访问一般）。不同的线程之间也无法直接访问对方工作内存中的变量，线程之间值的传递都需要通过主内存来完成。\n\nJava内存模型是围绕着并发编程中`原子性`、`可见性`、`有序性`这三个特征来建立。\n\n#### 原子性\n* 一个操作不能被打断，要么全部执行完毕，要么不执行。\n* 基本类型数据的访问都是`原子操作`。\n* 32位JVM中，long 和double类型的变量的读写操作是非原子操作。\n\n#### 可见性\n* 一个线程对共享变量做了修改之后，其他的线程立即能够看到（感知到）该变量这种修改（变化）。\n* Java内存模型是通过将在工作内存中的变量修改后的值同步到主内存，在读取变量前从主内存刷新最新值到工作内存中，这种依赖主内存的方式来实现可见性的。\n* volatile，synchronized，Lock，final关键字能实现可见性。\n* volatile：每次使用volatile变量前立即从主内存中刷新，修改后的新值立刻同步到主内存。\n* synchronized：同步块开始时，使用共享变量时会从主内存中刷新变量值到工作内存中；同步块结束时，将工作内存中的变量值同步到主内存中去。\n* Lock接口：最常用的实现ReentrantLock(重入锁)来实现可见性。\n\n#### 有序性\n* 在本线程内观察，操作都是有序的；如果在一个线程中观察另外一个线程，所有的操作都是无序的。\n* 无序指“`指令重排`”现象和“工作内存和主内存同步延迟”现象。\n* volatile和synchronized来保证多线程之间操作的有序性。\n\n#### happens-before原则\n* 解释：A happens-before B，A操作执行的结果对B操作可见。\n* `程序顺序规则`： 一个线程中的每个操作，happens-before于该线程中的任意后续操作。\n*  `监视器锁规则`：对一个锁的解锁，happens-before 于随后对这个锁的加锁。\n*  `volatile变量规则`：对一个 volatile域的写，happens-before于任意后续对这个volatile域的读。\n*  `传递性`：如果 A happens-before B,且 B happens-before C,那么A happens-before C\n\n\n","slug":"浅析JMM","published":1,"updated":"2018-12-25T01:54:05.727Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjwq2jfe90028qxpjzzosd5ja","content":"<p>Java Memory Model（JMM），Java内存模型，是一个抽象的概念。JMM是围绕着多线程通信以及与其相关的一系列特性而建立的模型。JMM定义了一些语法集，这些语法集映射到Java语言中就是volatile、synchronized等关键字。</p>\n<p><img src=\"https://github.com/echolixiaopeng/blog/raw/master/data/jmm.jpeg\" alt></p>\n<p>JMM规定了所有的变量都存储在<code>主内存</code>（Main Memory）中。每个线程还有自己的<code>工作内存</code>（Working Memory）,线程的工作内存中保存了该线程使用到的变量的主内存的副本拷贝，线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行，而不能直接读写主内存中的变量（volatile变量仍然有工作内存的拷贝，但是由于它特殊的操作顺序性规定，所以看起来如同直接在主内存中读写访问一般）。不同的线程之间也无法直接访问对方工作内存中的变量，线程之间值的传递都需要通过主内存来完成。</p>\n<p>Java内存模型是围绕着并发编程中<code>原子性</code>、<code>可见性</code>、<code>有序性</code>这三个特征来建立。</p>\n<h4 id=\"原子性\"><a href=\"#原子性\" class=\"headerlink\" title=\"原子性\"></a>原子性</h4><ul>\n<li>一个操作不能被打断，要么全部执行完毕，要么不执行。</li>\n<li>基本类型数据的访问都是<code>原子操作</code>。</li>\n<li>32位JVM中，long 和double类型的变量的读写操作是非原子操作。</li>\n</ul>\n<h4 id=\"可见性\"><a href=\"#可见性\" class=\"headerlink\" title=\"可见性\"></a>可见性</h4><ul>\n<li>一个线程对共享变量做了修改之后，其他的线程立即能够看到（感知到）该变量这种修改（变化）。</li>\n<li>Java内存模型是通过将在工作内存中的变量修改后的值同步到主内存，在读取变量前从主内存刷新最新值到工作内存中，这种依赖主内存的方式来实现可见性的。</li>\n<li>volatile，synchronized，Lock，final关键字能实现可见性。</li>\n<li>volatile：每次使用volatile变量前立即从主内存中刷新，修改后的新值立刻同步到主内存。</li>\n<li>synchronized：同步块开始时，使用共享变量时会从主内存中刷新变量值到工作内存中；同步块结束时，将工作内存中的变量值同步到主内存中去。</li>\n<li>Lock接口：最常用的实现ReentrantLock(重入锁)来实现可见性。</li>\n</ul>\n<h4 id=\"有序性\"><a href=\"#有序性\" class=\"headerlink\" title=\"有序性\"></a>有序性</h4><ul>\n<li>在本线程内观察，操作都是有序的；如果在一个线程中观察另外一个线程，所有的操作都是无序的。</li>\n<li>无序指“<code>指令重排</code>”现象和“工作内存和主内存同步延迟”现象。</li>\n<li>volatile和synchronized来保证多线程之间操作的有序性。</li>\n</ul>\n<h4 id=\"happens-before原则\"><a href=\"#happens-before原则\" class=\"headerlink\" title=\"happens-before原则\"></a>happens-before原则</h4><ul>\n<li>解释：A happens-before B，A操作执行的结果对B操作可见。</li>\n<li><code>程序顺序规则</code>： 一个线程中的每个操作，happens-before于该线程中的任意后续操作。</li>\n<li><code>监视器锁规则</code>：对一个锁的解锁，happens-before 于随后对这个锁的加锁。</li>\n<li><code>volatile变量规则</code>：对一个 volatile域的写，happens-before于任意后续对这个volatile域的读。</li>\n<li><code>传递性</code>：如果 A happens-before B,且 B happens-before C,那么A happens-before C</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>Java Memory Model（JMM），Java内存模型，是一个抽象的概念。JMM是围绕着多线程通信以及与其相关的一系列特性而建立的模型。JMM定义了一些语法集，这些语法集映射到Java语言中就是volatile、synchronized等关键字。</p>\n<p><img src=\"https://github.com/echolixiaopeng/blog/raw/master/data/jmm.jpeg\" alt></p>\n<p>JMM规定了所有的变量都存储在<code>主内存</code>（Main Memory）中。每个线程还有自己的<code>工作内存</code>（Working Memory）,线程的工作内存中保存了该线程使用到的变量的主内存的副本拷贝，线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行，而不能直接读写主内存中的变量（volatile变量仍然有工作内存的拷贝，但是由于它特殊的操作顺序性规定，所以看起来如同直接在主内存中读写访问一般）。不同的线程之间也无法直接访问对方工作内存中的变量，线程之间值的传递都需要通过主内存来完成。</p>\n<p>Java内存模型是围绕着并发编程中<code>原子性</code>、<code>可见性</code>、<code>有序性</code>这三个特征来建立。</p>\n<h4 id=\"原子性\"><a href=\"#原子性\" class=\"headerlink\" title=\"原子性\"></a>原子性</h4><ul>\n<li>一个操作不能被打断，要么全部执行完毕，要么不执行。</li>\n<li>基本类型数据的访问都是<code>原子操作</code>。</li>\n<li>32位JVM中，long 和double类型的变量的读写操作是非原子操作。</li>\n</ul>\n<h4 id=\"可见性\"><a href=\"#可见性\" class=\"headerlink\" title=\"可见性\"></a>可见性</h4><ul>\n<li>一个线程对共享变量做了修改之后，其他的线程立即能够看到（感知到）该变量这种修改（变化）。</li>\n<li>Java内存模型是通过将在工作内存中的变量修改后的值同步到主内存，在读取变量前从主内存刷新最新值到工作内存中，这种依赖主内存的方式来实现可见性的。</li>\n<li>volatile，synchronized，Lock，final关键字能实现可见性。</li>\n<li>volatile：每次使用volatile变量前立即从主内存中刷新，修改后的新值立刻同步到主内存。</li>\n<li>synchronized：同步块开始时，使用共享变量时会从主内存中刷新变量值到工作内存中；同步块结束时，将工作内存中的变量值同步到主内存中去。</li>\n<li>Lock接口：最常用的实现ReentrantLock(重入锁)来实现可见性。</li>\n</ul>\n<h4 id=\"有序性\"><a href=\"#有序性\" class=\"headerlink\" title=\"有序性\"></a>有序性</h4><ul>\n<li>在本线程内观察，操作都是有序的；如果在一个线程中观察另外一个线程，所有的操作都是无序的。</li>\n<li>无序指“<code>指令重排</code>”现象和“工作内存和主内存同步延迟”现象。</li>\n<li>volatile和synchronized来保证多线程之间操作的有序性。</li>\n</ul>\n<h4 id=\"happens-before原则\"><a href=\"#happens-before原则\" class=\"headerlink\" title=\"happens-before原则\"></a>happens-before原则</h4><ul>\n<li>解释：A happens-before B，A操作执行的结果对B操作可见。</li>\n<li><code>程序顺序规则</code>： 一个线程中的每个操作，happens-before于该线程中的任意后续操作。</li>\n<li><code>监视器锁规则</code>：对一个锁的解锁，happens-before 于随后对这个锁的加锁。</li>\n<li><code>volatile变量规则</code>：对一个 volatile域的写，happens-before于任意后续对这个volatile域的读。</li>\n<li><code>传递性</code>：如果 A happens-before B,且 B happens-before C,那么A happens-before C</li>\n</ul>\n"},{"title":"浅析JVM内存结构","date":"2018-08-10T16:00:00.000Z","_content":"JVM把内存划分为五个区域。方法区（Method Area），堆区（Heap Area），栈区（Stack Area），PC寄存器（PC Registers），本地方法堆栈（Native Method stacks）·   \n\n![](https://github.com/echolixiaopeng/blog/raw/master/data/JVM%20Runtime%20Data%20Areas.png)\n\n### 方法区（Method Area）\n\n* 方法区，是`线程共享`的。\n* 方法区存放了要加载的类的信息，类中的静态变量、final定义的常量、类中的field、方法信息。\n* `常量池`是方法区的一部分。\n* 方法区对应`持久代`（Permanent Generation），在JDK1.8中`元空间`取代了持久代。\n* 在`Full FC`时会回收方法区的空间。\n\n### 堆区（Heap Area）\n![](https://github.com/echolixiaopeng/blog/raw/master/data/jvm-heap.jpg)\n\n* 堆区，是`线程共享`的。\n* 堆区用来存储对象实例及数组值。\n* 采用了分代管理方式，`年轻代`（Young Generation）和`老年代`（Old Generation）。\n* 年轻代回收时触发`Young GC`，老年代回收时触发`Full GC`。\n* 对象首先会在年轻代中分配，大对象直接在年老代中分配。\n* 年轻代分为S0（Eden Space）和S1（Survivor Space）两部分。\n* 年老代中存放在年轻代中经多次垃圾回收仍然存活的对象，和直接在年老代中分配的对象。\n* -Xms：JVM堆初始分配内存。-Xmx ：JVM的最大堆分配内存。防止堆大小动态扩容，一般两者配置为相同参数。\n\n### 栈区（Stack Area）\n\n* 栈区，是`线程私有`的。\n* 一个线程的每个方法在执行的同时，都会创建一个`栈帧`（Statck Frame）。\n* 当方法被调用时，栈帧在JVM栈中入栈，当方法执行完成时，栈帧出栈。\n* 栈帧中存储的有局部变量表、操作站、动态链接、方法出口等。\n\n### PC寄存器（PC Registers）\n* 寄存器，是`线程私有`的。\n* 用于存储当前线程所执行的字节码的位置。\n\n### 本地方法栈（Native Method stacks）\n* 本地方法栈用于支持native方法的执行，存储了每个native方法调用的状态。\n\n","source":"_posts/浅析JVM内存结构.md","raw":"---\ntitle: 浅析JVM内存结构\ncategories:\n- JAVA\ndate: 2018-08-11 \ntags:\n- JVM\n---\nJVM把内存划分为五个区域。方法区（Method Area），堆区（Heap Area），栈区（Stack Area），PC寄存器（PC Registers），本地方法堆栈（Native Method stacks）·   \n\n![](https://github.com/echolixiaopeng/blog/raw/master/data/JVM%20Runtime%20Data%20Areas.png)\n\n### 方法区（Method Area）\n\n* 方法区，是`线程共享`的。\n* 方法区存放了要加载的类的信息，类中的静态变量、final定义的常量、类中的field、方法信息。\n* `常量池`是方法区的一部分。\n* 方法区对应`持久代`（Permanent Generation），在JDK1.8中`元空间`取代了持久代。\n* 在`Full FC`时会回收方法区的空间。\n\n### 堆区（Heap Area）\n![](https://github.com/echolixiaopeng/blog/raw/master/data/jvm-heap.jpg)\n\n* 堆区，是`线程共享`的。\n* 堆区用来存储对象实例及数组值。\n* 采用了分代管理方式，`年轻代`（Young Generation）和`老年代`（Old Generation）。\n* 年轻代回收时触发`Young GC`，老年代回收时触发`Full GC`。\n* 对象首先会在年轻代中分配，大对象直接在年老代中分配。\n* 年轻代分为S0（Eden Space）和S1（Survivor Space）两部分。\n* 年老代中存放在年轻代中经多次垃圾回收仍然存活的对象，和直接在年老代中分配的对象。\n* -Xms：JVM堆初始分配内存。-Xmx ：JVM的最大堆分配内存。防止堆大小动态扩容，一般两者配置为相同参数。\n\n### 栈区（Stack Area）\n\n* 栈区，是`线程私有`的。\n* 一个线程的每个方法在执行的同时，都会创建一个`栈帧`（Statck Frame）。\n* 当方法被调用时，栈帧在JVM栈中入栈，当方法执行完成时，栈帧出栈。\n* 栈帧中存储的有局部变量表、操作站、动态链接、方法出口等。\n\n### PC寄存器（PC Registers）\n* 寄存器，是`线程私有`的。\n* 用于存储当前线程所执行的字节码的位置。\n\n### 本地方法栈（Native Method stacks）\n* 本地方法栈用于支持native方法的执行，存储了每个native方法调用的状态。\n\n","slug":"浅析JVM内存结构","published":1,"updated":"2018-12-25T01:55:10.937Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjwq2jfeb002aqxpjdjn0w6x0","content":"<p>JVM把内存划分为五个区域。方法区（Method Area），堆区（Heap Area），栈区（Stack Area），PC寄存器（PC Registers），本地方法堆栈（Native Method stacks）·   </p>\n<p><img src=\"https://github.com/echolixiaopeng/blog/raw/master/data/JVM%20Runtime%20Data%20Areas.png\" alt></p>\n<h3 id=\"方法区（Method-Area）\"><a href=\"#方法区（Method-Area）\" class=\"headerlink\" title=\"方法区（Method Area）\"></a>方法区（Method Area）</h3><ul>\n<li>方法区，是<code>线程共享</code>的。</li>\n<li>方法区存放了要加载的类的信息，类中的静态变量、final定义的常量、类中的field、方法信息。</li>\n<li><code>常量池</code>是方法区的一部分。</li>\n<li>方法区对应<code>持久代</code>（Permanent Generation），在JDK1.8中<code>元空间</code>取代了持久代。</li>\n<li>在<code>Full FC</code>时会回收方法区的空间。</li>\n</ul>\n<h3 id=\"堆区（Heap-Area）\"><a href=\"#堆区（Heap-Area）\" class=\"headerlink\" title=\"堆区（Heap Area）\"></a>堆区（Heap Area）</h3><p><img src=\"https://github.com/echolixiaopeng/blog/raw/master/data/jvm-heap.jpg\" alt></p>\n<ul>\n<li>堆区，是<code>线程共享</code>的。</li>\n<li>堆区用来存储对象实例及数组值。</li>\n<li>采用了分代管理方式，<code>年轻代</code>（Young Generation）和<code>老年代</code>（Old Generation）。</li>\n<li>年轻代回收时触发<code>Young GC</code>，老年代回收时触发<code>Full GC</code>。</li>\n<li>对象首先会在年轻代中分配，大对象直接在年老代中分配。</li>\n<li>年轻代分为S0（Eden Space）和S1（Survivor Space）两部分。</li>\n<li>年老代中存放在年轻代中经多次垃圾回收仍然存活的对象，和直接在年老代中分配的对象。</li>\n<li>-Xms：JVM堆初始分配内存。-Xmx ：JVM的最大堆分配内存。防止堆大小动态扩容，一般两者配置为相同参数。</li>\n</ul>\n<h3 id=\"栈区（Stack-Area）\"><a href=\"#栈区（Stack-Area）\" class=\"headerlink\" title=\"栈区（Stack Area）\"></a>栈区（Stack Area）</h3><ul>\n<li>栈区，是<code>线程私有</code>的。</li>\n<li>一个线程的每个方法在执行的同时，都会创建一个<code>栈帧</code>（Statck Frame）。</li>\n<li>当方法被调用时，栈帧在JVM栈中入栈，当方法执行完成时，栈帧出栈。</li>\n<li>栈帧中存储的有局部变量表、操作站、动态链接、方法出口等。</li>\n</ul>\n<h3 id=\"PC寄存器（PC-Registers）\"><a href=\"#PC寄存器（PC-Registers）\" class=\"headerlink\" title=\"PC寄存器（PC Registers）\"></a>PC寄存器（PC Registers）</h3><ul>\n<li>寄存器，是<code>线程私有</code>的。</li>\n<li>用于存储当前线程所执行的字节码的位置。</li>\n</ul>\n<h3 id=\"本地方法栈（Native-Method-stacks）\"><a href=\"#本地方法栈（Native-Method-stacks）\" class=\"headerlink\" title=\"本地方法栈（Native Method stacks）\"></a>本地方法栈（Native Method stacks）</h3><ul>\n<li>本地方法栈用于支持native方法的执行，存储了每个native方法调用的状态。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>JVM把内存划分为五个区域。方法区（Method Area），堆区（Heap Area），栈区（Stack Area），PC寄存器（PC Registers），本地方法堆栈（Native Method stacks）·   </p>\n<p><img src=\"https://github.com/echolixiaopeng/blog/raw/master/data/JVM%20Runtime%20Data%20Areas.png\" alt></p>\n<h3 id=\"方法区（Method-Area）\"><a href=\"#方法区（Method-Area）\" class=\"headerlink\" title=\"方法区（Method Area）\"></a>方法区（Method Area）</h3><ul>\n<li>方法区，是<code>线程共享</code>的。</li>\n<li>方法区存放了要加载的类的信息，类中的静态变量、final定义的常量、类中的field、方法信息。</li>\n<li><code>常量池</code>是方法区的一部分。</li>\n<li>方法区对应<code>持久代</code>（Permanent Generation），在JDK1.8中<code>元空间</code>取代了持久代。</li>\n<li>在<code>Full FC</code>时会回收方法区的空间。</li>\n</ul>\n<h3 id=\"堆区（Heap-Area）\"><a href=\"#堆区（Heap-Area）\" class=\"headerlink\" title=\"堆区（Heap Area）\"></a>堆区（Heap Area）</h3><p><img src=\"https://github.com/echolixiaopeng/blog/raw/master/data/jvm-heap.jpg\" alt></p>\n<ul>\n<li>堆区，是<code>线程共享</code>的。</li>\n<li>堆区用来存储对象实例及数组值。</li>\n<li>采用了分代管理方式，<code>年轻代</code>（Young Generation）和<code>老年代</code>（Old Generation）。</li>\n<li>年轻代回收时触发<code>Young GC</code>，老年代回收时触发<code>Full GC</code>。</li>\n<li>对象首先会在年轻代中分配，大对象直接在年老代中分配。</li>\n<li>年轻代分为S0（Eden Space）和S1（Survivor Space）两部分。</li>\n<li>年老代中存放在年轻代中经多次垃圾回收仍然存活的对象，和直接在年老代中分配的对象。</li>\n<li>-Xms：JVM堆初始分配内存。-Xmx ：JVM的最大堆分配内存。防止堆大小动态扩容，一般两者配置为相同参数。</li>\n</ul>\n<h3 id=\"栈区（Stack-Area）\"><a href=\"#栈区（Stack-Area）\" class=\"headerlink\" title=\"栈区（Stack Area）\"></a>栈区（Stack Area）</h3><ul>\n<li>栈区，是<code>线程私有</code>的。</li>\n<li>一个线程的每个方法在执行的同时，都会创建一个<code>栈帧</code>（Statck Frame）。</li>\n<li>当方法被调用时，栈帧在JVM栈中入栈，当方法执行完成时，栈帧出栈。</li>\n<li>栈帧中存储的有局部变量表、操作站、动态链接、方法出口等。</li>\n</ul>\n<h3 id=\"PC寄存器（PC-Registers）\"><a href=\"#PC寄存器（PC-Registers）\" class=\"headerlink\" title=\"PC寄存器（PC Registers）\"></a>PC寄存器（PC Registers）</h3><ul>\n<li>寄存器，是<code>线程私有</code>的。</li>\n<li>用于存储当前线程所执行的字节码的位置。</li>\n</ul>\n<h3 id=\"本地方法栈（Native-Method-stacks）\"><a href=\"#本地方法栈（Native-Method-stacks）\" class=\"headerlink\" title=\"本地方法栈（Native Method stacks）\"></a>本地方法栈（Native Method stacks）</h3><ul>\n<li>本地方法栈用于支持native方法的执行，存储了每个native方法调用的状态。</li>\n</ul>\n"},{"title":"浅析JVM结构","date":"2018-08-29T16:00:00.000Z","_content":"JRE只是JVM（Java Virtual Machine）标准的一个实现，JVM负责分析字节码，编译代码和执行代码。了解JVM有助于我们写出更高效的代码，下面的内容有助于你了解到JVM的架构和JVM的不同组建。\n    \n### 既然说结构，必须先上图\n![JVM-Architecture](https://github.com/echolixiaopeng/blog/raw/master/data/JVM-Architecture.png)\n\n### JVM的组成是什么？\n如上图所示，JVM由三个子系统构成。\n> 类加载系统 （Class Loader Subsystem）\n> 执行时数据区域（Runtime Data Area）\n> 执行引擎（Execution Engine）\n\n#### 类加载系统 （Class Loader Subsystem）\n类加载系统处理过程包括`加载`和`链接`，并在类文件运行时，首次引用类时`初始化`类文件。\n##### 加载（loading）\n通过一个类的完全限定查找此类字节码文件，并利用字节码文件创建一个Class对象。\n> Bootstrap Class Loader \n> Extension Class Loader\n> Application Class Loader\n\n在Java的日常应用程序开发中，类的加载几乎是由上述3种类加载器相互配合执行的，在必要时，我们还可以自定义类加载器。\n\nJava虚拟机对class文件采用的是`按需加载`的方式，也就是说当需要使用该类时才会将它的class文件加载到内存生成class对象。\n\n虚拟机在加载时，采用的是`双亲委派模式`。其工作原理的是，如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器，如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载。\n\n##### 链接（linking）\n> 验证（Verify）：字节码验证器将验证字节码是否正确。\n> 准备（Prepare) ：为类变量以初始值分配内存。\n> 解释（Resolve）：符号引用替换为直接引用。\n\n##### 初始化（initialization）\n静态变量会被赋予初值，静态方法区会被执行\n\n#### 执行时数据区域（Runtime Data Area）\n运行时数据区可以划分为五个区域\n\n> 方法区（Method Area）：线程共享，存储类级别的数据。\n> 堆区（Heap Area）：线程共享，存储对象，对象中的变量和数组。\n> 栈区（Stack Area）：线程私有，每个方法在执行的同时都会创建一个栈帧。\n> PC寄存器（PC Registers）：线程私有，存储当前执行指令地址。\n> 本地方法堆栈（Native Method stacks）：线程私有，存储本地方法信息。\n\n#### 执行引擎（Execution Engine）\n\n>解释器：解释字节码，当一个方法被调用多次时，每次都需要一个新的解释。\n>JIT编译器：发现重复的代码时，编译整个字节码并将其更改为本地代码。\n>垃圾收集器：收集和删除未引用的对象。","source":"_posts/浅析JVM结构.md","raw":"---\ntitle: 浅析JVM结构\ncategories:\n- JAVA\ndate: 2018-08-30 \ntags:\n- JVM\n---\nJRE只是JVM（Java Virtual Machine）标准的一个实现，JVM负责分析字节码，编译代码和执行代码。了解JVM有助于我们写出更高效的代码，下面的内容有助于你了解到JVM的架构和JVM的不同组建。\n    \n### 既然说结构，必须先上图\n![JVM-Architecture](https://github.com/echolixiaopeng/blog/raw/master/data/JVM-Architecture.png)\n\n### JVM的组成是什么？\n如上图所示，JVM由三个子系统构成。\n> 类加载系统 （Class Loader Subsystem）\n> 执行时数据区域（Runtime Data Area）\n> 执行引擎（Execution Engine）\n\n#### 类加载系统 （Class Loader Subsystem）\n类加载系统处理过程包括`加载`和`链接`，并在类文件运行时，首次引用类时`初始化`类文件。\n##### 加载（loading）\n通过一个类的完全限定查找此类字节码文件，并利用字节码文件创建一个Class对象。\n> Bootstrap Class Loader \n> Extension Class Loader\n> Application Class Loader\n\n在Java的日常应用程序开发中，类的加载几乎是由上述3种类加载器相互配合执行的，在必要时，我们还可以自定义类加载器。\n\nJava虚拟机对class文件采用的是`按需加载`的方式，也就是说当需要使用该类时才会将它的class文件加载到内存生成class对象。\n\n虚拟机在加载时，采用的是`双亲委派模式`。其工作原理的是，如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器，如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载。\n\n##### 链接（linking）\n> 验证（Verify）：字节码验证器将验证字节码是否正确。\n> 准备（Prepare) ：为类变量以初始值分配内存。\n> 解释（Resolve）：符号引用替换为直接引用。\n\n##### 初始化（initialization）\n静态变量会被赋予初值，静态方法区会被执行\n\n#### 执行时数据区域（Runtime Data Area）\n运行时数据区可以划分为五个区域\n\n> 方法区（Method Area）：线程共享，存储类级别的数据。\n> 堆区（Heap Area）：线程共享，存储对象，对象中的变量和数组。\n> 栈区（Stack Area）：线程私有，每个方法在执行的同时都会创建一个栈帧。\n> PC寄存器（PC Registers）：线程私有，存储当前执行指令地址。\n> 本地方法堆栈（Native Method stacks）：线程私有，存储本地方法信息。\n\n#### 执行引擎（Execution Engine）\n\n>解释器：解释字节码，当一个方法被调用多次时，每次都需要一个新的解释。\n>JIT编译器：发现重复的代码时，编译整个字节码并将其更改为本地代码。\n>垃圾收集器：收集和删除未引用的对象。","slug":"浅析JVM结构","published":1,"updated":"2018-12-25T01:54:27.091Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjwq2jfed002fqxpj0lv71031","content":"<p>JRE只是JVM（Java Virtual Machine）标准的一个实现，JVM负责分析字节码，编译代码和执行代码。了解JVM有助于我们写出更高效的代码，下面的内容有助于你了解到JVM的架构和JVM的不同组建。</p>\n<h3 id=\"既然说结构，必须先上图\"><a href=\"#既然说结构，必须先上图\" class=\"headerlink\" title=\"既然说结构，必须先上图\"></a>既然说结构，必须先上图</h3><p><img src=\"https://github.com/echolixiaopeng/blog/raw/master/data/JVM-Architecture.png\" alt=\"JVM-Architecture\"></p>\n<h3 id=\"JVM的组成是什么？\"><a href=\"#JVM的组成是什么？\" class=\"headerlink\" title=\"JVM的组成是什么？\"></a>JVM的组成是什么？</h3><p>如上图所示，JVM由三个子系统构成。</p>\n<blockquote>\n<p>类加载系统 （Class Loader Subsystem）<br>执行时数据区域（Runtime Data Area）<br>执行引擎（Execution Engine）</p>\n</blockquote>\n<h4 id=\"类加载系统-（Class-Loader-Subsystem）\"><a href=\"#类加载系统-（Class-Loader-Subsystem）\" class=\"headerlink\" title=\"类加载系统 （Class Loader Subsystem）\"></a>类加载系统 （Class Loader Subsystem）</h4><p>类加载系统处理过程包括<code>加载</code>和<code>链接</code>，并在类文件运行时，首次引用类时<code>初始化</code>类文件。</p>\n<h5 id=\"加载（loading）\"><a href=\"#加载（loading）\" class=\"headerlink\" title=\"加载（loading）\"></a>加载（loading）</h5><p>通过一个类的完全限定查找此类字节码文件，并利用字节码文件创建一个Class对象。</p>\n<blockquote>\n<p>Bootstrap Class Loader<br>Extension Class Loader<br>Application Class Loader</p>\n</blockquote>\n<p>在Java的日常应用程序开发中，类的加载几乎是由上述3种类加载器相互配合执行的，在必要时，我们还可以自定义类加载器。</p>\n<p>Java虚拟机对class文件采用的是<code>按需加载</code>的方式，也就是说当需要使用该类时才会将它的class文件加载到内存生成class对象。</p>\n<p>虚拟机在加载时，采用的是<code>双亲委派模式</code>。其工作原理的是，如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器，如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载。</p>\n<h5 id=\"链接（linking）\"><a href=\"#链接（linking）\" class=\"headerlink\" title=\"链接（linking）\"></a>链接（linking）</h5><blockquote>\n<p>验证（Verify）：字节码验证器将验证字节码是否正确。<br>准备（Prepare) ：为类变量以初始值分配内存。<br>解释（Resolve）：符号引用替换为直接引用。</p>\n</blockquote>\n<h5 id=\"初始化（initialization）\"><a href=\"#初始化（initialization）\" class=\"headerlink\" title=\"初始化（initialization）\"></a>初始化（initialization）</h5><p>静态变量会被赋予初值，静态方法区会被执行</p>\n<h4 id=\"执行时数据区域（Runtime-Data-Area）\"><a href=\"#执行时数据区域（Runtime-Data-Area）\" class=\"headerlink\" title=\"执行时数据区域（Runtime Data Area）\"></a>执行时数据区域（Runtime Data Area）</h4><p>运行时数据区可以划分为五个区域</p>\n<blockquote>\n<p>方法区（Method Area）：线程共享，存储类级别的数据。<br>堆区（Heap Area）：线程共享，存储对象，对象中的变量和数组。<br>栈区（Stack Area）：线程私有，每个方法在执行的同时都会创建一个栈帧。<br>PC寄存器（PC Registers）：线程私有，存储当前执行指令地址。<br>本地方法堆栈（Native Method stacks）：线程私有，存储本地方法信息。</p>\n</blockquote>\n<h4 id=\"执行引擎（Execution-Engine）\"><a href=\"#执行引擎（Execution-Engine）\" class=\"headerlink\" title=\"执行引擎（Execution Engine）\"></a>执行引擎（Execution Engine）</h4><blockquote>\n<p>解释器：解释字节码，当一个方法被调用多次时，每次都需要一个新的解释。<br>JIT编译器：发现重复的代码时，编译整个字节码并将其更改为本地代码。<br>垃圾收集器：收集和删除未引用的对象。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<p>JRE只是JVM（Java Virtual Machine）标准的一个实现，JVM负责分析字节码，编译代码和执行代码。了解JVM有助于我们写出更高效的代码，下面的内容有助于你了解到JVM的架构和JVM的不同组建。</p>\n<h3 id=\"既然说结构，必须先上图\"><a href=\"#既然说结构，必须先上图\" class=\"headerlink\" title=\"既然说结构，必须先上图\"></a>既然说结构，必须先上图</h3><p><img src=\"https://github.com/echolixiaopeng/blog/raw/master/data/JVM-Architecture.png\" alt=\"JVM-Architecture\"></p>\n<h3 id=\"JVM的组成是什么？\"><a href=\"#JVM的组成是什么？\" class=\"headerlink\" title=\"JVM的组成是什么？\"></a>JVM的组成是什么？</h3><p>如上图所示，JVM由三个子系统构成。</p>\n<blockquote>\n<p>类加载系统 （Class Loader Subsystem）<br>执行时数据区域（Runtime Data Area）<br>执行引擎（Execution Engine）</p>\n</blockquote>\n<h4 id=\"类加载系统-（Class-Loader-Subsystem）\"><a href=\"#类加载系统-（Class-Loader-Subsystem）\" class=\"headerlink\" title=\"类加载系统 （Class Loader Subsystem）\"></a>类加载系统 （Class Loader Subsystem）</h4><p>类加载系统处理过程包括<code>加载</code>和<code>链接</code>，并在类文件运行时，首次引用类时<code>初始化</code>类文件。</p>\n<h5 id=\"加载（loading）\"><a href=\"#加载（loading）\" class=\"headerlink\" title=\"加载（loading）\"></a>加载（loading）</h5><p>通过一个类的完全限定查找此类字节码文件，并利用字节码文件创建一个Class对象。</p>\n<blockquote>\n<p>Bootstrap Class Loader<br>Extension Class Loader<br>Application Class Loader</p>\n</blockquote>\n<p>在Java的日常应用程序开发中，类的加载几乎是由上述3种类加载器相互配合执行的，在必要时，我们还可以自定义类加载器。</p>\n<p>Java虚拟机对class文件采用的是<code>按需加载</code>的方式，也就是说当需要使用该类时才会将它的class文件加载到内存生成class对象。</p>\n<p>虚拟机在加载时，采用的是<code>双亲委派模式</code>。其工作原理的是，如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器，如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载。</p>\n<h5 id=\"链接（linking）\"><a href=\"#链接（linking）\" class=\"headerlink\" title=\"链接（linking）\"></a>链接（linking）</h5><blockquote>\n<p>验证（Verify）：字节码验证器将验证字节码是否正确。<br>准备（Prepare) ：为类变量以初始值分配内存。<br>解释（Resolve）：符号引用替换为直接引用。</p>\n</blockquote>\n<h5 id=\"初始化（initialization）\"><a href=\"#初始化（initialization）\" class=\"headerlink\" title=\"初始化（initialization）\"></a>初始化（initialization）</h5><p>静态变量会被赋予初值，静态方法区会被执行</p>\n<h4 id=\"执行时数据区域（Runtime-Data-Area）\"><a href=\"#执行时数据区域（Runtime-Data-Area）\" class=\"headerlink\" title=\"执行时数据区域（Runtime Data Area）\"></a>执行时数据区域（Runtime Data Area）</h4><p>运行时数据区可以划分为五个区域</p>\n<blockquote>\n<p>方法区（Method Area）：线程共享，存储类级别的数据。<br>堆区（Heap Area）：线程共享，存储对象，对象中的变量和数组。<br>栈区（Stack Area）：线程私有，每个方法在执行的同时都会创建一个栈帧。<br>PC寄存器（PC Registers）：线程私有，存储当前执行指令地址。<br>本地方法堆栈（Native Method stacks）：线程私有，存储本地方法信息。</p>\n</blockquote>\n<h4 id=\"执行引擎（Execution-Engine）\"><a href=\"#执行引擎（Execution-Engine）\" class=\"headerlink\" title=\"执行引擎（Execution Engine）\"></a>执行引擎（Execution Engine）</h4><blockquote>\n<p>解释器：解释字节码，当一个方法被调用多次时，每次都需要一个新的解释。<br>JIT编译器：发现重复的代码时，编译整个字节码并将其更改为本地代码。<br>垃圾收集器：收集和删除未引用的对象。</p>\n</blockquote>\n"},{"title":"浅析JVM调试工具","date":"2018-01-08T16:00:00.000Z","_content":">JVM调试工具，适用于调试以下问题：\n>OOM问题\n>内存泄露问题\n>CPU占用率高问题\n\n#### top - 系统进程监控\n```\ntop -Hp <pid>\n\n  PID USER      PR  NI    VIRT    RES    SHR S %CPU %MEM     TIME+ COMMAND                                                  \n16786 root      20   0 5207600 851948   9692 S  0.7  2.6   1:31.38 java                                                     \n16783 root      20   0 5207600 851948   9692 S  0.3  2.6   2:09.71 java                                                     \n16785 root      20   0 5207600 851948   9692 S  0.3  2.6   1:31.53 java                                                    \n```\n`参数说明`\n>-H 检查该进程内运行的线程状况\n>-p 通过指定监控进程ID来仅仅监控某个进程的状态。 \n\n\n`结果列说明`\n>PID : 进程id\n>S : 进程状态。D=不可中断的睡眠状态 R=运行 S=睡眠 T=跟踪/停止 Z=僵尸进程\n>%CPU : 上次更新到现在的CPU时间占用百分比\n>%MEM : 进程使用的物理内存百分比\n>TIME+ : 进程使用的CPU时间总计（1:31.38，表示1分钟:31秒.38毫秒）\n\n\n#### jps - java虚拟机进程监控\n```\njps -ml \n\n23424 /data/service-x-test/gateway-x/gateway-x.jar\n28098 service-xx-x-0.0.1-SNAPSHOT.jar \n5256 gateway-xx.jar --spring.profiles.active=test \n```\n`参数说明`\n>-m:输出主函数传入的参数\n>-l: 输出应用程序主类完整package名称或jar完整名称\n\n#### jstatck - 查看Java进程内的线程堆栈信息 \n```\njstack <pid>\n\n\"Druid-ConnectionPool-Create-641011362\" #26 daemon prio=5 os_prio=0 tid=0x00007f55898de000 nid=0x4165 waiting on condition [0x00007f55c3afd000]\n   java.lang.Thread.State: WAITING (parking)\n        at sun.misc.Unsafe.park(Native Method)\n        - parking to wait for  <0x00000000b6a23ca0> (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)\n        at java.util.concurrent.locks.LockSupport.park(LockSupport.java:175)\n        at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:2039)\n        at com.alibaba.druid.pool.DruidDataSource$CreateConnectionThread.run(DruidDataSource.java:2308)\n```\n`结果列说明`\n>nid : 操作系统映射的线程id。16进制表示。\n>Thread.State : Waiting(等待唤醒)，Timed_Waiting(有时间限制的等待唤醒)，Runnable(得到CPU，就可以执行)\n\n\n#### jmap\n* 查看指定JVM进程的堆信息\n```\njmap -heap <pid>\n\nAttaching to process ID 16694, please wait...\nDebugger attached successfully.\nServer compiler detected.\nJVM version is 25.144-b01\n\nusing thread-local object allocation.\nParallel GC with 4 thread(s)\n\nHeap Configuration: #堆内存初始化配置\n   MinHeapFreeRatio         = 0\n   MaxHeapFreeRatio         = 100\n   #-XX:MaxHeapSize=设置JVM堆的最大大小\n   MaxHeapSize              = 1258291200 (1200.0MB)\n   #-XX:NewSize=设置JVM堆的‘新生代’的默认大小\n   NewSize                  = 175112192 (167.0MB)\n   #-XX:MaxNewSize=设置JVM堆的‘新生代’的最大大小\n   MaxNewSize               = 419430400 (400.0MB)\n   #-XX:OldSize=设置JVM堆的‘老生代’的大小\n   OldSize                  = 351272960 (335.0MB)\n   #-XX:NewRatio=:‘新生代’和‘老生代’的大小比率\n   NewRatio                 = 2\n   SurvivorRatio            = 8\n   MetaspaceSize            = 21807104 (20.796875MB)\n   CompressedClassSpaceSize = 1073741824 (1024.0MB)\n   MaxMetaspaceSize         = 17592186044415 MB\n   G1HeapRegionSize         = 0 (0.0MB)\n\nHeap Usage:\nPS Young Generation\nEden Space: #Eden区内存分布\n   capacity = 62914560 (60.0MB)\n   used     = 5889832 (5.616981506347656MB)\n   free     = 57024728 (54.383018493652344MB)\n   9.36163584391276% used\nFrom Space: #其中一个Survivor区的内存分布\n   capacity = 1048576 (1.0MB)\n   used     = 589824 (0.5625MB)\n   free     = 458752 (0.4375MB)\n   56.25% used\nTo Space: #另一个Survivor区的内存分布\n   capacity = 1572864 (1.5MB)\n   used     = 0 (0.0MB)\n   free     = 1572864 (1.5MB)\n   0.0% used\nPS Old Generation #当前的Old区内存分布 \n   capacity = 376963072 (359.5MB)\n   used     = 114052600 (108.76903533935547MB)\n   free     = 262910472 (250.73096466064453MB)\n   30.25564265350639% used\n\n40297 interned Strings occupying 4669600 bytes.\n```\n`注意`\njmap -heap有些时候会导致进程暂停，可通过jstat -gc获取内存目前每个区域的使用状况\n\n * 打印堆的对象统计\n```\njmap -histo <pid>\n\n num     #instances         #bytes  class name\n----------------------------------------------\n   1:         41799       30989904  [I\n   2:        299256       26082000  [C\n   3:         72156        8964856  [B\n   4:        291594        6998256  java.lang.String\n   5:         52692        4636896  java.lang.reflect.Method\n```\n`结果列说明`\n>B 代表 byte\nC 代表 char\nD 代表 double\nF 代表 float\nI 代表 int\nJ 代表 long\nZ 代表 boolean\n前边有 [ 代表数组， [I 就相当于 int[]\n对象用 [L+ 类名表示\n\n* 导出JVM内存信息\n```\njmap -dump:format=b,file=文件名 <pid>\n```\n`结果说明`\n>导出的dump文件可以使用Java VisualVM 分析。\n>heap如果比较大的话，就会导致这个过程比较耗时。\n>执行的过程中为了保证dump的信息是可靠的，所以会暂停应用。\n>配置JVM启动参数，OOM时自动生成Dump文件。\n\n#### jstat\n```\njstat -gc <pid> <采集间隔时间ms> <采集次数>\n\n S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT     GCT   \n512.0  512.0   96.0   0.0   56320.0  56320.0   273408.0   38963.4   48384.0 46119.9 6144.0 5724.3   6712   22.214   2      0.216   22.429\n512.0  512.0   96.0   0.0   56320.0  56320.0   273408.0   38963.4   48384.0 46119.9 6144.0 5724.3   6712   22.214   2      0.216   22.429\n512.0  512.0   96.0   0.0   56320.0  56320.0   273408.0   38963.4   48384.0 46119.9 6144.0 5724.3   6712   22.214   2      0.216   22.429\n512.0  512.0   96.0   0.0   56320.0  56320.0   273408.0   38963.4   48384.0 46119.9 6144.0 5724.3   6712   22.214   2      0.216   22.429\n512.0  512.0   96.0   0.0   56320.0  56320.0   273408.0   38963.4   48384.0 46119.9 6144.0 5724.3   6712   22.214   2      0.216   22.429\n512.0  512.0   96.0   0.0   56320.0  56320.0   273408.0   38963.4   48384.0 46119.9 6144.0 5724.3   6712   22.214   2      0.216   22.429\n512.0  512.0   96.0   0.0   56320.0  56320.0   273408.0   38963.4   48384.0 46119.9 6144.0 5724.3   6712   22.214   2      0.216   22.429\n512.0  512.0   96.0   0.0   56320.0  56320.0   273408.0   38963.4   48384.0 46119.9 6144.0 5724.3   6712   22.214   2      0.216   22.429\n512.0  512.0   96.0   0.0   56320.0  56320.0   273408.0   38963.4   48384.0 46119.9 6144.0 5724.3   6712   22.214   2      0.216   22.429\n512.0  512.0   96.0   0.0   56320.0  56320.0   273408.0   38963.4   48384.0 46119.9 6144.0 5724.3   6712   22.214   2      0.216   22.429\n```\n`结果列说明`\n>YGC : 从应用程序启动到采样时年轻代中gc次数\n>YGCT : 从应用程序启动到采样时年轻代中gc所用时间(s)\n>FGC : 从应用程序启动到采样时old代(全gc)gc次数\n>FGCT : 从应用程序启动到采样时old代(全gc)gc所用时间(s)\n>OC :  Old代的容量 (字节)\n>OU :  Old代目前已使用空间 (字节)\n\n\n","source":"_posts/浅析JVM调试工具.md","raw":"---\ntitle: 浅析JVM调试工具\ncategories:\n- JAVA\ndate: 2018-01-09 \ntags:\n- JVM\n---\n>JVM调试工具，适用于调试以下问题：\n>OOM问题\n>内存泄露问题\n>CPU占用率高问题\n\n#### top - 系统进程监控\n```\ntop -Hp <pid>\n\n  PID USER      PR  NI    VIRT    RES    SHR S %CPU %MEM     TIME+ COMMAND                                                  \n16786 root      20   0 5207600 851948   9692 S  0.7  2.6   1:31.38 java                                                     \n16783 root      20   0 5207600 851948   9692 S  0.3  2.6   2:09.71 java                                                     \n16785 root      20   0 5207600 851948   9692 S  0.3  2.6   1:31.53 java                                                    \n```\n`参数说明`\n>-H 检查该进程内运行的线程状况\n>-p 通过指定监控进程ID来仅仅监控某个进程的状态。 \n\n\n`结果列说明`\n>PID : 进程id\n>S : 进程状态。D=不可中断的睡眠状态 R=运行 S=睡眠 T=跟踪/停止 Z=僵尸进程\n>%CPU : 上次更新到现在的CPU时间占用百分比\n>%MEM : 进程使用的物理内存百分比\n>TIME+ : 进程使用的CPU时间总计（1:31.38，表示1分钟:31秒.38毫秒）\n\n\n#### jps - java虚拟机进程监控\n```\njps -ml \n\n23424 /data/service-x-test/gateway-x/gateway-x.jar\n28098 service-xx-x-0.0.1-SNAPSHOT.jar \n5256 gateway-xx.jar --spring.profiles.active=test \n```\n`参数说明`\n>-m:输出主函数传入的参数\n>-l: 输出应用程序主类完整package名称或jar完整名称\n\n#### jstatck - 查看Java进程内的线程堆栈信息 \n```\njstack <pid>\n\n\"Druid-ConnectionPool-Create-641011362\" #26 daemon prio=5 os_prio=0 tid=0x00007f55898de000 nid=0x4165 waiting on condition [0x00007f55c3afd000]\n   java.lang.Thread.State: WAITING (parking)\n        at sun.misc.Unsafe.park(Native Method)\n        - parking to wait for  <0x00000000b6a23ca0> (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)\n        at java.util.concurrent.locks.LockSupport.park(LockSupport.java:175)\n        at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:2039)\n        at com.alibaba.druid.pool.DruidDataSource$CreateConnectionThread.run(DruidDataSource.java:2308)\n```\n`结果列说明`\n>nid : 操作系统映射的线程id。16进制表示。\n>Thread.State : Waiting(等待唤醒)，Timed_Waiting(有时间限制的等待唤醒)，Runnable(得到CPU，就可以执行)\n\n\n#### jmap\n* 查看指定JVM进程的堆信息\n```\njmap -heap <pid>\n\nAttaching to process ID 16694, please wait...\nDebugger attached successfully.\nServer compiler detected.\nJVM version is 25.144-b01\n\nusing thread-local object allocation.\nParallel GC with 4 thread(s)\n\nHeap Configuration: #堆内存初始化配置\n   MinHeapFreeRatio         = 0\n   MaxHeapFreeRatio         = 100\n   #-XX:MaxHeapSize=设置JVM堆的最大大小\n   MaxHeapSize              = 1258291200 (1200.0MB)\n   #-XX:NewSize=设置JVM堆的‘新生代’的默认大小\n   NewSize                  = 175112192 (167.0MB)\n   #-XX:MaxNewSize=设置JVM堆的‘新生代’的最大大小\n   MaxNewSize               = 419430400 (400.0MB)\n   #-XX:OldSize=设置JVM堆的‘老生代’的大小\n   OldSize                  = 351272960 (335.0MB)\n   #-XX:NewRatio=:‘新生代’和‘老生代’的大小比率\n   NewRatio                 = 2\n   SurvivorRatio            = 8\n   MetaspaceSize            = 21807104 (20.796875MB)\n   CompressedClassSpaceSize = 1073741824 (1024.0MB)\n   MaxMetaspaceSize         = 17592186044415 MB\n   G1HeapRegionSize         = 0 (0.0MB)\n\nHeap Usage:\nPS Young Generation\nEden Space: #Eden区内存分布\n   capacity = 62914560 (60.0MB)\n   used     = 5889832 (5.616981506347656MB)\n   free     = 57024728 (54.383018493652344MB)\n   9.36163584391276% used\nFrom Space: #其中一个Survivor区的内存分布\n   capacity = 1048576 (1.0MB)\n   used     = 589824 (0.5625MB)\n   free     = 458752 (0.4375MB)\n   56.25% used\nTo Space: #另一个Survivor区的内存分布\n   capacity = 1572864 (1.5MB)\n   used     = 0 (0.0MB)\n   free     = 1572864 (1.5MB)\n   0.0% used\nPS Old Generation #当前的Old区内存分布 \n   capacity = 376963072 (359.5MB)\n   used     = 114052600 (108.76903533935547MB)\n   free     = 262910472 (250.73096466064453MB)\n   30.25564265350639% used\n\n40297 interned Strings occupying 4669600 bytes.\n```\n`注意`\njmap -heap有些时候会导致进程暂停，可通过jstat -gc获取内存目前每个区域的使用状况\n\n * 打印堆的对象统计\n```\njmap -histo <pid>\n\n num     #instances         #bytes  class name\n----------------------------------------------\n   1:         41799       30989904  [I\n   2:        299256       26082000  [C\n   3:         72156        8964856  [B\n   4:        291594        6998256  java.lang.String\n   5:         52692        4636896  java.lang.reflect.Method\n```\n`结果列说明`\n>B 代表 byte\nC 代表 char\nD 代表 double\nF 代表 float\nI 代表 int\nJ 代表 long\nZ 代表 boolean\n前边有 [ 代表数组， [I 就相当于 int[]\n对象用 [L+ 类名表示\n\n* 导出JVM内存信息\n```\njmap -dump:format=b,file=文件名 <pid>\n```\n`结果说明`\n>导出的dump文件可以使用Java VisualVM 分析。\n>heap如果比较大的话，就会导致这个过程比较耗时。\n>执行的过程中为了保证dump的信息是可靠的，所以会暂停应用。\n>配置JVM启动参数，OOM时自动生成Dump文件。\n\n#### jstat\n```\njstat -gc <pid> <采集间隔时间ms> <采集次数>\n\n S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT     GCT   \n512.0  512.0   96.0   0.0   56320.0  56320.0   273408.0   38963.4   48384.0 46119.9 6144.0 5724.3   6712   22.214   2      0.216   22.429\n512.0  512.0   96.0   0.0   56320.0  56320.0   273408.0   38963.4   48384.0 46119.9 6144.0 5724.3   6712   22.214   2      0.216   22.429\n512.0  512.0   96.0   0.0   56320.0  56320.0   273408.0   38963.4   48384.0 46119.9 6144.0 5724.3   6712   22.214   2      0.216   22.429\n512.0  512.0   96.0   0.0   56320.0  56320.0   273408.0   38963.4   48384.0 46119.9 6144.0 5724.3   6712   22.214   2      0.216   22.429\n512.0  512.0   96.0   0.0   56320.0  56320.0   273408.0   38963.4   48384.0 46119.9 6144.0 5724.3   6712   22.214   2      0.216   22.429\n512.0  512.0   96.0   0.0   56320.0  56320.0   273408.0   38963.4   48384.0 46119.9 6144.0 5724.3   6712   22.214   2      0.216   22.429\n512.0  512.0   96.0   0.0   56320.0  56320.0   273408.0   38963.4   48384.0 46119.9 6144.0 5724.3   6712   22.214   2      0.216   22.429\n512.0  512.0   96.0   0.0   56320.0  56320.0   273408.0   38963.4   48384.0 46119.9 6144.0 5724.3   6712   22.214   2      0.216   22.429\n512.0  512.0   96.0   0.0   56320.0  56320.0   273408.0   38963.4   48384.0 46119.9 6144.0 5724.3   6712   22.214   2      0.216   22.429\n512.0  512.0   96.0   0.0   56320.0  56320.0   273408.0   38963.4   48384.0 46119.9 6144.0 5724.3   6712   22.214   2      0.216   22.429\n```\n`结果列说明`\n>YGC : 从应用程序启动到采样时年轻代中gc次数\n>YGCT : 从应用程序启动到采样时年轻代中gc所用时间(s)\n>FGC : 从应用程序启动到采样时old代(全gc)gc次数\n>FGCT : 从应用程序启动到采样时old代(全gc)gc所用时间(s)\n>OC :  Old代的容量 (字节)\n>OU :  Old代目前已使用空间 (字节)\n\n\n","slug":"浅析JVM调试工具","published":1,"updated":"2018-12-25T01:48:09.938Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjwq2jfef002hqxpjhn1pmrlx","content":"<blockquote>\n<p>JVM调试工具，适用于调试以下问题：<br>OOM问题<br>内存泄露问题<br>CPU占用率高问题</p>\n</blockquote>\n<h4 id=\"top-系统进程监控\"><a href=\"#top-系统进程监控\" class=\"headerlink\" title=\"top - 系统进程监控\"></a>top - 系统进程监控</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">top -Hp &lt;pid&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">  PID USER      PR  NI    VIRT    RES    SHR S %CPU %MEM     TIME+ COMMAND                                                  </span><br><span class=\"line\">16786 root      20   0 5207600 851948   9692 S  0.7  2.6   1:31.38 java                                                     </span><br><span class=\"line\">16783 root      20   0 5207600 851948   9692 S  0.3  2.6   2:09.71 java                                                     </span><br><span class=\"line\">16785 root      20   0 5207600 851948   9692 S  0.3  2.6   1:31.53 java</span><br></pre></td></tr></table></figure>\n\n<p><code>参数说明</code></p>\n<blockquote>\n<p>-H 检查该进程内运行的线程状况<br>-p 通过指定监控进程ID来仅仅监控某个进程的状态。 </p>\n</blockquote>\n<p><code>结果列说明</code></p>\n<blockquote>\n<p>PID : 进程id<br>S : 进程状态。D=不可中断的睡眠状态 R=运行 S=睡眠 T=跟踪/停止 Z=僵尸进程<br>%CPU : 上次更新到现在的CPU时间占用百分比<br>%MEM : 进程使用的物理内存百分比<br>TIME+ : 进程使用的CPU时间总计（1:31.38，表示1分钟:31秒.38毫秒）</p>\n</blockquote>\n<h4 id=\"jps-java虚拟机进程监控\"><a href=\"#jps-java虚拟机进程监控\" class=\"headerlink\" title=\"jps - java虚拟机进程监控\"></a>jps - java虚拟机进程监控</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jps -ml </span><br><span class=\"line\"></span><br><span class=\"line\">23424 /data/service-x-test/gateway-x/gateway-x.jar</span><br><span class=\"line\">28098 service-xx-x-0.0.1-SNAPSHOT.jar </span><br><span class=\"line\">5256 gateway-xx.jar --spring.profiles.active=test</span><br></pre></td></tr></table></figure>\n\n<p><code>参数说明</code></p>\n<blockquote>\n<p>-m:输出主函数传入的参数<br>-l: 输出应用程序主类完整package名称或jar完整名称</p>\n</blockquote>\n<h4 id=\"jstatck-查看Java进程内的线程堆栈信息\"><a href=\"#jstatck-查看Java进程内的线程堆栈信息\" class=\"headerlink\" title=\"jstatck - 查看Java进程内的线程堆栈信息\"></a>jstatck - 查看Java进程内的线程堆栈信息</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jstack &lt;pid&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&quot;Druid-ConnectionPool-Create-641011362&quot; #26 daemon prio=5 os_prio=0 tid=0x00007f55898de000 nid=0x4165 waiting on condition [0x00007f55c3afd000]</span><br><span class=\"line\">   java.lang.Thread.State: WAITING (parking)</span><br><span class=\"line\">        at sun.misc.Unsafe.park(Native Method)</span><br><span class=\"line\">        - parking to wait for  &lt;0x00000000b6a23ca0&gt; (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)</span><br><span class=\"line\">        at java.util.concurrent.locks.LockSupport.park(LockSupport.java:175)</span><br><span class=\"line\">        at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:2039)</span><br><span class=\"line\">        at com.alibaba.druid.pool.DruidDataSource$CreateConnectionThread.run(DruidDataSource.java:2308)</span><br></pre></td></tr></table></figure>\n\n<p><code>结果列说明</code></p>\n<blockquote>\n<p>nid : 操作系统映射的线程id。16进制表示。<br>Thread.State : Waiting(等待唤醒)，Timed_Waiting(有时间限制的等待唤醒)，Runnable(得到CPU，就可以执行)</p>\n</blockquote>\n<h4 id=\"jmap\"><a href=\"#jmap\" class=\"headerlink\" title=\"jmap\"></a>jmap</h4><ul>\n<li>查看指定JVM进程的堆信息<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jmap -heap &lt;pid&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">Attaching to process ID 16694, please wait...</span><br><span class=\"line\">Debugger attached successfully.</span><br><span class=\"line\">Server compiler detected.</span><br><span class=\"line\">JVM version is 25.144-b01</span><br><span class=\"line\"></span><br><span class=\"line\">using thread-local object allocation.</span><br><span class=\"line\">Parallel GC with 4 thread(s)</span><br><span class=\"line\"></span><br><span class=\"line\">Heap Configuration: #堆内存初始化配置</span><br><span class=\"line\">   MinHeapFreeRatio         = 0</span><br><span class=\"line\">   MaxHeapFreeRatio         = 100</span><br><span class=\"line\">   #-XX:MaxHeapSize=设置JVM堆的最大大小</span><br><span class=\"line\">   MaxHeapSize              = 1258291200 (1200.0MB)</span><br><span class=\"line\">   #-XX:NewSize=设置JVM堆的‘新生代’的默认大小</span><br><span class=\"line\">   NewSize                  = 175112192 (167.0MB)</span><br><span class=\"line\">   #-XX:MaxNewSize=设置JVM堆的‘新生代’的最大大小</span><br><span class=\"line\">   MaxNewSize               = 419430400 (400.0MB)</span><br><span class=\"line\">   #-XX:OldSize=设置JVM堆的‘老生代’的大小</span><br><span class=\"line\">   OldSize                  = 351272960 (335.0MB)</span><br><span class=\"line\">   #-XX:NewRatio=:‘新生代’和‘老生代’的大小比率</span><br><span class=\"line\">   NewRatio                 = 2</span><br><span class=\"line\">   SurvivorRatio            = 8</span><br><span class=\"line\">   MetaspaceSize            = 21807104 (20.796875MB)</span><br><span class=\"line\">   CompressedClassSpaceSize = 1073741824 (1024.0MB)</span><br><span class=\"line\">   MaxMetaspaceSize         = 17592186044415 MB</span><br><span class=\"line\">   G1HeapRegionSize         = 0 (0.0MB)</span><br><span class=\"line\"></span><br><span class=\"line\">Heap Usage:</span><br><span class=\"line\">PS Young Generation</span><br><span class=\"line\">Eden Space: #Eden区内存分布</span><br><span class=\"line\">   capacity = 62914560 (60.0MB)</span><br><span class=\"line\">   used     = 5889832 (5.616981506347656MB)</span><br><span class=\"line\">   free     = 57024728 (54.383018493652344MB)</span><br><span class=\"line\">   9.36163584391276% used</span><br><span class=\"line\">From Space: #其中一个Survivor区的内存分布</span><br><span class=\"line\">   capacity = 1048576 (1.0MB)</span><br><span class=\"line\">   used     = 589824 (0.5625MB)</span><br><span class=\"line\">   free     = 458752 (0.4375MB)</span><br><span class=\"line\">   56.25% used</span><br><span class=\"line\">To Space: #另一个Survivor区的内存分布</span><br><span class=\"line\">   capacity = 1572864 (1.5MB)</span><br><span class=\"line\">   used     = 0 (0.0MB)</span><br><span class=\"line\">   free     = 1572864 (1.5MB)</span><br><span class=\"line\">   0.0% used</span><br><span class=\"line\">PS Old Generation #当前的Old区内存分布 </span><br><span class=\"line\">   capacity = 376963072 (359.5MB)</span><br><span class=\"line\">   used     = 114052600 (108.76903533935547MB)</span><br><span class=\"line\">   free     = 262910472 (250.73096466064453MB)</span><br><span class=\"line\">   30.25564265350639% used</span><br><span class=\"line\"></span><br><span class=\"line\">40297 interned Strings occupying 4669600 bytes.</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<p><code>注意</code><br>jmap -heap有些时候会导致进程暂停，可通过jstat -gc获取内存目前每个区域的使用状况</p>\n<ul>\n<li>打印堆的对象统计<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jmap -histo &lt;pid&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"> num     #instances         #bytes  class name</span><br><span class=\"line\">----------------------------------------------</span><br><span class=\"line\">   1:         41799       30989904  [I</span><br><span class=\"line\">   2:        299256       26082000  [C</span><br><span class=\"line\">   3:         72156        8964856  [B</span><br><span class=\"line\">   4:        291594        6998256  java.lang.String</span><br><span class=\"line\">   5:         52692        4636896  java.lang.reflect.Method</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<p><code>结果列说明</code></p>\n<blockquote>\n<p>B 代表 byte<br>C 代表 char<br>D 代表 double<br>F 代表 float<br>I 代表 int<br>J 代表 long<br>Z 代表 boolean<br>前边有 [ 代表数组， [I 就相当于 int[]<br>对象用 [L+ 类名表示</p>\n</blockquote>\n<ul>\n<li>导出JVM内存信息<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jmap -dump:format=b,file=文件名 &lt;pid&gt;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<p><code>结果说明</code></p>\n<blockquote>\n<p>导出的dump文件可以使用Java VisualVM 分析。<br>heap如果比较大的话，就会导致这个过程比较耗时。<br>执行的过程中为了保证dump的信息是可靠的，所以会暂停应用。<br>配置JVM启动参数，OOM时自动生成Dump文件。</p>\n</blockquote>\n<h4 id=\"jstat\"><a href=\"#jstat\" class=\"headerlink\" title=\"jstat\"></a>jstat</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jstat -gc &lt;pid&gt; &lt;采集间隔时间ms&gt; &lt;采集次数&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"> S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT     GCT   </span><br><span class=\"line\">512.0  512.0   96.0   0.0   56320.0  56320.0   273408.0   38963.4   48384.0 46119.9 6144.0 5724.3   6712   22.214   2      0.216   22.429</span><br><span class=\"line\">512.0  512.0   96.0   0.0   56320.0  56320.0   273408.0   38963.4   48384.0 46119.9 6144.0 5724.3   6712   22.214   2      0.216   22.429</span><br><span class=\"line\">512.0  512.0   96.0   0.0   56320.0  56320.0   273408.0   38963.4   48384.0 46119.9 6144.0 5724.3   6712   22.214   2      0.216   22.429</span><br><span class=\"line\">512.0  512.0   96.0   0.0   56320.0  56320.0   273408.0   38963.4   48384.0 46119.9 6144.0 5724.3   6712   22.214   2      0.216   22.429</span><br><span class=\"line\">512.0  512.0   96.0   0.0   56320.0  56320.0   273408.0   38963.4   48384.0 46119.9 6144.0 5724.3   6712   22.214   2      0.216   22.429</span><br><span class=\"line\">512.0  512.0   96.0   0.0   56320.0  56320.0   273408.0   38963.4   48384.0 46119.9 6144.0 5724.3   6712   22.214   2      0.216   22.429</span><br><span class=\"line\">512.0  512.0   96.0   0.0   56320.0  56320.0   273408.0   38963.4   48384.0 46119.9 6144.0 5724.3   6712   22.214   2      0.216   22.429</span><br><span class=\"line\">512.0  512.0   96.0   0.0   56320.0  56320.0   273408.0   38963.4   48384.0 46119.9 6144.0 5724.3   6712   22.214   2      0.216   22.429</span><br><span class=\"line\">512.0  512.0   96.0   0.0   56320.0  56320.0   273408.0   38963.4   48384.0 46119.9 6144.0 5724.3   6712   22.214   2      0.216   22.429</span><br><span class=\"line\">512.0  512.0   96.0   0.0   56320.0  56320.0   273408.0   38963.4   48384.0 46119.9 6144.0 5724.3   6712   22.214   2      0.216   22.429</span><br></pre></td></tr></table></figure>\n\n<p><code>结果列说明</code></p>\n<blockquote>\n<p>YGC : 从应用程序启动到采样时年轻代中gc次数<br>YGCT : 从应用程序启动到采样时年轻代中gc所用时间(s)<br>FGC : 从应用程序启动到采样时old代(全gc)gc次数<br>FGCT : 从应用程序启动到采样时old代(全gc)gc所用时间(s)<br>OC :  Old代的容量 (字节)<br>OU :  Old代目前已使用空间 (字节)</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>JVM调试工具，适用于调试以下问题：<br>OOM问题<br>内存泄露问题<br>CPU占用率高问题</p>\n</blockquote>\n<h4 id=\"top-系统进程监控\"><a href=\"#top-系统进程监控\" class=\"headerlink\" title=\"top - 系统进程监控\"></a>top - 系统进程监控</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">top -Hp &lt;pid&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">  PID USER      PR  NI    VIRT    RES    SHR S %CPU %MEM     TIME+ COMMAND                                                  </span><br><span class=\"line\">16786 root      20   0 5207600 851948   9692 S  0.7  2.6   1:31.38 java                                                     </span><br><span class=\"line\">16783 root      20   0 5207600 851948   9692 S  0.3  2.6   2:09.71 java                                                     </span><br><span class=\"line\">16785 root      20   0 5207600 851948   9692 S  0.3  2.6   1:31.53 java</span><br></pre></td></tr></table></figure>\n\n<p><code>参数说明</code></p>\n<blockquote>\n<p>-H 检查该进程内运行的线程状况<br>-p 通过指定监控进程ID来仅仅监控某个进程的状态。 </p>\n</blockquote>\n<p><code>结果列说明</code></p>\n<blockquote>\n<p>PID : 进程id<br>S : 进程状态。D=不可中断的睡眠状态 R=运行 S=睡眠 T=跟踪/停止 Z=僵尸进程<br>%CPU : 上次更新到现在的CPU时间占用百分比<br>%MEM : 进程使用的物理内存百分比<br>TIME+ : 进程使用的CPU时间总计（1:31.38，表示1分钟:31秒.38毫秒）</p>\n</blockquote>\n<h4 id=\"jps-java虚拟机进程监控\"><a href=\"#jps-java虚拟机进程监控\" class=\"headerlink\" title=\"jps - java虚拟机进程监控\"></a>jps - java虚拟机进程监控</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jps -ml </span><br><span class=\"line\"></span><br><span class=\"line\">23424 /data/service-x-test/gateway-x/gateway-x.jar</span><br><span class=\"line\">28098 service-xx-x-0.0.1-SNAPSHOT.jar </span><br><span class=\"line\">5256 gateway-xx.jar --spring.profiles.active=test</span><br></pre></td></tr></table></figure>\n\n<p><code>参数说明</code></p>\n<blockquote>\n<p>-m:输出主函数传入的参数<br>-l: 输出应用程序主类完整package名称或jar完整名称</p>\n</blockquote>\n<h4 id=\"jstatck-查看Java进程内的线程堆栈信息\"><a href=\"#jstatck-查看Java进程内的线程堆栈信息\" class=\"headerlink\" title=\"jstatck - 查看Java进程内的线程堆栈信息\"></a>jstatck - 查看Java进程内的线程堆栈信息</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jstack &lt;pid&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&quot;Druid-ConnectionPool-Create-641011362&quot; #26 daemon prio=5 os_prio=0 tid=0x00007f55898de000 nid=0x4165 waiting on condition [0x00007f55c3afd000]</span><br><span class=\"line\">   java.lang.Thread.State: WAITING (parking)</span><br><span class=\"line\">        at sun.misc.Unsafe.park(Native Method)</span><br><span class=\"line\">        - parking to wait for  &lt;0x00000000b6a23ca0&gt; (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)</span><br><span class=\"line\">        at java.util.concurrent.locks.LockSupport.park(LockSupport.java:175)</span><br><span class=\"line\">        at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:2039)</span><br><span class=\"line\">        at com.alibaba.druid.pool.DruidDataSource$CreateConnectionThread.run(DruidDataSource.java:2308)</span><br></pre></td></tr></table></figure>\n\n<p><code>结果列说明</code></p>\n<blockquote>\n<p>nid : 操作系统映射的线程id。16进制表示。<br>Thread.State : Waiting(等待唤醒)，Timed_Waiting(有时间限制的等待唤醒)，Runnable(得到CPU，就可以执行)</p>\n</blockquote>\n<h4 id=\"jmap\"><a href=\"#jmap\" class=\"headerlink\" title=\"jmap\"></a>jmap</h4><ul>\n<li>查看指定JVM进程的堆信息<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jmap -heap &lt;pid&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">Attaching to process ID 16694, please wait...</span><br><span class=\"line\">Debugger attached successfully.</span><br><span class=\"line\">Server compiler detected.</span><br><span class=\"line\">JVM version is 25.144-b01</span><br><span class=\"line\"></span><br><span class=\"line\">using thread-local object allocation.</span><br><span class=\"line\">Parallel GC with 4 thread(s)</span><br><span class=\"line\"></span><br><span class=\"line\">Heap Configuration: #堆内存初始化配置</span><br><span class=\"line\">   MinHeapFreeRatio         = 0</span><br><span class=\"line\">   MaxHeapFreeRatio         = 100</span><br><span class=\"line\">   #-XX:MaxHeapSize=设置JVM堆的最大大小</span><br><span class=\"line\">   MaxHeapSize              = 1258291200 (1200.0MB)</span><br><span class=\"line\">   #-XX:NewSize=设置JVM堆的‘新生代’的默认大小</span><br><span class=\"line\">   NewSize                  = 175112192 (167.0MB)</span><br><span class=\"line\">   #-XX:MaxNewSize=设置JVM堆的‘新生代’的最大大小</span><br><span class=\"line\">   MaxNewSize               = 419430400 (400.0MB)</span><br><span class=\"line\">   #-XX:OldSize=设置JVM堆的‘老生代’的大小</span><br><span class=\"line\">   OldSize                  = 351272960 (335.0MB)</span><br><span class=\"line\">   #-XX:NewRatio=:‘新生代’和‘老生代’的大小比率</span><br><span class=\"line\">   NewRatio                 = 2</span><br><span class=\"line\">   SurvivorRatio            = 8</span><br><span class=\"line\">   MetaspaceSize            = 21807104 (20.796875MB)</span><br><span class=\"line\">   CompressedClassSpaceSize = 1073741824 (1024.0MB)</span><br><span class=\"line\">   MaxMetaspaceSize         = 17592186044415 MB</span><br><span class=\"line\">   G1HeapRegionSize         = 0 (0.0MB)</span><br><span class=\"line\"></span><br><span class=\"line\">Heap Usage:</span><br><span class=\"line\">PS Young Generation</span><br><span class=\"line\">Eden Space: #Eden区内存分布</span><br><span class=\"line\">   capacity = 62914560 (60.0MB)</span><br><span class=\"line\">   used     = 5889832 (5.616981506347656MB)</span><br><span class=\"line\">   free     = 57024728 (54.383018493652344MB)</span><br><span class=\"line\">   9.36163584391276% used</span><br><span class=\"line\">From Space: #其中一个Survivor区的内存分布</span><br><span class=\"line\">   capacity = 1048576 (1.0MB)</span><br><span class=\"line\">   used     = 589824 (0.5625MB)</span><br><span class=\"line\">   free     = 458752 (0.4375MB)</span><br><span class=\"line\">   56.25% used</span><br><span class=\"line\">To Space: #另一个Survivor区的内存分布</span><br><span class=\"line\">   capacity = 1572864 (1.5MB)</span><br><span class=\"line\">   used     = 0 (0.0MB)</span><br><span class=\"line\">   free     = 1572864 (1.5MB)</span><br><span class=\"line\">   0.0% used</span><br><span class=\"line\">PS Old Generation #当前的Old区内存分布 </span><br><span class=\"line\">   capacity = 376963072 (359.5MB)</span><br><span class=\"line\">   used     = 114052600 (108.76903533935547MB)</span><br><span class=\"line\">   free     = 262910472 (250.73096466064453MB)</span><br><span class=\"line\">   30.25564265350639% used</span><br><span class=\"line\"></span><br><span class=\"line\">40297 interned Strings occupying 4669600 bytes.</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<p><code>注意</code><br>jmap -heap有些时候会导致进程暂停，可通过jstat -gc获取内存目前每个区域的使用状况</p>\n<ul>\n<li>打印堆的对象统计<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jmap -histo &lt;pid&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"> num     #instances         #bytes  class name</span><br><span class=\"line\">----------------------------------------------</span><br><span class=\"line\">   1:         41799       30989904  [I</span><br><span class=\"line\">   2:        299256       26082000  [C</span><br><span class=\"line\">   3:         72156        8964856  [B</span><br><span class=\"line\">   4:        291594        6998256  java.lang.String</span><br><span class=\"line\">   5:         52692        4636896  java.lang.reflect.Method</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<p><code>结果列说明</code></p>\n<blockquote>\n<p>B 代表 byte<br>C 代表 char<br>D 代表 double<br>F 代表 float<br>I 代表 int<br>J 代表 long<br>Z 代表 boolean<br>前边有 [ 代表数组， [I 就相当于 int[]<br>对象用 [L+ 类名表示</p>\n</blockquote>\n<ul>\n<li>导出JVM内存信息<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jmap -dump:format=b,file=文件名 &lt;pid&gt;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<p><code>结果说明</code></p>\n<blockquote>\n<p>导出的dump文件可以使用Java VisualVM 分析。<br>heap如果比较大的话，就会导致这个过程比较耗时。<br>执行的过程中为了保证dump的信息是可靠的，所以会暂停应用。<br>配置JVM启动参数，OOM时自动生成Dump文件。</p>\n</blockquote>\n<h4 id=\"jstat\"><a href=\"#jstat\" class=\"headerlink\" title=\"jstat\"></a>jstat</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jstat -gc &lt;pid&gt; &lt;采集间隔时间ms&gt; &lt;采集次数&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"> S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT     GCT   </span><br><span class=\"line\">512.0  512.0   96.0   0.0   56320.0  56320.0   273408.0   38963.4   48384.0 46119.9 6144.0 5724.3   6712   22.214   2      0.216   22.429</span><br><span class=\"line\">512.0  512.0   96.0   0.0   56320.0  56320.0   273408.0   38963.4   48384.0 46119.9 6144.0 5724.3   6712   22.214   2      0.216   22.429</span><br><span class=\"line\">512.0  512.0   96.0   0.0   56320.0  56320.0   273408.0   38963.4   48384.0 46119.9 6144.0 5724.3   6712   22.214   2      0.216   22.429</span><br><span class=\"line\">512.0  512.0   96.0   0.0   56320.0  56320.0   273408.0   38963.4   48384.0 46119.9 6144.0 5724.3   6712   22.214   2      0.216   22.429</span><br><span class=\"line\">512.0  512.0   96.0   0.0   56320.0  56320.0   273408.0   38963.4   48384.0 46119.9 6144.0 5724.3   6712   22.214   2      0.216   22.429</span><br><span class=\"line\">512.0  512.0   96.0   0.0   56320.0  56320.0   273408.0   38963.4   48384.0 46119.9 6144.0 5724.3   6712   22.214   2      0.216   22.429</span><br><span class=\"line\">512.0  512.0   96.0   0.0   56320.0  56320.0   273408.0   38963.4   48384.0 46119.9 6144.0 5724.3   6712   22.214   2      0.216   22.429</span><br><span class=\"line\">512.0  512.0   96.0   0.0   56320.0  56320.0   273408.0   38963.4   48384.0 46119.9 6144.0 5724.3   6712   22.214   2      0.216   22.429</span><br><span class=\"line\">512.0  512.0   96.0   0.0   56320.0  56320.0   273408.0   38963.4   48384.0 46119.9 6144.0 5724.3   6712   22.214   2      0.216   22.429</span><br><span class=\"line\">512.0  512.0   96.0   0.0   56320.0  56320.0   273408.0   38963.4   48384.0 46119.9 6144.0 5724.3   6712   22.214   2      0.216   22.429</span><br></pre></td></tr></table></figure>\n\n<p><code>结果列说明</code></p>\n<blockquote>\n<p>YGC : 从应用程序启动到采样时年轻代中gc次数<br>YGCT : 从应用程序启动到采样时年轻代中gc所用时间(s)<br>FGC : 从应用程序启动到采样时old代(全gc)gc次数<br>FGCT : 从应用程序启动到采样时old代(全gc)gc所用时间(s)<br>OC :  Old代的容量 (字节)<br>OU :  Old代目前已使用空间 (字节)</p>\n</blockquote>\n"},{"title":"浅识Nginx","date":"2018-05-31T16:00:00.000Z","_content":">国籍：俄罗斯\n>语言：C语言\n>开源软件，BSD许可\n>跨平台支持Linux和Windows\n>可作为WEB服务器，负载均衡器，邮件代理服务器等\n\n#### 优势\n`轻量级`\n占用更少的内存资源\n\n`高并发`\n异步非阻塞，epoll模，单机高并发\n\n`模块化`\n高度模块化的设计，便于扩展\n\n`超稳定`\n分为主进程，工作进程\n\n#### 为什么高性能\n`多进程模型`\nnginx默认以多进程的方式工作，一个master进程和多个worker进程，master进程主要用来管理worker进程。\n`异步非阻塞`\n在epoll支持下，采用异步非阻塞的方式来处理请求，从而实现高并发。\n\n#### 进程模型\n>多进程模型\n>独立的工作进程，不共享资源，不加锁\n\n`master进程`\n主进程，充当监控进程。\n不需要处理网络事件，不负责业务的执行。\n只负责管理worker进程。\n\n`worker进程`\n负责处理网络IO。\n各worker进程竞争来自客户端的请求。\n多cpu的情况下，设置woker进程的数量等于cpu的核数。\nNginx支持将某一个进程绑定在某一个核上。\n\n#### 常用命令\n`nginx` 启动\n\n`nginx -s stop` 关闭\n\n`ngixn -s relaod` 重载配置文件\n\n`nginx -t` 检查配置文件\n\n`nginx -v` 查看版本\n\n#### 性能优化\n\n1. worker_processes配置为CPU核数。\n2. 将worker process与指定cpu核绑定。\n3. 关闭访问日志，加快磁盘IO。\n4. 开启gzip，减少网络传输时间。\n5. worker_rlimit_nofile，更改worker进程的最大打开文件数限制","source":"_posts/浅识Nginx.md","raw":"---\ntitle: 浅识Nginx\ncategories:\n- 中间件\ndate: 2018-06-01 \ntags:\n- Nginx\n---\n>国籍：俄罗斯\n>语言：C语言\n>开源软件，BSD许可\n>跨平台支持Linux和Windows\n>可作为WEB服务器，负载均衡器，邮件代理服务器等\n\n#### 优势\n`轻量级`\n占用更少的内存资源\n\n`高并发`\n异步非阻塞，epoll模，单机高并发\n\n`模块化`\n高度模块化的设计，便于扩展\n\n`超稳定`\n分为主进程，工作进程\n\n#### 为什么高性能\n`多进程模型`\nnginx默认以多进程的方式工作，一个master进程和多个worker进程，master进程主要用来管理worker进程。\n`异步非阻塞`\n在epoll支持下，采用异步非阻塞的方式来处理请求，从而实现高并发。\n\n#### 进程模型\n>多进程模型\n>独立的工作进程，不共享资源，不加锁\n\n`master进程`\n主进程，充当监控进程。\n不需要处理网络事件，不负责业务的执行。\n只负责管理worker进程。\n\n`worker进程`\n负责处理网络IO。\n各worker进程竞争来自客户端的请求。\n多cpu的情况下，设置woker进程的数量等于cpu的核数。\nNginx支持将某一个进程绑定在某一个核上。\n\n#### 常用命令\n`nginx` 启动\n\n`nginx -s stop` 关闭\n\n`ngixn -s relaod` 重载配置文件\n\n`nginx -t` 检查配置文件\n\n`nginx -v` 查看版本\n\n#### 性能优化\n\n1. worker_processes配置为CPU核数。\n2. 将worker process与指定cpu核绑定。\n3. 关闭访问日志，加快磁盘IO。\n4. 开启gzip，减少网络传输时间。\n5. worker_rlimit_nofile，更改worker进程的最大打开文件数限制","slug":"浅识Nginx","published":1,"updated":"2018-12-25T01:48:12.515Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjwq2jfeh002mqxpj1ut6rvjx","content":"<blockquote>\n<p>国籍：俄罗斯<br>语言：C语言<br>开源软件，BSD许可<br>跨平台支持Linux和Windows<br>可作为WEB服务器，负载均衡器，邮件代理服务器等</p>\n</blockquote>\n<h4 id=\"优势\"><a href=\"#优势\" class=\"headerlink\" title=\"优势\"></a>优势</h4><p><code>轻量级</code><br>占用更少的内存资源</p>\n<p><code>高并发</code><br>异步非阻塞，epoll模，单机高并发</p>\n<p><code>模块化</code><br>高度模块化的设计，便于扩展</p>\n<p><code>超稳定</code><br>分为主进程，工作进程</p>\n<h4 id=\"为什么高性能\"><a href=\"#为什么高性能\" class=\"headerlink\" title=\"为什么高性能\"></a>为什么高性能</h4><p><code>多进程模型</code><br>nginx默认以多进程的方式工作，一个master进程和多个worker进程，master进程主要用来管理worker进程。<br><code>异步非阻塞</code><br>在epoll支持下，采用异步非阻塞的方式来处理请求，从而实现高并发。</p>\n<h4 id=\"进程模型\"><a href=\"#进程模型\" class=\"headerlink\" title=\"进程模型\"></a>进程模型</h4><blockquote>\n<p>多进程模型<br>独立的工作进程，不共享资源，不加锁</p>\n</blockquote>\n<p><code>master进程</code><br>主进程，充当监控进程。<br>不需要处理网络事件，不负责业务的执行。<br>只负责管理worker进程。</p>\n<p><code>worker进程</code><br>负责处理网络IO。<br>各worker进程竞争来自客户端的请求。<br>多cpu的情况下，设置woker进程的数量等于cpu的核数。<br>Nginx支持将某一个进程绑定在某一个核上。</p>\n<h4 id=\"常用命令\"><a href=\"#常用命令\" class=\"headerlink\" title=\"常用命令\"></a>常用命令</h4><p><code>nginx</code> 启动</p>\n<p><code>nginx -s stop</code> 关闭</p>\n<p><code>ngixn -s relaod</code> 重载配置文件</p>\n<p><code>nginx -t</code> 检查配置文件</p>\n<p><code>nginx -v</code> 查看版本</p>\n<h4 id=\"性能优化\"><a href=\"#性能优化\" class=\"headerlink\" title=\"性能优化\"></a>性能优化</h4><ol>\n<li>worker_processes配置为CPU核数。</li>\n<li>将worker process与指定cpu核绑定。</li>\n<li>关闭访问日志，加快磁盘IO。</li>\n<li>开启gzip，减少网络传输时间。</li>\n<li>worker_rlimit_nofile，更改worker进程的最大打开文件数限制</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>国籍：俄罗斯<br>语言：C语言<br>开源软件，BSD许可<br>跨平台支持Linux和Windows<br>可作为WEB服务器，负载均衡器，邮件代理服务器等</p>\n</blockquote>\n<h4 id=\"优势\"><a href=\"#优势\" class=\"headerlink\" title=\"优势\"></a>优势</h4><p><code>轻量级</code><br>占用更少的内存资源</p>\n<p><code>高并发</code><br>异步非阻塞，epoll模，单机高并发</p>\n<p><code>模块化</code><br>高度模块化的设计，便于扩展</p>\n<p><code>超稳定</code><br>分为主进程，工作进程</p>\n<h4 id=\"为什么高性能\"><a href=\"#为什么高性能\" class=\"headerlink\" title=\"为什么高性能\"></a>为什么高性能</h4><p><code>多进程模型</code><br>nginx默认以多进程的方式工作，一个master进程和多个worker进程，master进程主要用来管理worker进程。<br><code>异步非阻塞</code><br>在epoll支持下，采用异步非阻塞的方式来处理请求，从而实现高并发。</p>\n<h4 id=\"进程模型\"><a href=\"#进程模型\" class=\"headerlink\" title=\"进程模型\"></a>进程模型</h4><blockquote>\n<p>多进程模型<br>独立的工作进程，不共享资源，不加锁</p>\n</blockquote>\n<p><code>master进程</code><br>主进程，充当监控进程。<br>不需要处理网络事件，不负责业务的执行。<br>只负责管理worker进程。</p>\n<p><code>worker进程</code><br>负责处理网络IO。<br>各worker进程竞争来自客户端的请求。<br>多cpu的情况下，设置woker进程的数量等于cpu的核数。<br>Nginx支持将某一个进程绑定在某一个核上。</p>\n<h4 id=\"常用命令\"><a href=\"#常用命令\" class=\"headerlink\" title=\"常用命令\"></a>常用命令</h4><p><code>nginx</code> 启动</p>\n<p><code>nginx -s stop</code> 关闭</p>\n<p><code>ngixn -s relaod</code> 重载配置文件</p>\n<p><code>nginx -t</code> 检查配置文件</p>\n<p><code>nginx -v</code> 查看版本</p>\n<h4 id=\"性能优化\"><a href=\"#性能优化\" class=\"headerlink\" title=\"性能优化\"></a>性能优化</h4><ol>\n<li>worker_processes配置为CPU核数。</li>\n<li>将worker process与指定cpu核绑定。</li>\n<li>关闭访问日志，加快磁盘IO。</li>\n<li>开启gzip，减少网络传输时间。</li>\n<li>worker_rlimit_nofile，更改worker进程的最大打开文件数限制</li>\n</ol>\n"},{"title":"闲扯RESTful","date":"2017-11-11T16:00:00.000Z","_content":"#### 什么是RESTful\n>REST，即Representational State Transfer，表现层状态转化。\n每一个URI代表一种资源。\nhttp的method代表对资源的操作。\nPOST 创建，PUT 更新，GET 获取，DELETE 删除。\n\n\n#### 为什么用RESTful\n>无状态，不用考虑上下文。\n面向资源，具有自解释性。\n\n\n#### 局限性\n`不是所有的请求都是资源`\n例如订单的状态变更接口，难以使用RESTful去描述接口。\n\n`批量删除`\nDELETE /tickets/12 #单条删除ticekt 12\n使用RESTful风格如何定义批量删除？\n\n`批量查询URL长度问题`\nRESTful要求使用get获取资源。\n批量查询时，参数过长，url长度超过了get方法的url最大值。\n\n`增加接口切面定义难度`\nurl路径参数，增加了接口切面的定义难度。","source":"_posts/闲扯RESTful.md","raw":"---\ntitle: 闲扯RESTful\ncategories:\n- 方法论\ndate: 2017-11-12\ntags:\n- TDD\n---\n#### 什么是RESTful\n>REST，即Representational State Transfer，表现层状态转化。\n每一个URI代表一种资源。\nhttp的method代表对资源的操作。\nPOST 创建，PUT 更新，GET 获取，DELETE 删除。\n\n\n#### 为什么用RESTful\n>无状态，不用考虑上下文。\n面向资源，具有自解释性。\n\n\n#### 局限性\n`不是所有的请求都是资源`\n例如订单的状态变更接口，难以使用RESTful去描述接口。\n\n`批量删除`\nDELETE /tickets/12 #单条删除ticekt 12\n使用RESTful风格如何定义批量删除？\n\n`批量查询URL长度问题`\nRESTful要求使用get获取资源。\n批量查询时，参数过长，url长度超过了get方法的url最大值。\n\n`增加接口切面定义难度`\nurl路径参数，增加了接口切面的定义难度。","slug":"闲扯RESTful","published":1,"updated":"2018-12-25T01:48:15.332Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjwq2jfek002oqxpjh922rgom","content":"<h4 id=\"什么是RESTful\"><a href=\"#什么是RESTful\" class=\"headerlink\" title=\"什么是RESTful\"></a>什么是RESTful</h4><blockquote>\n<p>REST，即Representational State Transfer，表现层状态转化。<br>每一个URI代表一种资源。<br>http的method代表对资源的操作。<br>POST 创建，PUT 更新，GET 获取，DELETE 删除。</p>\n</blockquote>\n<h4 id=\"为什么用RESTful\"><a href=\"#为什么用RESTful\" class=\"headerlink\" title=\"为什么用RESTful\"></a>为什么用RESTful</h4><blockquote>\n<p>无状态，不用考虑上下文。<br>面向资源，具有自解释性。</p>\n</blockquote>\n<h4 id=\"局限性\"><a href=\"#局限性\" class=\"headerlink\" title=\"局限性\"></a>局限性</h4><p><code>不是所有的请求都是资源</code><br>例如订单的状态变更接口，难以使用RESTful去描述接口。</p>\n<p><code>批量删除</code><br>DELETE /tickets/12 #单条删除ticekt 12<br>使用RESTful风格如何定义批量删除？</p>\n<p><code>批量查询URL长度问题</code><br>RESTful要求使用get获取资源。<br>批量查询时，参数过长，url长度超过了get方法的url最大值。</p>\n<p><code>增加接口切面定义难度</code><br>url路径参数，增加了接口切面的定义难度。</p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"什么是RESTful\"><a href=\"#什么是RESTful\" class=\"headerlink\" title=\"什么是RESTful\"></a>什么是RESTful</h4><blockquote>\n<p>REST，即Representational State Transfer，表现层状态转化。<br>每一个URI代表一种资源。<br>http的method代表对资源的操作。<br>POST 创建，PUT 更新，GET 获取，DELETE 删除。</p>\n</blockquote>\n<h4 id=\"为什么用RESTful\"><a href=\"#为什么用RESTful\" class=\"headerlink\" title=\"为什么用RESTful\"></a>为什么用RESTful</h4><blockquote>\n<p>无状态，不用考虑上下文。<br>面向资源，具有自解释性。</p>\n</blockquote>\n<h4 id=\"局限性\"><a href=\"#局限性\" class=\"headerlink\" title=\"局限性\"></a>局限性</h4><p><code>不是所有的请求都是资源</code><br>例如订单的状态变更接口，难以使用RESTful去描述接口。</p>\n<p><code>批量删除</code><br>DELETE /tickets/12 #单条删除ticekt 12<br>使用RESTful风格如何定义批量删除？</p>\n<p><code>批量查询URL长度问题</code><br>RESTful要求使用get获取资源。<br>批量查询时，参数过长，url长度超过了get方法的url最大值。</p>\n<p><code>增加接口切面定义难度</code><br>url路径参数，增加了接口切面的定义难度。</p>\n"},{"title":"闲扯TDD","date":"2018-08-12T16:00:00.000Z","_content":">Test-driven development，缩写为TDD，测试驱动开发。\n>测试驱动代码的设计和功能的实现。\n>测试驱动代码的再设计和重构。\n\n#### 优势\n\n`改进设计`\n保障代码可测试性的同时，降低了代码的耦合度，使代码设计得到不断的改进。\n\n`可运行的文档`\n为功能代码提供了良好的文档，并能维护代码和文档的同步。测试用例集就是一份准备可靠，且能运行的文档。\n\n`自动回归测试`\nTDD的测试用例集则是自动可回归的。\n\n#### 局限\n`增加开发时间`\n编写测试用例，增加的编码量，延长了开发时间","source":"_posts/闲扯TDD.md","raw":"---\ntitle: 闲扯TDD\ncategories:\n- 方法论\ndate: 2018-08-13\ntags:\n- TDD\n---\n>Test-driven development，缩写为TDD，测试驱动开发。\n>测试驱动代码的设计和功能的实现。\n>测试驱动代码的再设计和重构。\n\n#### 优势\n\n`改进设计`\n保障代码可测试性的同时，降低了代码的耦合度，使代码设计得到不断的改进。\n\n`可运行的文档`\n为功能代码提供了良好的文档，并能维护代码和文档的同步。测试用例集就是一份准备可靠，且能运行的文档。\n\n`自动回归测试`\nTDD的测试用例集则是自动可回归的。\n\n#### 局限\n`增加开发时间`\n编写测试用例，增加的编码量，延长了开发时间","slug":"闲扯TDD","published":1,"updated":"2018-12-25T01:48:15.061Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjwq2jfen002tqxpjk8pcf6bz","content":"<blockquote>\n<p>Test-driven development，缩写为TDD，测试驱动开发。<br>测试驱动代码的设计和功能的实现。<br>测试驱动代码的再设计和重构。</p>\n</blockquote>\n<h4 id=\"优势\"><a href=\"#优势\" class=\"headerlink\" title=\"优势\"></a>优势</h4><p><code>改进设计</code><br>保障代码可测试性的同时，降低了代码的耦合度，使代码设计得到不断的改进。</p>\n<p><code>可运行的文档</code><br>为功能代码提供了良好的文档，并能维护代码和文档的同步。测试用例集就是一份准备可靠，且能运行的文档。</p>\n<p><code>自动回归测试</code><br>TDD的测试用例集则是自动可回归的。</p>\n<h4 id=\"局限\"><a href=\"#局限\" class=\"headerlink\" title=\"局限\"></a>局限</h4><p><code>增加开发时间</code><br>编写测试用例，增加的编码量，延长了开发时间</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>Test-driven development，缩写为TDD，测试驱动开发。<br>测试驱动代码的设计和功能的实现。<br>测试驱动代码的再设计和重构。</p>\n</blockquote>\n<h4 id=\"优势\"><a href=\"#优势\" class=\"headerlink\" title=\"优势\"></a>优势</h4><p><code>改进设计</code><br>保障代码可测试性的同时，降低了代码的耦合度，使代码设计得到不断的改进。</p>\n<p><code>可运行的文档</code><br>为功能代码提供了良好的文档，并能维护代码和文档的同步。测试用例集就是一份准备可靠，且能运行的文档。</p>\n<p><code>自动回归测试</code><br>TDD的测试用例集则是自动可回归的。</p>\n<h4 id=\"局限\"><a href=\"#局限\" class=\"headerlink\" title=\"局限\"></a>局限</h4><p><code>增加开发时间</code><br>编写测试用例，增加的编码量，延长了开发时间</p>\n"},{"title":"闲扯常用设计模式","date":"2017-08-04T16:00:00.000Z","_content":"#### 单例模式\n\n`定义`\n保证一个类仅有一个实例，并提供一个访问它的全局访问点。\n\n`优点`\n在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例。\n\n`案例`\n```\n//在一个JVM中，Runtime的实例应该只有一个\nRuntime.getRuntime()\n```\n\n#### 工厂模式\n`定义`\n只关心要什么，不关心他的实现和创建。\n\n`优点`\n解耦对象的创建和使用。\n\n`案例`\n```\njava.nio.charset.Charset#forName()\n```\n\n#### 代理模式\n`定义`\n代理对象来执行目标对象的方法，并在代理对象中增强目标对象。\n\n`优点`\n开放关闭原则。\n\n`案例`\n```\nCGLib动态代理\n```\n\n#### 命令模式\n`定义`\n把一个请求或者操作封装到一个对象中。\n\n`优点`\n方便命令的扩展，便于命令的统一管理。\n\n`案例`\n```\nLambda表达式\n```\n\n#### 策略模式\n`定义`\n创建表示各种策略的对象，和一个context 对象。\n策略对象改变 context 对象的执行算法。\n\n`优点`\n算法可以自由切换。\n避免使用多重条件判断\n\n`案例`\n```\njava.util.Comparator\n```\n\n#### 观察者模式\n`定义`\n当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。\n\n`优点`\n解耦观察者和被观察者。\n低耦合、高内聚设计原则。\n\n#### 门面模式\n`定义`\n为子系统中的一组接口提供一个一致的界面，定义了一个高层接口。\n\n`优点`\n方便调用者进行接口调用，简化调用流程。\n\n\n","source":"_posts/闲扯常用设计模式.md","raw":"---\ntitle: 闲扯常用设计模式\ncategories:\n- 方法论\ndate: 2017-08-05 \ntags:\n- 设计模式\n---\n#### 单例模式\n\n`定义`\n保证一个类仅有一个实例，并提供一个访问它的全局访问点。\n\n`优点`\n在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例。\n\n`案例`\n```\n//在一个JVM中，Runtime的实例应该只有一个\nRuntime.getRuntime()\n```\n\n#### 工厂模式\n`定义`\n只关心要什么，不关心他的实现和创建。\n\n`优点`\n解耦对象的创建和使用。\n\n`案例`\n```\njava.nio.charset.Charset#forName()\n```\n\n#### 代理模式\n`定义`\n代理对象来执行目标对象的方法，并在代理对象中增强目标对象。\n\n`优点`\n开放关闭原则。\n\n`案例`\n```\nCGLib动态代理\n```\n\n#### 命令模式\n`定义`\n把一个请求或者操作封装到一个对象中。\n\n`优点`\n方便命令的扩展，便于命令的统一管理。\n\n`案例`\n```\nLambda表达式\n```\n\n#### 策略模式\n`定义`\n创建表示各种策略的对象，和一个context 对象。\n策略对象改变 context 对象的执行算法。\n\n`优点`\n算法可以自由切换。\n避免使用多重条件判断\n\n`案例`\n```\njava.util.Comparator\n```\n\n#### 观察者模式\n`定义`\n当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。\n\n`优点`\n解耦观察者和被观察者。\n低耦合、高内聚设计原则。\n\n#### 门面模式\n`定义`\n为子系统中的一组接口提供一个一致的界面，定义了一个高层接口。\n\n`优点`\n方便调用者进行接口调用，简化调用流程。\n\n\n","slug":"闲扯常用设计模式","published":1,"updated":"2018-12-25T01:48:15.108Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjwq2jfer002wqxpjmal7c1cp","content":"<h4 id=\"单例模式\"><a href=\"#单例模式\" class=\"headerlink\" title=\"单例模式\"></a>单例模式</h4><p><code>定义</code><br>保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p>\n<p><code>优点</code><br>在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例。</p>\n<p><code>案例</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//在一个JVM中，Runtime的实例应该只有一个</span><br><span class=\"line\">Runtime.getRuntime()</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"工厂模式\"><a href=\"#工厂模式\" class=\"headerlink\" title=\"工厂模式\"></a>工厂模式</h4><p><code>定义</code><br>只关心要什么，不关心他的实现和创建。</p>\n<p><code>优点</code><br>解耦对象的创建和使用。</p>\n<p><code>案例</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">java.nio.charset.Charset#forName()</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"代理模式\"><a href=\"#代理模式\" class=\"headerlink\" title=\"代理模式\"></a>代理模式</h4><p><code>定义</code><br>代理对象来执行目标对象的方法，并在代理对象中增强目标对象。</p>\n<p><code>优点</code><br>开放关闭原则。</p>\n<p><code>案例</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CGLib动态代理</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"命令模式\"><a href=\"#命令模式\" class=\"headerlink\" title=\"命令模式\"></a>命令模式</h4><p><code>定义</code><br>把一个请求或者操作封装到一个对象中。</p>\n<p><code>优点</code><br>方便命令的扩展，便于命令的统一管理。</p>\n<p><code>案例</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Lambda表达式</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"策略模式\"><a href=\"#策略模式\" class=\"headerlink\" title=\"策略模式\"></a>策略模式</h4><p><code>定义</code><br>创建表示各种策略的对象，和一个context 对象。<br>策略对象改变 context 对象的执行算法。</p>\n<p><code>优点</code><br>算法可以自由切换。<br>避免使用多重条件判断</p>\n<p><code>案例</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">java.util.Comparator</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"观察者模式\"><a href=\"#观察者模式\" class=\"headerlink\" title=\"观察者模式\"></a>观察者模式</h4><p><code>定义</code><br>当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。</p>\n<p><code>优点</code><br>解耦观察者和被观察者。<br>低耦合、高内聚设计原则。</p>\n<h4 id=\"门面模式\"><a href=\"#门面模式\" class=\"headerlink\" title=\"门面模式\"></a>门面模式</h4><p><code>定义</code><br>为子系统中的一组接口提供一个一致的界面，定义了一个高层接口。</p>\n<p><code>优点</code><br>方便调用者进行接口调用，简化调用流程。</p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"单例模式\"><a href=\"#单例模式\" class=\"headerlink\" title=\"单例模式\"></a>单例模式</h4><p><code>定义</code><br>保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p>\n<p><code>优点</code><br>在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例。</p>\n<p><code>案例</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//在一个JVM中，Runtime的实例应该只有一个</span><br><span class=\"line\">Runtime.getRuntime()</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"工厂模式\"><a href=\"#工厂模式\" class=\"headerlink\" title=\"工厂模式\"></a>工厂模式</h4><p><code>定义</code><br>只关心要什么，不关心他的实现和创建。</p>\n<p><code>优点</code><br>解耦对象的创建和使用。</p>\n<p><code>案例</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">java.nio.charset.Charset#forName()</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"代理模式\"><a href=\"#代理模式\" class=\"headerlink\" title=\"代理模式\"></a>代理模式</h4><p><code>定义</code><br>代理对象来执行目标对象的方法，并在代理对象中增强目标对象。</p>\n<p><code>优点</code><br>开放关闭原则。</p>\n<p><code>案例</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CGLib动态代理</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"命令模式\"><a href=\"#命令模式\" class=\"headerlink\" title=\"命令模式\"></a>命令模式</h4><p><code>定义</code><br>把一个请求或者操作封装到一个对象中。</p>\n<p><code>优点</code><br>方便命令的扩展，便于命令的统一管理。</p>\n<p><code>案例</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Lambda表达式</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"策略模式\"><a href=\"#策略模式\" class=\"headerlink\" title=\"策略模式\"></a>策略模式</h4><p><code>定义</code><br>创建表示各种策略的对象，和一个context 对象。<br>策略对象改变 context 对象的执行算法。</p>\n<p><code>优点</code><br>算法可以自由切换。<br>避免使用多重条件判断</p>\n<p><code>案例</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">java.util.Comparator</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"观察者模式\"><a href=\"#观察者模式\" class=\"headerlink\" title=\"观察者模式\"></a>观察者模式</h4><p><code>定义</code><br>当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。</p>\n<p><code>优点</code><br>解耦观察者和被观察者。<br>低耦合、高内聚设计原则。</p>\n<h4 id=\"门面模式\"><a href=\"#门面模式\" class=\"headerlink\" title=\"门面模式\"></a>门面模式</h4><p><code>定义</code><br>为子系统中的一组接口提供一个一致的界面，定义了一个高层接口。</p>\n<p><code>优点</code><br>方便调用者进行接口调用，简化调用流程。</p>\n"},{"title":"闲扯微服务","date":"2018-02-14T16:00:00.000Z","_content":">微服务，就是`协同工作`，`小而自制`的服务。\n>SOA架构强调的是异构系统之间的通信和解耦合。\n>微服务架构强调的是系统按业务边界做细粒度的拆分和部署。\n>Dubbo和Spring Cloud是框架和组件，SOA和微服务是架构思想。\n>\n\n#### 单体架构痛点\n`项目过于臃肿`\n当大大小小的功能模块都集中在同一项目的时候，整个项目必然会变得臃肿，让开发者难以维护。\n\n`资源无法隔离`\n就像刚刚小灰的经历一样，整个单体系统的各个功能模块都依赖于同样的数据库、内存等资源，一旦某个功能模块对资源使用不当，整个系统都会被拖垮。\n\n`无法灵活扩展`\n当系统的访问量越来越大的时候，单体系统固然可以进行水平扩展，部署在多台机器上组成集群。但是这种扩展并非灵活的扩展。比如我们现在的性能瓶颈是支付模块，希望只针对支付模块做水平扩展，这一点在单体系统是做不到的。\n\n#### 优势\n`技术异构`\n不必使用相同的编程语言和技术栈，不同的服务选用最适合自己的技术栈。\n\n`资源隔离`\n有效避免了服务之间争用数据库和缓存资源所带来的问题，实现了服务器资源（内存、CPU资源等）的有效隔离。\n\n`灵活扩展`\n微服务是以每一个独立组件（例如用户服务，商品服务）为单位进行独立部署，每个服务可以根据业务进行灵活扩展。\n\n#### 局限性\n`增加开发复杂度`\n原有的进程内接口调用，变成RESTful接口调用。\n\n`增加测试复杂度`\n测试依赖其他服务，需要部署其他微服务支撑测试。\n\n`增加运维难度`\n原有的单个进程部署，现在需要多个微服务进程，和其他微服务支撑组件部署。\n\n`增加BUG排查难度`\n单个业务请求，贯穿多个微服务，需要跟踪多个微服务才能排查问题。\n\n`数据一致性`\n为了保证服务间的数据一致性，需要引入分布式事务和补偿机制。\n\n#### 核心组件\n\n`路由网关`\n提供动态路由,监控,弹性,安全等边缘服务的框架\n\n`服务注册中心`\n用于定位服务，以实现云端中间层服务发现和故障转移。\n\n`配置中心`\n可以把配置放到远程服务器，集中化管理集群配置。\n\n`断路器`\n通过熔断机制控制服务和第三方库的节点,从而对延迟和故障提供更强大的容错能力。\n\n#### 分布式事务\n\n`CAP原则`\n指的是在一个分布式系统中， Consistency（一致性）、 Availability（可用性）、Partition tolerance（分区容错性），三者不可得兼。\n\n`BASE理论`\nBASE是Basically Available（基本可用）、Soft state（软状态）和Eventually consistent（最终一致性）三个短语的简写。\n\n`2PC两阶段提交`\n2PC顾名思义分为两个阶段，其实施思路可概括为：\n（1）投票阶段（voting phase）：参与者将操作结果通知协调者；\n（2）提交阶段（commit phase）：收到参与者的通知后，协调者再向参与者发出通知，根据反馈情况决定各参与者是否要提交还是回滚；\n 实现复杂，牺牲了可用性，对性能影响较大，不适合高并发高性能场景\n\n`TCC补偿事务`\nTry 阶段主要是对业务系统做检测及资源预留。\nConfirm 阶段主要是对业务系统做确认提交，Try阶段执行成功并开始执行 Confirm阶段时，默认 Confirm阶段是不会出错的。即：只要Try成功，Confirm一定成功。\nCancel 阶段主要是在业务执行错误，需要回滚的状态下执行的业务取消，预留资源释放。\n\n`本地消息表`\n消息生产方，需要额外建一个消息表，并记录消息发送状态。消息表和业务数据要在一个事务里提交，也就是说他们要在一个数据库里面。然后消息会经过MQ发送到消息的消费方。如果消息发送失败，会进行重试发送。\n遵循BASE理论，采用的是最终一致性。\n\n`事务消息`\n有一些第三方的MQ是支持事务消息的，比如RocketMQ，他们支持事务消息的方式也是类似于采用的二阶段提交。\n\n","source":"_posts/闲扯微服务.md","raw":"---\ntitle: 闲扯微服务\ncategories:\n- 方法论\ndate: 2018-02-15 \ntags:\n- 微服务\n---\n>微服务，就是`协同工作`，`小而自制`的服务。\n>SOA架构强调的是异构系统之间的通信和解耦合。\n>微服务架构强调的是系统按业务边界做细粒度的拆分和部署。\n>Dubbo和Spring Cloud是框架和组件，SOA和微服务是架构思想。\n>\n\n#### 单体架构痛点\n`项目过于臃肿`\n当大大小小的功能模块都集中在同一项目的时候，整个项目必然会变得臃肿，让开发者难以维护。\n\n`资源无法隔离`\n就像刚刚小灰的经历一样，整个单体系统的各个功能模块都依赖于同样的数据库、内存等资源，一旦某个功能模块对资源使用不当，整个系统都会被拖垮。\n\n`无法灵活扩展`\n当系统的访问量越来越大的时候，单体系统固然可以进行水平扩展，部署在多台机器上组成集群。但是这种扩展并非灵活的扩展。比如我们现在的性能瓶颈是支付模块，希望只针对支付模块做水平扩展，这一点在单体系统是做不到的。\n\n#### 优势\n`技术异构`\n不必使用相同的编程语言和技术栈，不同的服务选用最适合自己的技术栈。\n\n`资源隔离`\n有效避免了服务之间争用数据库和缓存资源所带来的问题，实现了服务器资源（内存、CPU资源等）的有效隔离。\n\n`灵活扩展`\n微服务是以每一个独立组件（例如用户服务，商品服务）为单位进行独立部署，每个服务可以根据业务进行灵活扩展。\n\n#### 局限性\n`增加开发复杂度`\n原有的进程内接口调用，变成RESTful接口调用。\n\n`增加测试复杂度`\n测试依赖其他服务，需要部署其他微服务支撑测试。\n\n`增加运维难度`\n原有的单个进程部署，现在需要多个微服务进程，和其他微服务支撑组件部署。\n\n`增加BUG排查难度`\n单个业务请求，贯穿多个微服务，需要跟踪多个微服务才能排查问题。\n\n`数据一致性`\n为了保证服务间的数据一致性，需要引入分布式事务和补偿机制。\n\n#### 核心组件\n\n`路由网关`\n提供动态路由,监控,弹性,安全等边缘服务的框架\n\n`服务注册中心`\n用于定位服务，以实现云端中间层服务发现和故障转移。\n\n`配置中心`\n可以把配置放到远程服务器，集中化管理集群配置。\n\n`断路器`\n通过熔断机制控制服务和第三方库的节点,从而对延迟和故障提供更强大的容错能力。\n\n#### 分布式事务\n\n`CAP原则`\n指的是在一个分布式系统中， Consistency（一致性）、 Availability（可用性）、Partition tolerance（分区容错性），三者不可得兼。\n\n`BASE理论`\nBASE是Basically Available（基本可用）、Soft state（软状态）和Eventually consistent（最终一致性）三个短语的简写。\n\n`2PC两阶段提交`\n2PC顾名思义分为两个阶段，其实施思路可概括为：\n（1）投票阶段（voting phase）：参与者将操作结果通知协调者；\n（2）提交阶段（commit phase）：收到参与者的通知后，协调者再向参与者发出通知，根据反馈情况决定各参与者是否要提交还是回滚；\n 实现复杂，牺牲了可用性，对性能影响较大，不适合高并发高性能场景\n\n`TCC补偿事务`\nTry 阶段主要是对业务系统做检测及资源预留。\nConfirm 阶段主要是对业务系统做确认提交，Try阶段执行成功并开始执行 Confirm阶段时，默认 Confirm阶段是不会出错的。即：只要Try成功，Confirm一定成功。\nCancel 阶段主要是在业务执行错误，需要回滚的状态下执行的业务取消，预留资源释放。\n\n`本地消息表`\n消息生产方，需要额外建一个消息表，并记录消息发送状态。消息表和业务数据要在一个事务里提交，也就是说他们要在一个数据库里面。然后消息会经过MQ发送到消息的消费方。如果消息发送失败，会进行重试发送。\n遵循BASE理论，采用的是最终一致性。\n\n`事务消息`\n有一些第三方的MQ是支持事务消息的，比如RocketMQ，他们支持事务消息的方式也是类似于采用的二阶段提交。\n\n","slug":"闲扯微服务","published":1,"updated":"2018-12-25T01:48:15.705Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjwq2jff2002zqxpjmrbbio85","content":"<blockquote>\n<p>微服务，就是<code>协同工作</code>，<code>小而自制</code>的服务。<br>SOA架构强调的是异构系统之间的通信和解耦合。<br>微服务架构强调的是系统按业务边界做细粒度的拆分和部署。<br>Dubbo和Spring Cloud是框架和组件，SOA和微服务是架构思想。</p>\n</blockquote>\n<h4 id=\"单体架构痛点\"><a href=\"#单体架构痛点\" class=\"headerlink\" title=\"单体架构痛点\"></a>单体架构痛点</h4><p><code>项目过于臃肿</code><br>当大大小小的功能模块都集中在同一项目的时候，整个项目必然会变得臃肿，让开发者难以维护。</p>\n<p><code>资源无法隔离</code><br>就像刚刚小灰的经历一样，整个单体系统的各个功能模块都依赖于同样的数据库、内存等资源，一旦某个功能模块对资源使用不当，整个系统都会被拖垮。</p>\n<p><code>无法灵活扩展</code><br>当系统的访问量越来越大的时候，单体系统固然可以进行水平扩展，部署在多台机器上组成集群。但是这种扩展并非灵活的扩展。比如我们现在的性能瓶颈是支付模块，希望只针对支付模块做水平扩展，这一点在单体系统是做不到的。</p>\n<h4 id=\"优势\"><a href=\"#优势\" class=\"headerlink\" title=\"优势\"></a>优势</h4><p><code>技术异构</code><br>不必使用相同的编程语言和技术栈，不同的服务选用最适合自己的技术栈。</p>\n<p><code>资源隔离</code><br>有效避免了服务之间争用数据库和缓存资源所带来的问题，实现了服务器资源（内存、CPU资源等）的有效隔离。</p>\n<p><code>灵活扩展</code><br>微服务是以每一个独立组件（例如用户服务，商品服务）为单位进行独立部署，每个服务可以根据业务进行灵活扩展。</p>\n<h4 id=\"局限性\"><a href=\"#局限性\" class=\"headerlink\" title=\"局限性\"></a>局限性</h4><p><code>增加开发复杂度</code><br>原有的进程内接口调用，变成RESTful接口调用。</p>\n<p><code>增加测试复杂度</code><br>测试依赖其他服务，需要部署其他微服务支撑测试。</p>\n<p><code>增加运维难度</code><br>原有的单个进程部署，现在需要多个微服务进程，和其他微服务支撑组件部署。</p>\n<p><code>增加BUG排查难度</code><br>单个业务请求，贯穿多个微服务，需要跟踪多个微服务才能排查问题。</p>\n<p><code>数据一致性</code><br>为了保证服务间的数据一致性，需要引入分布式事务和补偿机制。</p>\n<h4 id=\"核心组件\"><a href=\"#核心组件\" class=\"headerlink\" title=\"核心组件\"></a>核心组件</h4><p><code>路由网关</code><br>提供动态路由,监控,弹性,安全等边缘服务的框架</p>\n<p><code>服务注册中心</code><br>用于定位服务，以实现云端中间层服务发现和故障转移。</p>\n<p><code>配置中心</code><br>可以把配置放到远程服务器，集中化管理集群配置。</p>\n<p><code>断路器</code><br>通过熔断机制控制服务和第三方库的节点,从而对延迟和故障提供更强大的容错能力。</p>\n<h4 id=\"分布式事务\"><a href=\"#分布式事务\" class=\"headerlink\" title=\"分布式事务\"></a>分布式事务</h4><p><code>CAP原则</code><br>指的是在一个分布式系统中， Consistency（一致性）、 Availability（可用性）、Partition tolerance（分区容错性），三者不可得兼。</p>\n<p><code>BASE理论</code><br>BASE是Basically Available（基本可用）、Soft state（软状态）和Eventually consistent（最终一致性）三个短语的简写。</p>\n<p><code>2PC两阶段提交</code><br>2PC顾名思义分为两个阶段，其实施思路可概括为：<br>（1）投票阶段（voting phase）：参与者将操作结果通知协调者；<br>（2）提交阶段（commit phase）：收到参与者的通知后，协调者再向参与者发出通知，根据反馈情况决定各参与者是否要提交还是回滚；<br> 实现复杂，牺牲了可用性，对性能影响较大，不适合高并发高性能场景</p>\n<p><code>TCC补偿事务</code><br>Try 阶段主要是对业务系统做检测及资源预留。<br>Confirm 阶段主要是对业务系统做确认提交，Try阶段执行成功并开始执行 Confirm阶段时，默认 Confirm阶段是不会出错的。即：只要Try成功，Confirm一定成功。<br>Cancel 阶段主要是在业务执行错误，需要回滚的状态下执行的业务取消，预留资源释放。</p>\n<p><code>本地消息表</code><br>消息生产方，需要额外建一个消息表，并记录消息发送状态。消息表和业务数据要在一个事务里提交，也就是说他们要在一个数据库里面。然后消息会经过MQ发送到消息的消费方。如果消息发送失败，会进行重试发送。<br>遵循BASE理论，采用的是最终一致性。</p>\n<p><code>事务消息</code><br>有一些第三方的MQ是支持事务消息的，比如RocketMQ，他们支持事务消息的方式也是类似于采用的二阶段提交。</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>微服务，就是<code>协同工作</code>，<code>小而自制</code>的服务。<br>SOA架构强调的是异构系统之间的通信和解耦合。<br>微服务架构强调的是系统按业务边界做细粒度的拆分和部署。<br>Dubbo和Spring Cloud是框架和组件，SOA和微服务是架构思想。</p>\n</blockquote>\n<h4 id=\"单体架构痛点\"><a href=\"#单体架构痛点\" class=\"headerlink\" title=\"单体架构痛点\"></a>单体架构痛点</h4><p><code>项目过于臃肿</code><br>当大大小小的功能模块都集中在同一项目的时候，整个项目必然会变得臃肿，让开发者难以维护。</p>\n<p><code>资源无法隔离</code><br>就像刚刚小灰的经历一样，整个单体系统的各个功能模块都依赖于同样的数据库、内存等资源，一旦某个功能模块对资源使用不当，整个系统都会被拖垮。</p>\n<p><code>无法灵活扩展</code><br>当系统的访问量越来越大的时候，单体系统固然可以进行水平扩展，部署在多台机器上组成集群。但是这种扩展并非灵活的扩展。比如我们现在的性能瓶颈是支付模块，希望只针对支付模块做水平扩展，这一点在单体系统是做不到的。</p>\n<h4 id=\"优势\"><a href=\"#优势\" class=\"headerlink\" title=\"优势\"></a>优势</h4><p><code>技术异构</code><br>不必使用相同的编程语言和技术栈，不同的服务选用最适合自己的技术栈。</p>\n<p><code>资源隔离</code><br>有效避免了服务之间争用数据库和缓存资源所带来的问题，实现了服务器资源（内存、CPU资源等）的有效隔离。</p>\n<p><code>灵活扩展</code><br>微服务是以每一个独立组件（例如用户服务，商品服务）为单位进行独立部署，每个服务可以根据业务进行灵活扩展。</p>\n<h4 id=\"局限性\"><a href=\"#局限性\" class=\"headerlink\" title=\"局限性\"></a>局限性</h4><p><code>增加开发复杂度</code><br>原有的进程内接口调用，变成RESTful接口调用。</p>\n<p><code>增加测试复杂度</code><br>测试依赖其他服务，需要部署其他微服务支撑测试。</p>\n<p><code>增加运维难度</code><br>原有的单个进程部署，现在需要多个微服务进程，和其他微服务支撑组件部署。</p>\n<p><code>增加BUG排查难度</code><br>单个业务请求，贯穿多个微服务，需要跟踪多个微服务才能排查问题。</p>\n<p><code>数据一致性</code><br>为了保证服务间的数据一致性，需要引入分布式事务和补偿机制。</p>\n<h4 id=\"核心组件\"><a href=\"#核心组件\" class=\"headerlink\" title=\"核心组件\"></a>核心组件</h4><p><code>路由网关</code><br>提供动态路由,监控,弹性,安全等边缘服务的框架</p>\n<p><code>服务注册中心</code><br>用于定位服务，以实现云端中间层服务发现和故障转移。</p>\n<p><code>配置中心</code><br>可以把配置放到远程服务器，集中化管理集群配置。</p>\n<p><code>断路器</code><br>通过熔断机制控制服务和第三方库的节点,从而对延迟和故障提供更强大的容错能力。</p>\n<h4 id=\"分布式事务\"><a href=\"#分布式事务\" class=\"headerlink\" title=\"分布式事务\"></a>分布式事务</h4><p><code>CAP原则</code><br>指的是在一个分布式系统中， Consistency（一致性）、 Availability（可用性）、Partition tolerance（分区容错性），三者不可得兼。</p>\n<p><code>BASE理论</code><br>BASE是Basically Available（基本可用）、Soft state（软状态）和Eventually consistent（最终一致性）三个短语的简写。</p>\n<p><code>2PC两阶段提交</code><br>2PC顾名思义分为两个阶段，其实施思路可概括为：<br>（1）投票阶段（voting phase）：参与者将操作结果通知协调者；<br>（2）提交阶段（commit phase）：收到参与者的通知后，协调者再向参与者发出通知，根据反馈情况决定各参与者是否要提交还是回滚；<br> 实现复杂，牺牲了可用性，对性能影响较大，不适合高并发高性能场景</p>\n<p><code>TCC补偿事务</code><br>Try 阶段主要是对业务系统做检测及资源预留。<br>Confirm 阶段主要是对业务系统做确认提交，Try阶段执行成功并开始执行 Confirm阶段时，默认 Confirm阶段是不会出错的。即：只要Try成功，Confirm一定成功。<br>Cancel 阶段主要是在业务执行错误，需要回滚的状态下执行的业务取消，预留资源释放。</p>\n<p><code>本地消息表</code><br>消息生产方，需要额外建一个消息表，并记录消息发送状态。消息表和业务数据要在一个事务里提交，也就是说他们要在一个数据库里面。然后消息会经过MQ发送到消息的消费方。如果消息发送失败，会进行重试发送。<br>遵循BASE理论，采用的是最终一致性。</p>\n<p><code>事务消息</code><br>有一些第三方的MQ是支持事务消息的，比如RocketMQ，他们支持事务消息的方式也是类似于采用的二阶段提交。</p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cjwq2jfc40000qxpj419y67ku","category_id":"cjwq2jfch0002qxpjt85msnvj","_id":"cjwq2jfcx000cqxpjno1hb62a"},{"post_id":"cjwq2jfcc0001qxpj0aji22jt","category_id":"cjwq2jfco0007qxpj8x2li7l7","_id":"cjwq2jfd5000jqxpjujbqwv77"},{"post_id":"cjwq2jfck0004qxpjxebkb0nn","category_id":"cjwq2jfco0007qxpj8x2li7l7","_id":"cjwq2jfda000oqxpj4olpcwww"},{"post_id":"cjwq2jfd5000lqxpjrskb6gr4","category_id":"cjwq2jfd4000iqxpjwi1bbbqc","_id":"cjwq2jfdd000vqxpj7qwtq9vj"},{"post_id":"cjwq2jfcm0005qxpjcc6a00yq","category_id":"cjwq2jfd4000iqxpjwi1bbbqc","_id":"cjwq2jfdf000zqxpjyhhncojn"},{"post_id":"cjwq2jfd7000nqxpjadn1o9m9","category_id":"cjwq2jfd4000iqxpjwi1bbbqc","_id":"cjwq2jfdh0012qxpjexajty03"},{"post_id":"cjwq2jfdb000sqxpjmkm700au","category_id":"cjwq2jfd4000iqxpjwi1bbbqc","_id":"cjwq2jfdi0016qxpj5w6kxmp6"},{"post_id":"cjwq2jfcn0006qxpjcdp4t2u7","category_id":"cjwq2jfd4000iqxpjwi1bbbqc","_id":"cjwq2jfdl0019qxpjgzgekeda"},{"post_id":"cjwq2jfdd000uqxpjfpk1g19i","category_id":"cjwq2jfd4000iqxpjwi1bbbqc","_id":"cjwq2jfdn001dqxpjt3rihi8l"},{"post_id":"cjwq2jfde000yqxpj4244zgd6","category_id":"cjwq2jfd4000iqxpjwi1bbbqc","_id":"cjwq2jfdq001gqxpj16yeq005"},{"post_id":"cjwq2jfcp000aqxpjju0h66hc","category_id":"cjwq2jfd4000iqxpjwi1bbbqc","_id":"cjwq2jfdu001lqxpjzqtbjxxs"},{"post_id":"cjwq2jfdg0011qxpjasiwm64s","category_id":"cjwq2jfco0007qxpj8x2li7l7","_id":"cjwq2jfdv001oqxpjhzslxfq2"},{"post_id":"cjwq2jfcr000bqxpjt8n76jzs","category_id":"cjwq2jfd4000iqxpjwi1bbbqc","_id":"cjwq2jfdy001sqxpj0tsjelx7"},{"post_id":"cjwq2jfd0000fqxpjeni252iv","category_id":"cjwq2jfd4000iqxpjwi1bbbqc","_id":"cjwq2jfe0001vqxpjj8wyv9wv"},{"post_id":"cjwq2jfd2000hqxpja2l8gcpa","category_id":"cjwq2jfd4000iqxpjwi1bbbqc","_id":"cjwq2jfe2001yqxpjrvkljj1b"},{"post_id":"cjwq2jfdv001nqxpj9d5k4uaa","category_id":"cjwq2jfco0007qxpj8x2li7l7","_id":"cjwq2jfe50022qxpjesexysuy"},{"post_id":"cjwq2jfdx001rqxpjso0iahu3","category_id":"cjwq2jfco0007qxpj8x2li7l7","_id":"cjwq2jfe70024qxpjfq9shxgu"},{"post_id":"cjwq2jfdi0015qxpjx947kl52","category_id":"cjwq2jfdw001pqxpjevo1jptv","_id":"cjwq2jfea0029qxpjgqoajsh9"},{"post_id":"cjwq2jfe1001xqxpj0or3z00o","category_id":"cjwq2jfdw001pqxpjevo1jptv","_id":"cjwq2jfeb002bqxpj4ejypb11"},{"post_id":"cjwq2jfe40021qxpjovmxfrpl","category_id":"cjwq2jfdw001pqxpjevo1jptv","_id":"cjwq2jfee002gqxpjcxa4zqw1"},{"post_id":"cjwq2jfdl0018qxpjd7l75te2","category_id":"cjwq2jfe1001wqxpjxcsunlrz","_id":"cjwq2jfef002iqxpjmd58co0q"},{"post_id":"cjwq2jfe60023qxpjzc1z61ad","category_id":"cjwq2jfdw001pqxpjevo1jptv","_id":"cjwq2jfei002nqxpjo3pz55lc"},{"post_id":"cjwq2jfe90028qxpjzzosd5ja","category_id":"cjwq2jfdw001pqxpjevo1jptv","_id":"cjwq2jfem002pqxpj3fu6vp3n"},{"post_id":"cjwq2jfdn001cqxpjg1dlpx65","category_id":"cjwq2jfe1001wqxpjxcsunlrz","_id":"cjwq2jfeo002uqxpj7f5fy0fi"},{"post_id":"cjwq2jfeb002aqxpjdjn0w6x0","category_id":"cjwq2jfdw001pqxpjevo1jptv","_id":"cjwq2jff0002xqxpj6vhfjbi4"},{"post_id":"cjwq2jfed002fqxpj0lv71031","category_id":"cjwq2jfdw001pqxpjevo1jptv","_id":"cjwq2jff20030qxpj58ouuhjl"},{"post_id":"cjwq2jfdp001fqxpj7eln946a","category_id":"cjwq2jfe1001wqxpjxcsunlrz","_id":"cjwq2jff30032qxpjxg0w4206"},{"post_id":"cjwq2jfef002hqxpjhn1pmrlx","category_id":"cjwq2jfdw001pqxpjevo1jptv","_id":"cjwq2jff40034qxpj2jmjt57z"},{"post_id":"cjwq2jfeh002mqxpj1ut6rvjx","category_id":"cjwq2jfd4000iqxpjwi1bbbqc","_id":"cjwq2jff40036qxpj627j7pra"},{"post_id":"cjwq2jfdt001kqxpjj4nfjitr","category_id":"cjwq2jfe1001wqxpjxcsunlrz","_id":"cjwq2jff50037qxpjg284ze18"},{"post_id":"cjwq2jfek002oqxpjh922rgom","category_id":"cjwq2jfch0002qxpjt85msnvj","_id":"cjwq2jff5003aqxpjjofqu9jd"},{"post_id":"cjwq2jfen002tqxpjk8pcf6bz","category_id":"cjwq2jfch0002qxpjt85msnvj","_id":"cjwq2jff5003bqxpjijslyx5g"},{"post_id":"cjwq2jfdz001uqxpj6432y980","category_id":"cjwq2jfem002qqxpjd9eniytk","_id":"cjwq2jff6003dqxpjy8t22mgj"},{"post_id":"cjwq2jfer002wqxpjmal7c1cp","category_id":"cjwq2jfch0002qxpjt85msnvj","_id":"cjwq2jff6003fqxpjtbu5zg0v"},{"post_id":"cjwq2jff2002zqxpjmrbbio85","category_id":"cjwq2jfch0002qxpjt85msnvj","_id":"cjwq2jff7003hqxpjocsv90p0"}],"PostTag":[{"post_id":"cjwq2jfc40000qxpj419y67ku","tag_id":"cjwq2jfcj0003qxpjxnltxmui","_id":"cjwq2jfcp0009qxpj55x85rok"},{"post_id":"cjwq2jfcc0001qxpj0aji22jt","tag_id":"cjwq2jfco0008qxpjka5wzhs5","_id":"cjwq2jfd1000gqxpjnga5atpy"},{"post_id":"cjwq2jfck0004qxpjxebkb0nn","tag_id":"cjwq2jfcy000eqxpjgfnfcefp","_id":"cjwq2jfd7000mqxpjdhhg9egt"},{"post_id":"cjwq2jfd5000lqxpjrskb6gr4","tag_id":"cjwq2jfd5000kqxpjt80mqeid","_id":"cjwq2jfda000qqxpj1eaiabxr"},{"post_id":"cjwq2jfcm0005qxpjcc6a00yq","tag_id":"cjwq2jfd5000kqxpjt80mqeid","_id":"cjwq2jfdc000tqxpjos2bat3h"},{"post_id":"cjwq2jfcn0006qxpjcdp4t2u7","tag_id":"cjwq2jfd5000kqxpjt80mqeid","_id":"cjwq2jfdg0010qxpjawbro0nu"},{"post_id":"cjwq2jfcp000aqxpjju0h66hc","tag_id":"cjwq2jfd5000kqxpjt80mqeid","_id":"cjwq2jfdk0017qxpjgiaic2iv"},{"post_id":"cjwq2jfcr000bqxpjt8n76jzs","tag_id":"cjwq2jfd5000kqxpjt80mqeid","_id":"cjwq2jfdp001eqxpjeplojjnh"},{"post_id":"cjwq2jfdl0018qxpjd7l75te2","tag_id":"cjwq2jfcy000eqxpjgfnfcefp","_id":"cjwq2jfdr001iqxpj763qkxzb"},{"post_id":"cjwq2jfd0000fqxpjeni252iv","tag_id":"cjwq2jfd5000kqxpjt80mqeid","_id":"cjwq2jfdu001mqxpjj4mzfqdy"},{"post_id":"cjwq2jfd2000hqxpja2l8gcpa","tag_id":"cjwq2jfd5000kqxpjt80mqeid","_id":"cjwq2jfdz001tqxpjee3wuf3v"},{"post_id":"cjwq2jfd7000nqxpjadn1o9m9","tag_id":"cjwq2jfdw001qqxpjsnq0p7ll","_id":"cjwq2jfe30020qxpjaxgk7bl5"},{"post_id":"cjwq2jfdb000sqxpjmkm700au","tag_id":"cjwq2jfdw001qqxpjsnq0p7ll","_id":"cjwq2jfe90027qxpjww1hid37"},{"post_id":"cjwq2jfdd000uqxpjfpk1g19i","tag_id":"cjwq2jfdw001qqxpjsnq0p7ll","_id":"cjwq2jfed002eqxpj5erpfir2"},{"post_id":"cjwq2jfde000yqxpj4244zgd6","tag_id":"cjwq2jfdw001qqxpjsnq0p7ll","_id":"cjwq2jfeg002lqxpjrvfueb91"},{"post_id":"cjwq2jfeh002mqxpj1ut6rvjx","tag_id":"cjwq2jfd5000kqxpjt80mqeid","_id":"cjwq2jfen002sqxpj4co7wg76"},{"post_id":"cjwq2jfdg0011qxpjasiwm64s","tag_id":"cjwq2jfef002kqxpjfe9ao69l","_id":"cjwq2jfeq002vqxpju5ty18dr"},{"post_id":"cjwq2jfdi0015qxpjx947kl52","tag_id":"cjwq2jfem002rqxpjbiw91a9o","_id":"cjwq2jff30031qxpjacfpq3a7"},{"post_id":"cjwq2jfdn001cqxpjg1dlpx65","tag_id":"cjwq2jff0002yqxpj1vy3xuox","_id":"cjwq2jff40035qxpjz9smh459"},{"post_id":"cjwq2jfdp001fqxpj7eln946a","tag_id":"cjwq2jff30033qxpj9j524azo","_id":"cjwq2jff50039qxpjw7vs7szf"},{"post_id":"cjwq2jfdt001kqxpjj4nfjitr","tag_id":"cjwq2jff50038qxpj3javnmjp","_id":"cjwq2jff6003eqxpj3d6zgkb1"},{"post_id":"cjwq2jfdv001nqxpj9d5k4uaa","tag_id":"cjwq2jff5003cqxpjadc0rjra","_id":"cjwq2jff7003iqxpjjfmnr61o"},{"post_id":"cjwq2jfdx001rqxpjso0iahu3","tag_id":"cjwq2jff5003cqxpjadc0rjra","_id":"cjwq2jff7003kqxpjzrvz5lb3"},{"post_id":"cjwq2jfdz001uqxpj6432y980","tag_id":"cjwq2jff7003jqxpj9egryry6","_id":"cjwq2jff8003mqxpjhiy7x4dc"},{"post_id":"cjwq2jfe1001xqxpj0or3z00o","tag_id":"cjwq2jfem002rqxpjbiw91a9o","_id":"cjwq2jff9003oqxpjhqzo1yor"},{"post_id":"cjwq2jfe40021qxpjovmxfrpl","tag_id":"cjwq2jfem002rqxpjbiw91a9o","_id":"cjwq2jffa003qqxpjp2e901m0"},{"post_id":"cjwq2jfe60023qxpjzc1z61ad","tag_id":"cjwq2jfem002rqxpjbiw91a9o","_id":"cjwq2jffa003sqxpj5t1xjlp3"},{"post_id":"cjwq2jfe90028qxpjzzosd5ja","tag_id":"cjwq2jfem002rqxpjbiw91a9o","_id":"cjwq2jffb003uqxpj5wbml317"},{"post_id":"cjwq2jfeb002aqxpjdjn0w6x0","tag_id":"cjwq2jfem002rqxpjbiw91a9o","_id":"cjwq2jffc003wqxpjociakoyw"},{"post_id":"cjwq2jfed002fqxpj0lv71031","tag_id":"cjwq2jfem002rqxpjbiw91a9o","_id":"cjwq2jffd003yqxpjfko3ua8d"},{"post_id":"cjwq2jfef002hqxpjhn1pmrlx","tag_id":"cjwq2jfem002rqxpjbiw91a9o","_id":"cjwq2jffe0040qxpj8j87wx0p"},{"post_id":"cjwq2jfek002oqxpjh922rgom","tag_id":"cjwq2jffe003zqxpjmaqpjlrp","_id":"cjwq2jfff0042qxpjtbx06x3s"},{"post_id":"cjwq2jfen002tqxpjk8pcf6bz","tag_id":"cjwq2jffe003zqxpjmaqpjlrp","_id":"cjwq2jffg0044qxpjw8ziuzku"},{"post_id":"cjwq2jfer002wqxpjmal7c1cp","tag_id":"cjwq2jfff0043qxpj0p7dn8zm","_id":"cjwq2jffg0046qxpjb7ulxmym"},{"post_id":"cjwq2jff2002zqxpjmrbbio85","tag_id":"cjwq2jffg0045qxpj7xs1216k","_id":"cjwq2jffj0047qxpj0nk932lw"}],"Tag":[{"name":"RESTful","_id":"cjwq2jfcj0003qxpjxnltxmui"},{"name":"Hbase","_id":"cjwq2jfco0008qxpjka5wzhs5"},{"name":"MongoDB","_id":"cjwq2jfcy000eqxpjgfnfcefp"},{"name":"Nginx","_id":"cjwq2jfd5000kqxpjt80mqeid"},{"name":"RabbitMQ","_id":"cjwq2jfdw001qqxpjsnq0p7ll"},{"name":"Redis","_id":"cjwq2jfef002kqxpjfe9ao69l"},{"name":"JVM","_id":"cjwq2jfem002rqxpjbiw91a9o"},{"name":"OOM","_id":"cjwq2jff0002yqxpj1vy3xuox"},{"name":"UDP","_id":"cjwq2jff30033qxpj9j524azo"},{"name":"redis","_id":"cjwq2jff50038qxpj3javnmjp"},{"name":"MySQL","_id":"cjwq2jff5003cqxpjadc0rjra"},{"name":"Spring","_id":"cjwq2jff7003jqxpj9egryry6"},{"name":"TDD","_id":"cjwq2jffe003zqxpjmaqpjlrp"},{"name":"设计模式","_id":"cjwq2jfff0043qxpj0p7dn8zm"},{"name":"微服务","_id":"cjwq2jffg0045qxpj7xs1216k"}]}}