---
title: 浅析JAVA垃圾回收
categories:
- JAVA
date: 2017-12-13 
tags:
- JVM
---
#### 哪些内存需要回收？
`栈，寄存器，本地方法区`。这三个区域，内存随线程而生，随线程而灭，不需要过多考虑回收问题。
`堆`和`方法区`。这两个区域，只有在运行期才确定创建那些对象，内存的分配和回收都是动态的。
垃圾回收，回收的是堆和方法区中的内存。

#### 哪些是垃圾对象？
* `引用计数算法`
给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用的。该算法不能解决相互引用问题。

* `可达性分析算法`
从`GC Roots`节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连（用图论的话来说，就是从GC Roots到这个对象不可达）时，则证明此对象是不可用的。
栈，方法区，本地方法栈中的引用对象可作为GC Roots。

#### 垃圾回收算法
* 标记-清除算法
首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。该算法有两个不足，一个是`效率低`，另一个是清除后会出现大量不连续的`内存碎片`。

* 复制算法
把内存分为两块，每次只使用其中的一块。当这一块用完了，就将还存活的对象复制到另一块，然后再把使用过的内存一次清理掉。优点是，`不会出现内存碎片`。缺点是，`缩小内存的大小`。
新对象的内存分配都是先在`Eden区域`中进行的，当Eden区域的空间不足时，所有存活的对象（仍然可达对象）会被拷贝到其中一个`Survivor区域`，同时年龄增长为“1”。并清除整个Eden内存区域中的非可达对象。

* 标记-清理算法
首先标记出所有需要回收的对象，然后将所有存活的对象都向一端移动。

* 分代收集算法
把内存分为`年轻代`和`年老代`。
`年轻代`中，对象大批死去，只有少量存活。选用`复制算法`。
`年老代`中，对象存活率高，选用`标记-清除算法`或`标记-清理`算法